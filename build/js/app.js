/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var bitcorep2p = __webpack_require__(79);

	var pool = new bitcorep2p.Pool();

	pool.on('seed', function(ips) { console.log('seed! '); });
	pool.on('seederror', function(err) { console.log('seederror ', err); });

	var peers = {};

	pool.on('peerready', function(peer, addr) {
	    console.log('adding', addr.hash);
	    peers[addr.hash] = peer;
	});
	pool.on('peertx', function(peer, message) { console.log('peertx: ', peer, ', Message: ', message); });
	pool.on('peeraddrdisconnect', function(peer, addr) {
	    console.log('removing', addr.hash);
	    peers.remove(addr.hash);
	});

	pool.on('peerping', function(peer, message) { console.log('peeraddr: ', peer, ', Message: ', message); });

	pool.connect();

	setTimeout(function(){
	    console.log('numConnected: ', pool.numberConnected());
	},3000);
	//pool.disconnect()


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var base64 = __webpack_require__(121)
	var ieee754 = __webpack_require__(122)
	var isArray = __webpack_require__(123)

	exports.Buffer = Buffer
	exports.SlowBuffer = Buffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var kMaxLength = 0x3fffffff

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Note:
	 *
	 * - Implementation must support adding new properties to `Uint8Array` instances.
	 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
	 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *    incorrect length in some situations.
	 *
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
	 * get the Object implementation, which is slower but will work correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = (function () {
	  try {
	    var buf = new ArrayBuffer(0)
	    var arr = new Uint8Array(buf)
	    arr.foo = function () { return 42 }
	    return 42 === arr.foo() && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	})()

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (subject, encoding, noZero) {
	  if (!(this instanceof Buffer))
	    return new Buffer(subject, encoding, noZero)

	  var type = typeof subject

	  // Find the length
	  var length
	  if (type === 'number')
	    length = subject > 0 ? subject >>> 0 : 0
	  else if (type === 'string') {
	    if (encoding === 'base64')
	      subject = base64clean(subject)
	    length = Buffer.byteLength(subject, encoding)
	  } else if (type === 'object' && subject !== null) { // assume object is array-like
	    if (subject.type === 'Buffer' && isArray(subject.data))
	      subject = subject.data
	    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
	  } else
	    throw new TypeError('must start with number, buffer, array or string')

	  if (this.length > kMaxLength)
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	      'size: 0x' + kMaxLength.toString(16) + ' bytes')

	  var buf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Preferred: Return an augmented `Uint8Array` instance for best performance
	    buf = Buffer._augment(new Uint8Array(length))
	  } else {
	    // Fallback: Return THIS instance of Buffer (created by `new`)
	    buf = this
	    buf.length = length
	    buf._isBuffer = true
	  }

	  var i
	  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
	    // Speed optimization -- use set if we're copying from a typed array
	    buf._set(subject)
	  } else if (isArrayish(subject)) {
	    // Treat array-ish objects as a byte array
	    if (Buffer.isBuffer(subject)) {
	      for (i = 0; i < length; i++)
	        buf[i] = subject.readUInt8(i)
	    } else {
	      for (i = 0; i < length; i++)
	        buf[i] = ((subject[i] % 256) + 256) % 256
	    }
	  } else if (type === 'string') {
	    buf.write(subject, 0, encoding)
	  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
	    for (i = 0; i < length; i++) {
	      buf[i] = 0
	    }
	  }

	  return buf
	}

	Buffer.isBuffer = function (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
	    throw new TypeError('Arguments must be Buffers')

	  var x = a.length
	  var y = b.length
	  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function (list, totalLength) {
	  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

	  if (list.length === 0) {
	    return new Buffer(0)
	  } else if (list.length === 1) {
	    return list[0]
	  }

	  var i
	  if (totalLength === undefined) {
	    totalLength = 0
	    for (i = 0; i < list.length; i++) {
	      totalLength += list[i].length
	    }
	  }

	  var buf = new Buffer(totalLength)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	Buffer.byteLength = function (str, encoding) {
	  var ret
	  str = str + ''
	  switch (encoding || 'utf8') {
	    case 'ascii':
	    case 'binary':
	    case 'raw':
	      ret = str.length
	      break
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      ret = str.length * 2
	      break
	    case 'hex':
	      ret = str.length >>> 1
	      break
	    case 'utf8':
	    case 'utf-8':
	      ret = utf8ToBytes(str).length
	      break
	    case 'base64':
	      ret = base64ToBytes(str).length
	      break
	    default:
	      ret = str.length
	  }
	  return ret
	}

	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined

	// toString(encoding, start=0, end=buffer.length)
	Buffer.prototype.toString = function (encoding, start, end) {
	  var loweredCase = false

	  start = start >>> 0
	  end = end === undefined || end === Infinity ? this.length : end >>> 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase)
	          throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.equals = function (b) {
	  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max)
	      str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  return Buffer.compare(this, b)
	}

	// `get` will be removed in Node 0.13+
	Buffer.prototype.get = function (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` will be removed in Node 0.13+
	Buffer.prototype.set = function (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var byte = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(byte)) throw new Error('Invalid hex string')
	    buf[offset + i] = byte
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
	  return charsWritten
	}

	function asciiWrite (buf, string, offset, length) {
	  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
	  return charsWritten
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
	  return charsWritten
	}

	function utf16leWrite (buf, string, offset, length) {
	  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
	  return charsWritten
	}

	Buffer.prototype.write = function (string, offset, length, encoding) {
	  // Support both (string, offset, length, encoding)
	  // and the legacy (string, encoding, offset, length)
	  if (isFinite(offset)) {
	    if (!isFinite(length)) {
	      encoding = length
	      length = undefined
	    }
	  } else {  // legacy
	    var swap = encoding
	    encoding = offset
	    offset = length
	    length = swap
	  }

	  offset = Number(offset) || 0
	  var remaining = this.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	  encoding = String(encoding || 'utf8').toLowerCase()

	  var ret
	  switch (encoding) {
	    case 'hex':
	      ret = hexWrite(this, string, offset, length)
	      break
	    case 'utf8':
	    case 'utf-8':
	      ret = utf8Write(this, string, offset, length)
	      break
	    case 'ascii':
	      ret = asciiWrite(this, string, offset, length)
	      break
	    case 'binary':
	      ret = binaryWrite(this, string, offset, length)
	      break
	    case 'base64':
	      ret = base64Write(this, string, offset, length)
	      break
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      ret = utf16leWrite(this, string, offset, length)
	      break
	    default:
	      throw new TypeError('Unknown encoding: ' + encoding)
	  }
	  return ret
	}

	Buffer.prototype.toJSON = function () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  var res = ''
	  var tmp = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    if (buf[i] <= 0x7F) {
	      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
	      tmp = ''
	    } else {
	      tmp += '%' + buf[i].toString(16)
	    }
	  }

	  return res + decodeUtf8Char(tmp)
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  return asciiSlice(buf, start, end)
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len;
	    if (start < 0)
	      start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0)
	      end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start)
	    end = start

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    return Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    var newBuf = new Buffer(sliceLen, undefined, true)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	    return newBuf
	  }
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0)
	    throw new RangeError('offset is not uint')
	  if (offset + ext > length)
	    throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUInt8 = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	      ((this[offset + 1] << 16) |
	      (this[offset + 2] << 8) |
	      this[offset + 3])
	}

	Buffer.prototype.readInt8 = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80))
	    return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16) |
	      (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	      (this[offset + 1] << 16) |
	      (this[offset + 2] << 8) |
	      (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function (offset, noAssert) {
	  if (!noAssert)
	    checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new TypeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new TypeError('index out of range')
	}

	Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = value
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else objectWriteUInt16(this, value, offset, true)
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else objectWriteUInt16(this, value, offset, false)
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = value
	  } else objectWriteUInt32(this, value, offset, true)
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else objectWriteUInt32(this, value, offset, false)
	  return offset + 4
	}

	Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = value
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else objectWriteUInt16(this, value, offset, true)
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else objectWriteUInt16(this, value, offset, false)
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else objectWriteUInt32(this, value, offset, true)
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
	  value = +value
	  offset = offset >>> 0
	  if (!noAssert)
	    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else objectWriteUInt32(this, value, offset, false)
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new TypeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new TypeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert)
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert)
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function (target, target_start, start, end) {
	  var source = this

	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (!target_start) target_start = 0

	  // Copy 0 bytes; we're done
	  if (end === start) return
	  if (target.length === 0 || source.length === 0) return

	  // Fatal error conditions
	  if (end < start) throw new TypeError('sourceEnd < sourceStart')
	  if (target_start < 0 || target_start >= target.length)
	    throw new TypeError('targetStart out of bounds')
	  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
	  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length)
	    end = this.length
	  if (target.length - target_start < end - start)
	    end = target.length - target_start + start

	  var len = end - start

	  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < len; i++) {
	      target[i + target_start] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), target_start)
	  }
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new TypeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array get/set methods before overwriting
	  arr._get = arr.get
	  arr._set = arr.set

	  // deprecated, will be removed in node 0.13+
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function isArrayish (subject) {
	  return isArray(subject) || Buffer.isBuffer(subject) ||
	      subject && typeof subject === 'object' &&
	      typeof subject.length === 'number'
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    var b = str.charCodeAt(i)
	    if (b <= 0x7F) {
	      byteArray.push(b)
	    } else {
	      var start = i
	      if (b >= 0xD800 && b <= 0xDFFF) i++
	      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
	      for (var j = 0; j < h.length; j++) {
	        byteArray.push(parseInt(h[j], 16))
	      }
	    }
	  }
	  return byteArray
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(str)
	}

	function blitBuffer (src, dst, offset, length, unitSize) {
	  if (unitSize) length -= length % unitSize;
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length))
	      break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function decodeUtf8Char (str) {
	  try {
	    return decodeURIComponent(str)
	  } catch (err) {
	    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern -o ./lodash.js`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '3.1.0';

	  /** Used to compose bitmasks for wrapper metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      REARG_FLAG = 128,
	      ARY_FLAG = 256;

	  /** Used as default options for `_.trunc`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect when a function becomes hot. */
	  var HOT_COUNT = 150,
	      HOT_SPAN = 16;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 0,
	      LAZY_MAP_FLAG = 1,
	      LAZY_WHILE_FLAG = 2;

	  /** Used as the `TypeError` message for "Functions" methods. */
	  var FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      weakMapTag = '[object WeakMap]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
	      reUnescapedHtml = /[&<>"'`]/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /**
	   * Used to match ES template delimiters.
	   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)
	   * for more details.
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect named functions. */
	  var reFuncName = /^\s*function[ \n\r\t]+\w/;

	  /** Used to detect hexadecimal string values. */
	  var reHexPrefix = /^0[xX]/;

	  /** Used to detect host constructors (Safari > 5). */
	  var reHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
	  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /**
	   * Used to match `RegExp` special characters.
	   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
	   * for more details.
	   */
	  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
	      reHasRegExpChars = RegExp(reRegExpChars.source);

	  /** Used to detect functions containing a `this` reference. */
	  var reThis = /\bthis\b/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to match words to create compound words. */
	  var reWords = (function() {
	    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
	        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

	    return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
	  }());

	  /** Used to detect and test for whitespace. */
	  var whitespace = (
	    // Basic whitespace characters.
	    ' \t\x0b\f\xa0\ufeff' +

	    // Line terminators.
	    '\n\r\u2028\u2029' +

	    // Unicode category "Zs" space separators.
	    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
	  );

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
	    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
	    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    'window', 'WinRTError'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[stringTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[mapTag] = cloneableTags[setTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used as an internal `_.debounce` options object by `_.throttle`. */
	  var debounceOptions = {
	    'leading': false,
	    'maxWait': 0,
	    'trailing': false
	  };

	  /** Used to map latin-1 supplementary letters to basic latin letters. */
	  var deburredLetters = {
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '`': '&#96;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'",
	    '&#96;': '`'
	  };

	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /**
	   * Used as a reference to the global object.
	   *
	   * The `this` value is used if it is the global object to avoid Greasemonkey's
	   * restricted `window` object, otherwise the `window` object is used.
	   */
	  var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;

	  /** Detect free variable `exports`. */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
	  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
	    root = freeGlobal;
	  }

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The base implementation of `compareAscending` which compares values and
	   * sorts them in ascending order without guaranteeing a stable sort.
	   *
	   * @private
	   * @param {*} value The value to compare to `other`.
	   * @param {*} other The value to compare to `value`.
	   * @returns {number} Returns the sort order indicator for `value`.
	   */
	  function baseCompareAscending(value, other) {
	    if (value !== other) {
	      var valIsReflexive = value === value,
	          othIsReflexive = other === other;

	      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
	        return 1;
	      }
	      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
	        return -1;
	      }
	    }
	    return 0;
	  }

	  /**
	   * The base implementation of `_.indexOf` without support for binary searches.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} [fromIndex=0] The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    if (value !== value) {
	      return indexOfNaN(array, fromIndex);
	    }
	    var index = (fromIndex || 0) - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`
	   * to define the sort order of `array` and replaces criteria objects with their
	   * corresponding values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;

	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }

	  /**
	   * Converts `value` to a string if it is not one. An empty string is returned
	   * for `null` or `undefined` values.
	   *
	   * @private
	   * @param {*} value The value to process.
	   * @returns {string} Returns the string.
	   */
	  function baseToString(value) {
	    if (typeof value == 'string') {
	      return value;
	    }
	    return value == null ? '' : (value + '');
	  }

	  /**
	   * Used by `_.max` and `_.min` as the default callback for string values.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the code unit of the first character of the string.
	   */
	  function charAtCallback(string) {
	    return string.charCodeAt(0);
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the first character not found in `chars`.
	   */
	  function charsLeftIndex(string, chars) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the last character not found in `chars`.
	   */
	  function charsRightIndex(string, chars) {
	    var index = string.length;

	    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.sortBy` to compare transformed elements of a collection and stable
	   * sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare to `other`.
	   * @param {Object} other The object to compare to `object`.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareAscending(object, other) {
	    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
	  }

	  /**
	   * Used by `_.sortByAll` to compare multiple properties of each element
	   * in a collection and stable sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare to `other`.
	   * @param {Object} other The object to compare to `object`.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareMultipleAscending(object, other) {
	    var index = -1,
	        objCriteria = object.criteria,
	        othCriteria = other.criteria,
	        length = objCriteria.length;

	    while (++index < length) {
	      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
	      if (result) {
	        return result;
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to provide the same value for
	    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	    // for more details.
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
	    return object.index - other.index;
	  }

	  /**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  function deburrLetter(letter) {
	    return deburredLetters[letter];
	  }

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeHtmlChar(chr) {
	    return htmlEscapes[chr];
	  }

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled
	   * string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   * If `fromRight` is provided elements of `array` are iterated from right to left.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} [fromIndex] The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */
	  function indexOfNaN(array, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);

	    while ((fromRight ? index-- : ++index < length)) {
	      var other = array[index];
	      if (other !== other) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * Checks if `value` is object-like.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   */
	  function isObjectLike(value) {
	    return (value && typeof value == 'object') || false;
	  }

	  /**
	   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
	   * character code is whitespace.
	   *
	   * @private
	   * @param {number} charCode The character code to inspect.
	   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
	   */
	  function isSpace(charCode) {
	    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
	      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      if (array[index] === placeholder) {
	        array[index] = PLACEHOLDER;
	        result[++resIndex] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * An implementation of `_.uniq` optimized for sorted arrays without support
	   * for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} [iteratee] The function invoked per iteration.
	   * @returns {Array} Returns the new duplicate-value-free array.
	   */
	  function sortedUniq(array, iteratee) {
	    var seen,
	        index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      var value = array[index],
	          computed = iteratee ? iteratee(value, index, array) : value;

	      if (!index || seen !== computed) {
	        seen = computed;
	        result[++resIndex] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the first non-whitespace character.
	   */
	  function trimmedLeftIndex(string) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedRightIndex(string) {
	    var index = string.length;

	    while (index-- && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(chr) {
	    return htmlUnescapes[chr];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the given `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utility
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'add': function(a, b) { return a + b; } });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'sub': function(a, b) { return a - b; } });
	   *
	   * _.isFunction(_.add);
	   * // => true
	   * _.isFunction(_.sub);
	   * // => false
	   *
	   * lodash.isFunction(lodash.add);
	   * // => false
	   * lodash.isFunction(lodash.sub);
	   * // => true
	   *
	   * // using `context` to mock `Date#getTime` use in `_.now`
	   * var mock = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': getTimeMock };
	   *   }
	   * });
	   *
	   * // or creating a suped-up `defer` in Node.js
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See https://es5.github.io/#x11.1.5 for more details.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

	    /** Native constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for native method references. */
	    var arrayProto = Array.prototype,
	        objectProto = Object.prototype;

	    /** Used to detect DOM support. */
	    var document = (document = context.window) && document.document;

	    /** Used to resolve the decompiled source of functions. */
	    var fnToString = Function.prototype.toString;

	    /** Used to the length of n-tuples for `_.unzip`. */
	    var getLength = baseProperty('length');

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /**
	     * Used to resolve the `toStringTag` of values.
	     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	     * for more details.
	     */
	    var objToString = objectProto.toString;

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = context._;

	    /** Used to detect if a method is native. */
	    var reNative = RegExp('^' +
	      escapeRegExp(objToString)
	      .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Native method references. */
	    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
	        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
	        ceil = Math.ceil,
	        clearTimeout = context.clearTimeout,
	        floor = Math.floor,
	        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
	        push = arrayProto.push,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        Set = isNative(Set = context.Set) && Set,
	        setTimeout = context.setTimeout,
	        splice = arrayProto.splice,
	        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
	        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;

	    /** Used to clone array buffers. */
	    var Float64Array = (function() {
	      // Safari 5 errors when using an array buffer to initialize a typed array
	      // where the array buffer's `byteLength` is not a multiple of the typed
	      // array's `BYTES_PER_ELEMENT`.
	      try {
	        var func = isNative(func = context.Float64Array) && func,
	            result = new func(new ArrayBuffer(10), 0, 1) && func;
	      } catch(e) {}
	      return result;
	    }());

	    /* Native method references for those with the same name as other `lodash` methods. */
	    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
	        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
	        nativeIsFinite = context.isFinite,
	        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = isNative(nativeNow = Date.now) && nativeNow,
	        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;

	    /** Used as references for `-Infinity` and `Infinity`. */
	    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
	        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

	    /** Used as references for the maximum length and index of an array. */
	    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
	        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
	        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	    /** Used as the size, in bytes, of each `Float64Array` element. */
	    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

	    /**
	     * Used as the maximum length of an array-like value.
	     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	     * for more details.
	     */
	    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
	     * Methods that operate on and return arrays, collections, and functions can
	     * be chained together. Methods that return a boolean or single value will
	     * automatically end the chain returning the unwrapped value. Explicit chaining
	     * may be enabled using `_.chain`. The execution of chained methods is lazy,
	     * that is, execution is deferred until `_#value` is implicitly or explicitly
	     * called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
	     * fusion is an optimization that merges iteratees to avoid creating intermediate
	     * arrays and reduce the number of iteratee executions.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers also have the following `Array` methods:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
	     * and `unshift`
	     *
	     * The wrapper functions that support shortcut fusion are:
	     * `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`, `first`,
	     * `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`, `slice`,
	     * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `where`
	     *
	     * The chainable wrapper functions are:
	     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
	     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
	     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
	     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
	     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
	     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
	     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
	     * `keysIn`, `map`, `mapValues`, `matches`, `memoize`, `merge`, `mixin`,
	     * `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
	     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
	     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
	     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `splice`, `spread`,
	     * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,
	     * `thru`, `times`, `toArray`, `toPlainObject`, `transform`, `union`, `uniq`,
	     * `unshift`, `unzip`, `values`, `valuesIn`, `where`, `without`, `wrap`, `xor`,
	     * `zip`, and `zipObject`
	     *
	     * The wrapper functions that are **not** chainable by default are:
	     * `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
	     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
	     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
	     * `identity`, `includes`, `indexOf`, `isArguments`, `isArray`, `isBoolean`,
	     * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`,
	     * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
	     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
	     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
	     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
	     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
	     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
	     * `startCase`, `startsWith`, `template`, `trim`, `trimLeft`, `trimRight`,
	     * `trunc`, `unescape`, `uniqueId`, `value`, and `words`
	     *
	     * The wrapper function `sample` will return a wrapped value when `n` is provided,
	     * otherwise an unwrapped value is returned.
	     *
	     * @name _
	     * @constructor
	     * @category Chain
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(sum, n) { return sum + n; });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(n) { return n * n; });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
	     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
	     */
	    function LodashWrapper(value, chainAll, actions) {
	      this.__wrapped__ = value;
	      this.__actions__ = actions || [];
	      this.__chain__ = !!chainAll;
	    }

	    /**
	     * An object environment feature flags.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};

	    (function(x) {

	      /**
	       * Detect if functions can be decompiled by `Function#toString`
	       * (all but Firefox OS certified apps, older Opera mobile browsers, and
	       * the PlayStation 3; forced `false` for Windows 8 apps).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

	      /**
	       * Detect if `Function#name` is supported (all but IE).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.funcNames = typeof Function.name == 'string';

	      /**
	       * Detect if the DOM is supported.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      try {
	        support.dom = document.createDocumentFragment().nodeType === 11;
	      } catch(e) {
	        support.dom = false;
	      }

	      /**
	       * Detect if `arguments` object indexes are non-enumerable.
	       *
	       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
	       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
	       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
	       * checks for indexes that exceed their function's formal parameters with
	       * associated values of `0`.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      try {
	        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
	      } catch(e) {
	        support.nonEnumArgs = true;
	      }
	    }(0, 0));

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = null;
	      this.__dir__ = 1;
	      this.__dropCount__ = 0;
	      this.__filtered__ = false;
	      this.__iteratees__ = null;
	      this.__takeCount__ = POSITIVE_INFINITY;
	      this.__views__ = null;
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var actions = this.__actions__,
	          iteratees = this.__iteratees__,
	          views = this.__views__,
	          result = new LazyWrapper(this.__wrapped__);

	      result.__actions__ = actions ? arrayCopy(actions) : null;
	      result.__dir__ = this.__dir__;
	      result.__dropCount__ = this.__dropCount__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = views ? arrayCopy(views) : null;
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value();
	      if (!isArray(array)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var dir = this.__dir__,
	          isRight = dir < 0,
	          view = getView(0, array.length, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          dropCount = this.__dropCount__,
	          takeCount = nativeMin(length, this.__takeCount__ - dropCount),
	          index = isRight ? end : start - 1,
	          iteratees = this.__iteratees__,
	          iterLength = iteratees ? iteratees.length : 0,
	          resIndex = 0,
	          result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              computed = iteratee(value, index, array),
	              type = data.type;

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        if (dropCount) {
	          dropCount--;
	        } else {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a cache object to store key/value pairs.
	     *
	     * @private
	     * @static
	     * @name Cache
	     * @memberOf _.memoize
	     */
	    function MapCache() {
	      this.__data__ = {};
	    }

	    /**
	     * Removes `key` and its value from the cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
	     */
	    function mapDelete(key) {
	      return this.has(key) && delete this.__data__[key];
	    }

	    /**
	     * Gets the cached value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the cached value.
	     */
	    function mapGet(key) {
	      return key == '__proto__' ? undefined : this.__data__[key];
	    }

	    /**
	     * Checks if a cached value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapHas(key) {
	      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
	    }

	    /**
	     * Adds `value` to `key` of the cache.
	     *
	     * @private
	     * @name set
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to cache.
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache object.
	     */
	    function mapSet(key, value) {
	      if (key != '__proto__') {
	        this.__data__[key] = value;
	      }
	      return this;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates a cache object to store unique values.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var length = values ? values.length : 0;

	      this.data = { 'hash': nativeCreate(null), 'set': new Set };
	      while (length--) {
	        this.push(values[length]);
	      }
	    }

	    /**
	     * Checks if `value` is in `cache` mimicking the return signature of
	     * `_.indexOf` by returning `0` if the value is found, else `-1`.
	     *
	     * @private
	     * @param {Object} cache The cache to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `0` if `value` is found, else `-1`.
	     */
	    function cacheIndexOf(cache, value) {
	      var data = cache.data,
	          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

	      return result ? 0 : -1;
	    }

	    /**
	     * Adds `value` to the cache.
	     *
	     * @private
	     * @name push
	     * @memberOf SetCache
	     * @param {*} value The value to cache.
	     */
	    function cachePush(value) {
	      var data = this.data;
	      if (typeof value == 'string' || isObject(value)) {
	        data.set.add(value);
	      } else {
	        data.hash[value] = true;
	      }
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayCopy(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEach` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEach(array, iteratee) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (iteratee(array[index], index, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEachRight` for arrays without support for
	     * callback shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEachRight(array, iteratee) {
	      var length = array.length;

	      while (length--) {
	        if (iteratee(array[length], length, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.every` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     */
	    function arrayEvery(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (!predicate(array[index], index, array)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `_.filter` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function arrayFilter(array, predicate) {
	      var index = -1,
	          length = array.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.map` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function arrayMap(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = iteratee(array[index], index, array);
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.max` for arrays without support for iteratees.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     */
	    function arrayMax(array) {
	      var index = -1,
	          length = array.length,
	          result = NEGATIVE_INFINITY;

	      while (++index < length) {
	        var value = array[index];
	        if (value > result) {
	          result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.min` for arrays without support for iteratees.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     */
	    function arrayMin(array) {
	      var index = -1,
	          length = array.length,
	          result = POSITIVE_INFINITY;

	      while (++index < length) {
	        var value = array[index];
	        if (value < result) {
	          result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.reduce` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the first element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduce(array, iteratee, accumulator, initFromArray) {
	      var index = -1,
	          length = array.length;

	      if (initFromArray && length) {
	        accumulator = array[++index];
	      }
	      while (++index < length) {
	        accumulator = iteratee(accumulator, array[index], index, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.reduceRight` for arrays without support for
	     * callback shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the last element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
	      var length = array.length;
	      if (initFromArray && length) {
	        accumulator = array[--length];
	      }
	      while (length--) {
	        accumulator = iteratee(accumulator, array[length], length, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.some` for arrays without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function arraySome(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return true;
	        }
	      }
	      return false;
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assign` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignDefaults(objectValue, sourceValue) {
	      return typeof objectValue == 'undefined' ? sourceValue : objectValue;
	    }

	    /**
	     * Used by `_.template` to customize its `_.assign` use.
	     *
	     * **Note:** This method is like `assignDefaults` except that it ignores
	     * inherited property values when checking if a property is `undefined`.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @param {string} key The key associated with the object and source values.
	     * @param {Object} object The destination object.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignOwnDefaults(objectValue, sourceValue, key, object) {
	      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))
	        ? sourceValue
	        : objectValue;
	    }

	    /**
	     * The base implementation of `_.assign` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize assigning values.
	     * @returns {Object} Returns the destination object.
	     */
	    function baseAssign(object, source, customizer) {
	      var props = keys(source);
	      if (!customizer) {
	        return baseCopy(source, object, props);
	      }
	      var index = -1,
	          length = props.length

	      while (++index < length) {
	        var key = props[index],
	            value = object[key],
	            result = customizer(value, source[key], key, object, source);

	        if ((result === result ? result !== value : value === value) ||
	            (typeof value == 'undefined' && !(key in object))) {
	          object[key] = result;
	        }
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.at` without support for strings and individual
	     * key arguments.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.
	     * @returns {Array} Returns the new array of picked elements.
	     */
	    function baseAt(collection, props) {
	      var index = -1,
	          length = collection.length,
	          isArr = isLength(length),
	          propsLength = props.length,
	          result = Array(propsLength);

	      while(++index < propsLength) {
	        var key = props[index];
	        if (isArr) {
	          key = parseFloat(key);
	          result[index] = isIndex(key, length) ? collection[key] : undefined;
	        } else {
	          result[index] = collection[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies the properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Array} props The property names to copy.
	     * @returns {Object} Returns `object`.
	     */
	    function baseCopy(source, object, props) {
	      if (!props) {
	        props = object;
	        object = {};
	      }
	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];
	        object[key] = source[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.bindAll` without support for individual
	     * method name arguments.
	     *
	     * @private
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {string[]} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     */
	    function baseBindAll(object, methodNames) {
	      var index = -1,
	          length = methodNames.length;

	      while (++index < length) {
	        var key = methodNames[index];
	        object[key] = createWrapper(object[key], BIND_FLAG, object);
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.callback` which supports specifying the
	     * number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function baseCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (type == 'function') {
	        return (typeof thisArg != 'undefined' && isBindable(func))
	          ? bindCallback(func, thisArg, argCount)
	          : func;
	      }
	      if (func == null) {
	        return identity;
	      }
	      // Handle "_.property" and "_.matches" style callback shorthands.
	      return type == 'object'
	        ? baseMatches(func)
	        : baseProperty(func + '');
	    }

	    /**
	     * The base implementation of `_.clone` without support for argument juggling
	     * and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The object `value` belongs to.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object) : customizer(value);
	      }
	      if (typeof result != 'undefined') {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return arrayCopy(value, result);
	        }
	      } else {
	        var tag = objToString.call(value),
	            isFunc = tag == funcTag;

	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return baseCopy(value, result, keys(value));
	          }
	        } else {
	          return cloneableTags[tag]
	            ? initCloneByTag(value, tag, isDeep)
	            : (object ? value : {});
	        }
	      }
	      // Check for circular references and return corresponding clone.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == value) {
	          return stackB[length];
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate it with its clone.
	      stackA.push(value);
	      stackB.push(result);

	      // Recursively populate clone (susceptible to call stack limits).
	      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function Object() {}
	      return function(prototype) {
	        if (isObject(prototype)) {
	          Object.prototype = prototype;
	          var result = new Object;
	          Object.prototype = null;
	        }
	        return result || context.Object();
	      };
	    }());

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts an index
	     * of where to slice the arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The `arguments` object to slice and provide to `func`.
	     * @returns {number} Returns the timer id.
	     */
	    function baseDelay(func, wait, args, fromIndex) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);
	    }

	    /**
	     * The base implementation of `_.difference` which accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var length = array ? array.length : 0,
	          result = [];

	      if (!length) {
	        return result;
	      }
	      var index = -1,
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          cache = isCommon && values.length >= 200 && createCache(values),
	          valuesLength = values.length;

	      if (cache) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	        values = cache;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index];

	        if (isCommon && value === value) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === value) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (indexOf(values, value) < 0) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    function baseEach(collection, iteratee) {
	      var length = collection ? collection.length : 0;
	      if (!isLength(length)) {
	        return baseForOwn(collection, iteratee);
	      }
	      var index = -1,
	          iterable = toObject(collection);

	      while (++index < length) {
	        if (iteratee(iterable[index], index, iterable) === false) {
	          break;
	        }
	      }
	      return collection;
	    }

	    /**
	     * The base implementation of `_.forEachRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    function baseEachRight(collection, iteratee) {
	      var length = collection ? collection.length : 0;
	      if (!isLength(length)) {
	        return baseForOwnRight(collection, iteratee);
	      }
	      var iterable = toObject(collection);
	      while (length--) {
	        if (iteratee(iterable[length], length, iterable) === false) {
	          break;
	        }
	      }
	      return collection;
	    }

	    /**
	     * The base implementation of `_.every` without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : end >>> 0;
	      start >>>= 0;

	      while (start < length) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
	     * without support for callback shorthands and `this` binding, which iterates
	     * over `collection` using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @param {boolean} [retKey] Specify returning the key of the found element
	     *  instead of the element itself.
	     * @returns {*} Returns the found element or its key, else `undefined`.
	     */
	    function baseFind(collection, predicate, eachFunc, retKey) {
	      var result;
	      eachFunc(collection, function(value, key, collection) {
	        if (predicate(value, key, collection)) {
	          result = retKey ? key : value;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with added support for restricting
	     * flattening and specifying the start index.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.
	     * @param {number} [fromIndex=0] The index to start from.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, isDeep, isStrict, fromIndex) {
	      var index = (fromIndex || 0) - 1,
	          length = array.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];

	        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
	          if (isDeep) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            value = baseFlatten(value, isDeep, isStrict);
	          }
	          var valIndex = -1,
	              valLength = value.length;

	          result.length += valLength;
	          while (++valIndex < valLength) {
	            result[++resIndex] = value[valIndex];
	          }
	        } else if (!isStrict) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForIn` and `baseForOwn` which iterates
	     * over `object` properties returned by `keysFunc` invoking `iteratee` for
	     * each property. Iterator functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    function baseFor(object, iteratee, keysFunc) {
	      var index = -1,
	          iterable = toObject(object),
	          props = keysFunc(object),
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];
	        if (iteratee(iterable[key], key, iterable) === false) {
	          break;
	        }
	      }
	      return object;
	    }

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForRight(object, iteratee, keysFunc) {
	      var iterable = toObject(object),
	          props = keysFunc(object),
	          length = props.length;

	      while (length--) {
	        var key = props[length];
	        if (iteratee(iterable[key], key, iterable) === false) {
	          break;
	        }
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.forIn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForIn(object, iteratee) {
	      return baseFor(object, iteratee, keysIn);
	    }

	    /**
	     * The base implementation of `_.forOwn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from those provided.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the new array of filtered property names.
	     */
	    function baseFunctions(object, props) {
	      var index = -1,
	          length = props.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var key = props[index];
	        if (isFunction(object[key])) {
	          result[++resIndex] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.invoke` which requires additional arguments
	     * to be provided as an array of arguments rather than individually.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|string} methodName The name of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {Array} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     */
	    function baseInvoke(collection, methodName, args) {
	      var index = -1,
	          isFunc = typeof methodName == 'function',
	          length = collection ? collection.length : 0,
	          result = isLength(length) ? Array(length) : [];

	      baseEach(collection, function(value) {
	        var func = isFunc ? methodName : (value != null && value[methodName]);
	        result[++index] = func ? func.apply(value, args) : undefined;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.isEqual` without support for `this` binding
	     * `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isWhere] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
	      // Exit early for identical values.
	      if (value === other) {
	        // Treat `+0` vs. `-0` as not equal.
	        return value !== 0 || (1 / value == 1 / other);
	      }
	      var valType = typeof value,
	          othType = typeof other;

	      // Exit early for unlike primitive values.
	      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
	          value == null || other == null) {
	        // Return `false` unless both values are `NaN`.
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @param {boolean} [isWhere] Specify performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;

	      if (!objIsArr) {
	        objTag = objToString.call(object);
	        if (objTag == argsTag) {
	          objTag = objectTag;
	        } else if (objTag != objectTag) {
	          objIsArr = isTypedArray(object);
	        }
	      }
	      if (!othIsArr) {
	        othTag = objToString.call(other);
	        if (othTag == argsTag) {
	          othTag = objectTag;
	        } else if (othTag != objectTag) {
	          othIsArr = isTypedArray(other);
	        }
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && !(objIsArr || objIsObj)) {
	        return equalByTag(object, other, objTag);
	      }
	      var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	          othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	      if (valWrapped || othWrapped) {
	        return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      // For more information on detecting circular references see https://es5.github.io/#JO.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == object) {
	          return stackB[length] == other;
	        }
	      }
	      // Add `object` and `other` to the stack of traversed objects.
	      stackA.push(object);
	      stackB.push(other);

	      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

	      stackA.pop();
	      stackB.pop();

	      return result;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for callback
	     * shorthands or `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The source property names to match.
	     * @param {Array} values The source values to match.
	     * @param {Array} strictCompareFlags Strict comparison flags for source values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      var index = -1,
	          noCustomizer = !customizer;

	      while (++index < length) {
	        if ((noCustomizer && strictCompareFlags[index])
	              ? values[index] !== object[props[index]]
	              : !hasOwnProperty.call(object, props[index])
	            ) {
	          return false;
	        }
	      }
	      index = -1;
	      while (++index < length) {
	        var key = props[index];
	        if (noCustomizer && strictCompareFlags[index]) {
	          var result = hasOwnProperty.call(object, key);
	        } else {
	          var objValue = object[key],
	              srcValue = values[index];

	          result = customizer ? customizer(objValue, srcValue, key) : undefined;
	          if (typeof result == 'undefined') {
	            result = baseIsEqual(srcValue, objValue, customizer, true);
	          }
	        }
	        if (!result) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.map` without support for callback shorthands
	     * or `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var result = [];
	      baseEach(collection, function(value, key, collection) {
	        result.push(iteratee(value, key, collection));
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which supports specifying whether
	     * `source` should be cloned.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatches(source) {
	      var props = keys(source),
	          length = props.length;

	      if (length == 1) {
	        var key = props[0],
	            value = source[key];

	        if (isStrictComparable(value)) {
	          return function(object) {
	            return object != null && value === object[key] && hasOwnProperty.call(object, key);
	          };
	        }
	      }
	      var values = Array(length),
	          strictCompareFlags = Array(length);

	      while (length--) {
	        value = source[props[length]];
	        values[length] = value;
	        strictCompareFlags[length] = isStrictComparable(value);
	      }
	      return function(object) {
	        return baseIsMatch(object, props, values, strictCompareFlags);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize merging properties.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {Object} Returns the destination object.
	     */
	    function baseMerge(object, source, customizer, stackA, stackB) {
	      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));

	      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
	        if (isObjectLike(srcValue)) {
	          stackA || (stackA = []);
	          stackB || (stackB = []);
	          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
	        }
	        var value = object[key],
	            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	            isCommon = typeof result == 'undefined';

	        if (isCommon) {
	          result = srcValue;
	        }
	        if ((isSrcArr || typeof result != 'undefined') &&
	            (isCommon || (result === result ? result !== value : value === value))) {
	          object[key] = result;
	        }
	      });
	      return object;
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize merging properties.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
	      var length = stackA.length,
	          srcValue = source[key];

	      while (length--) {
	        if (stackA[length] == srcValue) {
	          object[key] = stackB[length];
	          return;
	        }
	      }
	      var value = object[key],
	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	          isCommon = typeof result == 'undefined';

	      if (isCommon) {
	        result = srcValue;
	        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
	          result = isArray(value)
	            ? value
	            : (value ? arrayCopy(value) : []);
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          result = isArguments(value)
	            ? toPlainObject(value)
	            : (isPlainObject(value) ? value : {});
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate
	      // it with its merged value.
	      stackA.push(srcValue);
	      stackB.push(result);

	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
	      } else if (result === result ? result !== value : value === value) {
	        object[key] = result;
	      }
	    }

	    /**
	     * The base implementation of `_.property` which does not coerce `key` to a string.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function baseProperty(key) {
	      return function(object) {
	        return object == null ? undefined : object[key];
	      };
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * index arguments.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     */
	    function basePullAt(array, indexes) {
	      var length = indexes.length,
	          result = baseAt(array, indexes);

	      indexes.sort(baseCompareAscending);
	      while (length--) {
	        var index = parseFloat(indexes[length]);
	        if (index != previous && isIndex(index)) {
	          var previous = index;
	          splice.call(array, index, 1);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.random` without support for argument juggling
	     * and returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(min, max) {
	      return min + floor(nativeRandom() * (max - min + 1));
	    }

	    /**
	     * The base implementation of `_.reduce` and `_.reduceRight` without support
	     * for callback shorthands or `this` binding, which iterates over `collection`
	     * using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} accumulator The initial value.
	     * @param {boolean} initFromCollection Specify using the first or last element
	     *  of `collection` as the initial value.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @returns {*} Returns the accumulated value.
	     */
	    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
	      eachFunc(collection, function(value, index, collection) {
	        accumulator = initFromCollection
	          ? (initFromCollection = false, value)
	          : iteratee(accumulator, value, index, collection)
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : (end - start) >>> 0;
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for callback shorthands
	     * or `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The function invoked per iteration.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     */
	    function baseUniq(array, iteratee) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array.length,
	          isCommon = indexOf == baseIndexOf,
	          isLarge = isCommon && length >= 200,
	          seen = isLarge && createCache(),
	          result = [];

	      if (seen) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	      } else {
	        isLarge = false;
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value, index, array) : value;

	        if (isCommon && value === value) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (indexOf(seen, computed) < 0) {
	          if (iteratee || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.values` and `_.valuesIn` which creates an
	     * array of `object` property values corresponding to the property names
	     * returned by `keysFunc`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} props The property names to get values for.
	     * @returns {Object} Returns the array of property values.
	     */
	    function baseValues(object, props) {
	      var index = -1,
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to peform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved unwrapped value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      var index = -1,
	          length = actions.length;

	      while (++index < length) {
	        var args = [result],
	            action = actions[index];

	        push.apply(args, action.args);
	        result = action.func.apply(action.thisArg, args);
	      }
	      return result;
	    }

	    /**
	     * Performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest, instead
	     *  of the lowest, index at which a value should be inserted into `array`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndex(array, value, retHighest) {
	      var low = 0,
	          high = array ? array.length : low;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if (retHighest ? (computed <= value) : (computed < value)) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return binaryIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * This function is like `binaryIndex` except that it invokes `iteratee` for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [retHighest] Specify returning the highest, instead
	     *  of the lowest, index at which a value should be inserted into `array`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array ? array.length : 0,
	          valIsNaN = value !== value,
	          valIsUndef = typeof value == 'undefined';

	      while (low < high) {
	        var mid = floor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            isReflexive = computed === computed;

	        if (valIsNaN) {
	          var setLow = isReflexive || retHighest;
	        } else if (valIsUndef) {
	          setLow = isReflexive && (retHighest || typeof computed != 'undefined');
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * A specialized version of `baseCallback` which only supports `this` binding
	     * and specifying the number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function bindCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      if (typeof thisArg == 'undefined') {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	        case 5: return function(value, other, key, object, source) {
	          return func.call(thisArg, value, other, key, object, source);
	        };
	      }
	      return function() {
	        return func.apply(thisArg, arguments);
	      };
	    }

	    /**
	     * Creates a clone of the given array buffer.
	     *
	     * @private
	     * @param {ArrayBuffer} buffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function bufferClone(buffer) {
	      return bufferSlice.call(buffer, 0);
	    }
	    if (!bufferSlice) {
	      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
	      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
	        var byteLength = buffer.byteLength,
	            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
	            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
	            result = new ArrayBuffer(byteLength);

	        if (floatLength) {
	          var view = new Float64Array(result, 0, floatLength);
	          view.set(new Float64Array(buffer, 0, floatLength));
	        }
	        if (byteLength != offset) {
	          view = new Uint8Array(result, offset);
	          view.set(new Uint8Array(buffer, offset));
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders) {
	      var holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          leftIndex = -1,
	          leftLength = partials.length,
	          result = Array(argsLength + leftLength);

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        result[holders[argsIndex]] = args[argsIndex];
	      }
	      while (argsLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders) {
	      var holdersIndex = -1,
	          holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          rightIndex = -1,
	          rightLength = partials.length,
	          result = Array(argsLength + rightLength);

	      while (++argsIndex < argsLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var pad = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[pad + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        result[pad + holders[holdersIndex]] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * Creates a function that aggregates a collection, creating an accumulator
	     * object composed from the results of running each element in the collection
	     * through an iteratee. The `setter` sets the keys and values of the accumulator
	     * object. If `initializer` is provided initializes the accumulator object.
	     *
	     * @private
	     * @param {Function} setter The function to set keys and values of the accumulator object.
	     * @param {Function} [initializer] The function to initialize the accumulator object.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee, thisArg) {
	        var result = initializer ? initializer() : {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;

	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, iteratee(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, iteratee(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that assigns properties of source object(s) to a given
	     * destination object.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return function() {
	        var length = arguments.length,
	            object = arguments[0];

	        if (length < 2 || object == null) {
	          return object;
	        }
	        if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
	          length = 2;
	        }
	        // Juggle arguments.
	        if (length > 3 && typeof arguments[length - 2] == 'function') {
	          var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
	        } else if (length > 2 && typeof arguments[length - 1] == 'function') {
	          customizer = arguments[--length];
	        }
	        var index = 0;
	        while (++index < length) {
	          var source = arguments[index];
	          if (source) {
	            assigner(object, source, customizer);
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createBindWrapper(func, thisArg) {
	      var Ctor = createCtorWrapper(func);

	      function wrapper() {
	        return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `Set` cache object to optimize linear searches of large arrays.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	     */
	    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
	      return new SetCache(values);
	    };

	    /**
	     * Creates a function that produces compound words out of the words in a
	     * given string.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        var index = -1,
	            array = words(deburr(string)),
	            length = array.length,
	            result = '';

	        while (++index < length) {
	          result = callback(result, array[index], index);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtorWrapper(Ctor) {
	      return function() {
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, arguments);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a function that gets the extremum value of a collection.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to get the extremum value from an array.
	     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,
	     *  extremum value.
	     * @returns {Function} Returns the new extremum function.
	     */
	    function createExtremum(arrayFunc, isMin) {
	      return function(collection, iteratee, thisArg) {
	        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	          iteratee = null;
	        }
	        var func = getCallback(),
	            noIteratee = iteratee == null;

	        if (!(func === baseCallback && noIteratee)) {
	          noIteratee = false;
	          iteratee = func(iteratee, thisArg, 3);
	        }
	        if (noIteratee) {
	          var isArr = isArray(collection);
	          if (!isArr && isString(collection)) {
	            iteratee = charAtCallback;
	          } else {
	            return arrayFunc(isArr ? collection : toIterable(collection));
	          }
	        }
	        return extremumBy(collection, iteratee, isMin);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with optional `this`
	     * binding of, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurry = bitmask & CURRY_FLAG,
	          isCurryBound = bitmask & CURRY_BOUND_FLAG,
	          isCurryRight = bitmask & CURRY_RIGHT_FLAG;

	      var Ctor = !isBindKey && createCtorWrapper(func),
	          key = func;

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it to other functions.
	        var length = arguments.length,
	            index = length,
	            args = Array(length);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight);
	        }
	        if (isCurry || isCurryRight) {
	          var placeholder = wrapper.placeholder,
	              argsHolders = replaceHolders(args, placeholder);

	          length -= argsHolders.length;
	          if (length < arity) {
	            var newArgPos = argPos ? arrayCopy(argPos) : null,
	                newArity = nativeMax(arity - length, 0),
	                newsHolders = isCurry ? argsHolders : null,
	                newHoldersRight = isCurry ? null : argsHolders,
	                newPartials = isCurry ? args : null,
	                newPartialsRight = isCurry ? null : args;

	            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

	            if (!isCurryBound) {
	              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	            }
	            var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
	            result.placeholder = placeholder;
	            return result;
	          }
	        }
	        var thisBinding = isBind ? thisArg : this;
	        if (isBindKey) {
	          func = thisBinding[key];
	        }
	        if (argPos) {
	          args = reorder(args, argPos);
	        }
	        if (isAry && ary < args.length) {
	          args.length = ary;
	        }
	        return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates the pad required for `string` based on the given padding length.
	     * The `chars` string may be truncated if the number of padding characters
	     * exceeds the padding length.
	     *
	     * @private
	     * @param {string} string The string to create padding for.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the pad for `string`.
	     */
	    function createPad(string, length, chars) {
	      var strLength = string.length;
	      length = +length;

	      if (strLength >= length || !nativeIsFinite(length)) {
	        return '';
	      }
	      var padLength = length - strLength;
	      chars = chars == null ? ' ' : (chars + '');
	      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the optional `this`
	     * binding of `thisArg` and the `partials` prepended to those provided to
	     * the wrapper.
	     *
	     * @private
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to the new function.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createPartialWrapper(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it `func`.
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(argsLength + leftLength);

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = null;
	      }
	      length -= (holders ? holders.length : 0);
	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = null;
	      }
	      var data = !isBindKey && getData(func),
	          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

	      if (data && data !== true) {
	        mergeData(newData, data);
	        bitmask = newData[1];
	        arity = newData[9];
	      }
	      newData[9] = arity == null
	        ? (isBindKey ? 0 : func.length)
	        : (nativeMax(arity - length, 0) || 0);

	      if (bitmask == BIND_FLAG) {
	        var result = createBindWrapper(newData[0], newData[2]);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
	        result = createPartialWrapper.apply(undefined, newData);
	      } else {
	        result = createHybridWrapper.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setter(result, newData);
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing arrays.
	     * @param {boolean} [isWhere] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
	      var index = -1,
	          arrLength = array.length,
	          othLength = other.length,
	          result = true;

	      if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
	        return false;
	      }
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (result && ++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];

	        result = undefined;
	        if (customizer) {
	          result = isWhere
	            ? customizer(othValue, arrValue, index)
	            : customizer(arrValue, othValue, index);
	        }
	        if (typeof result == 'undefined') {
	          // Recursively compare arrays (susceptible to call stack limits).
	          if (isWhere) {
	            var othIndex = othLength;
	            while (othIndex--) {
	              othValue = other[othIndex];
	              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
	              if (result) {
	                break;
	              }
	            }
	          } else {
	            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
	          }
	        }
	      }
	      return !!result;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} value The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag) {
	      switch (tag) {
	        case boolTag:
	        case dateTag:
	          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	          return +object == +other;

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case numberTag:
	          // Treat `NaN` vs. `NaN` as equal.
	          return (object != +object)
	            ? other != +other
	            // But, treat `-0` vs. `+0` as not equal.
	            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings primitives and string
	          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	          return object == (other + '');
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isWhere] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
	      var objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isWhere) {
	        return false;
	      }
	      var hasCtor,
	          index = -1;

	      while (++index < objLength) {
	        var key = objProps[index],
	            result = hasOwnProperty.call(other, key);

	        if (result) {
	          var objValue = object[key],
	              othValue = other[key];

	          result = undefined;
	          if (customizer) {
	            result = isWhere
	              ? customizer(othValue, objValue, key)
	              : customizer(objValue, othValue, key);
	          }
	          if (typeof result == 'undefined') {
	            // Recursively compare objects (susceptible to call stack limits).
	            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
	          }
	        }
	        if (!result) {
	          return false;
	        }
	        hasCtor || (hasCtor = key == 'constructor');
	      }
	      if (!hasCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Gets the extremum value of `collection` invoking `iteratee` for each value
	     * in `collection` to generate the criterion by which the value is ranked.
	     * The `iteratee` is invoked with three arguments; (value, index, collection).
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [isMin] Specify returning the minimum, instead of the
	     *  maximum, extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function extremumBy(collection, iteratee, isMin) {
	      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
	          computed = exValue,
	          result = computed;

	      baseEach(collection, function(value, index, collection) {
	        var current = iteratee(value, index, collection);
	        if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {
	          computed = current;
	          result = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * Gets the appropriate "callback" function. If the `_.callback` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseCallback` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getCallback(func, thisArg, argCount) {
	      var result = lodash.callback || callback;
	      result = result === callback ? baseCallback : result;
	      return argCount ? result(func, thisArg, argCount) : result;
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseIndexOf` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function|number} Returns the chosen function or its result.
	     */
	    function getIndexOf(collection, target, fromIndex) {
	      var result = lodash.indexOf || indexOf;
	      result = result === indexOf ? baseIndexOf : result;
	      return collection ? result(collection, target, fromIndex) : result;
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} [transforms] The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms ? transforms.length : 0;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add array properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      var Ctor = object.constructor;
	      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	        Ctor = Object;
	      }
	      return new Ctor;
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return bufferClone(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          var buffer = object.buffer;
	          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          var result = new Ctor(object.source, reFlags.exec(object));
	          result.lastIndex = object.lastIndex;
	      }
	      return result;
	    }

	    /**
	     * Checks if `func` is eligible for `this` binding.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
	     */
	    function isBindable(func) {
	      var support = lodash.support,
	          result = !(support.funcNames ? func.name : support.funcDecomp);

	      if (!result) {
	        var source = fnToString.call(func);
	        if (!support.funcNames) {
	          result = !reFuncName.test(source);
	        }
	        if (!result) {
	          // Check if `func` references the `this` keyword and store the result.
	          result = reThis.test(source) || isNative(func);
	          baseSetData(func, result);
	        }
	      }
	      return result;
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      value = +value;
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return value > -1 && value % 1 == 0 && value < length;
	    }

	    /**
	     * Checks if the provided arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number') {
	        var length = object.length,
	            prereq = isLength(length) && isIndex(index, length);
	      } else {
	        prereq = type == 'string' && index in object;
	      }
	      return prereq && object[index] === value;
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is based on ES `ToLength`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
	     * for more details.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     */
	    function isLength(value) {
	      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers required to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
	     * augment function arguments, making the order in which they are executed important,
	     * preventing the merging of metadata. However, we make an exception for a safe
	     * common case where curried functions have `_.ary` and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask;

	      var arityFlags = ARY_FLAG | REARG_FLAG,
	          bindFlags = BIND_FLAG | BIND_KEY_FLAG,
	          comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

	      var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
	          isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
	          argPos = (isRearg ? data : source)[7],
	          ary = (isAry ? data : source)[8];

	      var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
	        !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

	      var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
	        (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = arrayCopy(value);
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * A specialized version of `_.pick` that picks `object` properties specified
	     * by the `props` array.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property names to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByArray(object, props) {
	      object = toObject(object);

	      var index = -1,
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index];
	        if (key in object) {
	          result[key] = object[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.pick` that picks `object` properties `predicate`
	     * returns truthy for.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByCallback(object, predicate) {
	      var result = {};
	      baseForIn(object, function(value, key, object) {
	        if (predicate(value, key, object)) {
	          result[key] = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = arrayCopy(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity function
	     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = (function() {
	      var count = 0,
	          lastCalled = 0;

	      return function(key, value) {
	        var stamp = now(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return key;
	          }
	        } else {
	          count = 0;
	        }
	        return baseSetData(key, value);
	      };
	    }());

	    /**
	     * A fallback implementation of `_.isPlainObject` which checks if `value`
	     * is an object created by the `Object` constructor or has a `[[Prototype]]`
	     * of `null`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     */
	    function shimIsPlainObject(value) {
	      var Ctor,
	          support = lodash.support;

	      // Exit early for non `Object` objects.
	      if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
	          (!hasOwnProperty.call(value, 'constructor') &&
	            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      var result;
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      baseForIn(value, function(subValue, key) {
	        result = key;
	      });
	      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
	    }

	    /**
	     * A fallback implementation of `Object.keys` which creates an array of the
	     * own enumerable property names of `object`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the array of property names.
	     */
	    function shimKeys(object) {
	      var props = keysIn(object),
	          propsLength = props.length,
	          length = propsLength && object.length,
	          support = lodash.support;

	      var allowIndexes = length && isLength(length) &&
	        (isArray(object) || (support.nonEnumArgs && isArguments(object)));

	      var index = -1,
	          result = [];

	      while (++index < propsLength) {
	        var key = props[index];
	        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to an array-like object if it is not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array|Object} Returns the array-like object.
	     */
	    function toIterable(value) {
	      if (value == null) {
	        return [];
	      }
	      if (!isLength(value.length)) {
	        return values(value);
	      }
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to an object if it is not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Object} Returns the object.
	     */
	    function toObject(value) {
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      return wrapper instanceof LazyWrapper
	        ? wrapper.clone()
	        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `collection` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new array containing chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if (guard ? isIterateeCall(array, size, guard) : size == null) {
	        size = 1;
	      } else {
	        size = nativeMax(+size || 1, 1);
	      }
	      var index = 0,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = Array(ceil(length / size));

	      while (index < length) {
	        result[++resIndex] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array excluding all values of the provided arrays using
	     * `SameValueZero` for equality comparisons.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3], [5, 2, 10]);
	     * // => [1, 3]
	     */
	    function difference() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var value = arguments[index];
	        if (isArray(value) || isArguments(value)) {
	          break;
	        }
	      }
	      return baseDifference(value, baseFlatten(arguments, false, true, ++index));
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per element.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRightWhile([1, 2, 3], function(n) { return n > 1; });
	     * // => [1]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'status': 'busy', 'active': false },
	     *   { 'user': 'fred',    'status': 'busy', 'active': true },
	     *   { 'user': 'pebbles', 'status': 'away', 'active': true }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
	     * // => ['barney']
	     *
	     * // using the "_.matches" callback shorthand
	     * _.pluck(_.dropRightWhile(users, { 'status': 'away' }), 'user');
	     * // => ['barney', 'fred']
	     */
	    function dropRightWhile(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      predicate = getCallback(predicate, thisArg, 3);
	      while (length-- && predicate(array[length], length, array)) {}
	      return baseSlice(array, 0, length + 1);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per element.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropWhile([1, 2, 3], function(n) { return n < 3; });
	     * // => [3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'status': 'busy', 'active': true },
	     *   { 'user': 'fred',    'status': 'busy', 'active': false },
	     *   { 'user': 'pebbles', 'status': 'away', 'active': true }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.pluck(_.dropWhile(users, 'active'), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the "_.matches" callback shorthand
	     * _.pluck(_.dropWhile(users, { 'status': 'busy' }), 'user');
	     * // => ['pebbles']
	     */
	    function dropWhile(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var index = -1;
	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length && predicate(array[index], index, array)) {}
	      return baseSlice(array, index);
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function fill(array, value, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for, instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.findIndex(users, function(chr) { return chr.age < 40; });
	     * // => 0
	     *
	     * // using the "_.matches" callback shorthand
	     * _.findIndex(users, { 'age': 1 });
	     * // => 2
	     *
	     * // using the "_.property" callback shorthand
	     * _.findIndex(users, 'active');
	     * // => 1
	     */
	    function findIndex(array, predicate, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0;

	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(chr) { return chr.age < 40; });
	     * // => 2
	     *
	     * // using the "_.matches" callback shorthand
	     * _.findLastIndex(users, { 'age': 40 });
	     * // => 1
	     *
	     * // using the "_.property" callback shorthand
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      predicate = getCallback(predicate, thisArg, 3);
	      while (length--) {
	        if (predicate(array[length], length, array)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([]);
	     * // => undefined
	     */
	    function first(array) {
	      return array ? array[0] : undefined;
	    }

	    /**
	     * Flattens a nested array. If `isDeep` is `true` the array is recursively
	     * flattened, otherwise it is only flattened a single level.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2], [3, [[4]]]]);
	     * // => [1, 2, 3, [[4]]];
	     *
	     * // using `isDeep`
	     * _.flatten([1, [2], [3, [[4]]]], true);
	     * // => [1, 2, 3, 4];
	     */
	    function flatten(array, isDeep, guard) {
	      var length = array ? array.length : 0;
	      if (guard && isIterateeCall(array, isDeep, guard)) {
	        isDeep = false;
	      }
	      return length ? baseFlatten(array, isDeep) : [];
	    }

	    /**
	     * Recursively flattens a nested array.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to recursively flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2], [3, [[4]]]]);
	     * // => [1, 2, 3, 4];
	     */
	    function flattenDeep(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, true) : [];
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
	     * it is used as the offset from the end of `array`. If `array` is sorted
	     * providing `true` for `fromIndex` performs a faster binary search.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 1
	     *
	     * // using `fromIndex`
	     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 4
	     *
	     * // performing a binary search
	     * _.indexOf([4, 4, 5, 5, 6, 6], 5, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      } else if (fromIndex) {
	        var index = binaryIndex(array, value),
	            other = array[index];

	        return (value === value ? value === other : other !== other) ? index : -1;
	      }
	      return baseIndexOf(array, value, fromIndex);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      return dropRight(array, 1);
	    }

	    /**
	     * Creates an array of unique values in all provided arrays using `SameValueZero`
	     * for equality comparisons.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     *
	     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2]
	     */
	    function intersection() {
	      var args = [],
	          argsIndex = -1,
	          argsLength = arguments.length,
	          caches = [],
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf;

	      while (++argsIndex < argsLength) {
	        var value = arguments[argsIndex];
	        if (isArray(value) || isArguments(value)) {
	          args.push(value);
	          caches.push(isCommon && value.length >= 120 && createCache(argsIndex && value));
	        }
	      }
	      argsLength = args.length;
	      var array = args[0],
	          index = -1,
	          length = array ? array.length : 0,
	          result = [],
	          seen = caches[0];

	      outer:
	      while (++index < length) {
	        value = array[index];
	        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {
	          argsIndex = argsLength;
	          while (--argsIndex) {
	            var cache = caches[argsIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(value);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array ? array.length : 0;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
	     *  or `true` to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
	     * // => 4
	     *
	     * // using `fromIndex`
	     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
	     * // => 1
	     *
	     * // performing a binary search
	     * _.lastIndexOf([4, 4, 5, 5, 6, 6], 5, true);
	     * // => 3
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
	      } else if (fromIndex) {
	        index = binaryIndex(array, value, true) - 1;
	        var other = array[index];
	        return (value === value ? value === other : other !== other) ? index : -1;
	      }
	      if (value !== value) {
	        return indexOfNaN(array, index, true);
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Removes all provided values from `array` using `SameValueZero` for equality
	     * comparisons.
	     *
	     * **Notes:**
	     *  - Unlike `_.without`, this method mutates `array`.
	     *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,
	     *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     *    for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull() {
	      var array = arguments[0];
	      if (!(array && array.length)) {
	        return array;
	      }
	      var index = 0,
	          indexOf = getIndexOf(),
	          length = arguments.length;

	      while (++index < length) {
	        var fromIndex = 0,
	            value = arguments[index];

	        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * Removes elements from `array` corresponding to the given indexes and returns
	     * an array of the removed elements. Indexes may be specified as an array of
	     * indexes or as individual arguments.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [5, 10, 15, 20];
	     * var evens = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => [5, 15]
	     *
	     * console.log(evens);
	     * // => [10, 20]
	     */
	    function pullAt(array) {
	      return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
	    }

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is bound to
	     * `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) { return n % 2 == 0; });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate, thisArg) {
	      var index = -1,
	          length = array ? array.length : 0,
	          result = [];

	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          splice.call(array, index--, 1);
	          length--;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias tail
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function rest(array) {
	      return drop(array, 1);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This function is used instead of `Array#slice` to support node
	     * lists in IE < 9 and to ensure dense arrays are returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value` should
	     * be inserted into `array` in order to maintain its sort order. If an iteratee
	     * function is provided it is invoked for `value` and each element of `array`
	     * to compute their sort ranking. The iteratee is bound to `thisArg` and
	     * invoked with one argument; (value).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     *
	     * _.sortedIndex([4, 4, 5, 5, 6, 6], 5);
	     * // => 2
	     *
	     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
	     *
	     * // using an iteratee function
	     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
	     *   return this.data[word];
	     * }, dict);
	     * // => 1
	     *
	     * // using the "_.property" callback shorthand
	     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 1
	     */
	    function sortedIndex(array, value, iteratee, thisArg) {
	      var func = getCallback(iteratee);
	      return (func === baseCallback && iteratee == null)
	        ? binaryIndex(array, value)
	        : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 4, 5, 5, 6, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value, iteratee, thisArg) {
	      var func = getCallback(iteratee);
	      return (func === baseCallback && iteratee == null)
	        ? binaryIndex(array, value, true)
	        : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
	     * and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per element.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRightWhile([1, 2, 3], function(n) { return n > 1; });
	     * // => [2, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'status': 'busy', 'active': false },
	     *   { 'user': 'fred',    'status': 'busy', 'active': true },
	     *   { 'user': 'pebbles', 'status': 'away', 'active': true }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the "_.matches" callback shorthand
	     * _.pluck(_.takeRightWhile(users, { 'status': 'away' }), 'user');
	     * // => ['pebbles']
	     */
	    function takeRightWhile(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      predicate = getCallback(predicate, thisArg, 3);
	      while (length-- && predicate(array[length], length, array)) {}
	      return baseSlice(array, length + 1);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is bound to
	     * `thisArg` and invoked with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per element.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeWhile([1, 2, 3], function(n) { return n < 3; });
	     * // => [1, 2]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'status': 'busy', 'active': true },
	     *   { 'user': 'fred',    'status': 'busy', 'active': false },
	     *   { 'user': 'pebbles', 'status': 'away', 'active': true }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.pluck(_.takeWhile(users, 'active'), 'user');
	     * // => ['barney']
	     *
	     * // using the "_.matches" callback shorthand
	     * _.pluck(_.takeWhile(users, { 'status': 'busy' }), 'user');
	     * // => ['barney', 'fred']
	     */
	    function takeWhile(array, predicate, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var index = -1;
	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length && predicate(array[index], index, array)) {}
	      return baseSlice(array, 0, index);
	    }

	    /**
	     * Creates an array of unique values, in order, of the provided arrays using
	     * `SameValueZero` for equality comparisons.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
	     * // => [1, 2, 3, 5, 4]
	     */
	    function union() {
	      return baseUniq(baseFlatten(arguments, false, true));
	    }

	    /**
	     * Creates a duplicate-value-free version of an array using `SameValueZero`
	     * for equality comparisons. Providing `true` for `isSorted` performs a faster
	     * search algorithm for sorted arrays. If an iteratee function is provided it
	     * is invoked for each value in the array to generate the criterion by which
	     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments; (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {boolean} [isSorted] Specify the array is sorted.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     *  If a property name or object is provided it is used to create a "_.property"
	     *  or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([1, 2, 1]);
	     * // => [1, 2]
	     *
	     * // using `isSorted`
	     * _.uniq([1, 1, 2], true);
	     * // => [1, 2]
	     *
	     * // using an iteratee function
	     * _.uniq([1, 2.5, 1.5, 2], function(n) { return this.floor(n); }, Math);
	     * // => [1, 2.5]
	     *
	     * // using the "_.property" callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      // Juggle arguments.
	      if (typeof isSorted != 'boolean' && isSorted != null) {
	        thisArg = iteratee;
	        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
	        isSorted = false;
	      }
	      var func = getCallback();
	      if (!(func === baseCallback && iteratee == null)) {
	        iteratee = func(iteratee, thisArg, 3);
	      }
	      return (isSorted && getIndexOf() == baseIndexOf)
	        ? sortedUniq(array, iteratee)
	        : baseUniq(array, iteratee);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-`_.zip`
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */
	    function unzip(array) {
	      var index = -1,
	          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = arrayMap(array, baseProperty(index));
	      }
	      return result;
	    }

	    /**
	     * Creates an array excluding all provided values using `SameValueZero` for
	     * equality comparisons.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to filter.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
	     * // => [2, 3, 4]
	     */
	    function without(array) {
	      return baseDifference(array, baseSlice(arguments, 1));
	    }

	    /**
	     * Creates an array that is the symmetric difference of the provided arrays.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Symmetric_difference) for
	     * more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xor([1, 2, 3], [5, 2, 1, 4]);
	     * // => [3, 5, 4]
	     *
	     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
	     * // => [1, 4, 5]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var array = arguments[index];
	        if (isArray(array) || isArguments(array)) {
	          var result = result
	            ? baseDifference(result, array).concat(baseDifference(array, result))
	            : array;
	        }
	      }
	      return result ? baseUniq(result) : [];
	    }

	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second elements
	     * of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    function zip() {
	      var length = arguments.length,
	          array = Array(length);

	      while (length--) {
	        array[length] = arguments[length];
	      }
	      return unzip(array);
	    }

	    /**
	     * Creates an object composed from arrays of property names and values. Provide
	     * either a single two dimensional array, e.g. `[[key1, value1], [key2, value2]]`
	     * or two arrays, one of property names and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Array
	     * @param {Array} props The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(props, values) {
	      var index = -1,
	          length = props ? props.length : 0,
	          result = {};

	      if (length && !values && !isArray(props[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = props[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object that wraps `value` with explicit method
	     * chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(users)
	     *   .sortBy('age')
	     *   .map(function(chr) { return chr.user + ' is ' + chr.age; })
	     *   .first()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor is
	     * bound to `thisArg` and invoked with one argument; (value). The purpose of
	     * this method is to "tap into" a method chain in order to perform operations
	     * on intermediate results within the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) { array.pop(); })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor, thisArg) {
	      interceptor.call(thisArg, value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .last()
	     *  .thru(function(value) { return [value]; })
	     *  .value();
	     * // => [3]
	     */
	    function thru(value, interceptor, thisArg) {
	      return interceptor.call(thisArg, value);
	    }

	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(users).first();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(users).chain()
	     *   .first()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chained sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapper = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapper = wrapper.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapper.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value());
	    }

	    /**
	     * Creates a clone of the chained sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapper = _(array).map(_.partial(Math.pow, _, 2));
	     *
	     * var other = [3, 4];
	     * var otherWrapper = wrapper.plant(other);
	     *
	     * otherWrapper.value();
	     * // => [9, 16]
	     *
	     * wrapper.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof LodashWrapper) {
	        var clone = wrapperClone(parent);
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * Reverses the wrapped array so the first element becomes the last, the
	     * second element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        if (this.__actions__.length) {
	          value = new LazyWrapper(this);
	        }
	        return new LodashWrapper(value.reverse());
	      }
	      return this.thru(function(value) {
	        return value.reverse();
	      });
	    }

	    /**
	     * Produces the result of coercing the unwrapped value to a string.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chain
	     * @returns {string} Returns the coerced string value.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return (this.value() + '');
	    }

	    /**
	     * Executes the chained sequence to extract the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @alias run, toJSON, valueOf
	     * @category Chain
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements corresponding to the given keys, or indexes,
	     * of `collection`. Keys may be specified as individual arguments or as arrays
	     * of keys.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [props] The property names
	     *  or indexes of elements to pick, specified individually or in arrays.
	     * @returns {Array} Returns the new array of picked elements.
	     * @example
	     *
	     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
	     * // => ['a', 'c', 'e']
	     *
	     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
	     * // => ['fred', 'pebbles']
	     */
	    function at(collection) {
	      var length = collection ? collection.length : 0;
	      if (isLength(length)) {
	        collection = toIterable(collection);
	      }
	      return baseAt(collection, baseFlatten(arguments, false, false, 1));
	    }

	    /**
	     * Checks if `value` is in `collection` using `SameValueZero` for equality
	     * comparisons. If `fromIndex` is negative, it is used as the offset from
	     * the end of `collection`.
	     *
	     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
	     * e.g. `===`, except that `NaN` matches `NaN`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @alias contains, include
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} target The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */
	    function includes(collection, target, fromIndex) {
	      var length = collection ? collection.length : 0;
	      if (!isLength(length)) {
	        collection = values(collection);
	        length = collection.length;
	      }
	      if (!length) {
	        return false;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      } else {
	        fromIndex = 0;
	      }
	      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
	        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
	        : (getIndexOf(collection, target, fromIndex) > -1);
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the number of times the key was returned by `iteratee`.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) { return Math.floor(n); });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) { return this.floor(n); }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * The predicate is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes']);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.every(users, 'age');
	     * // => true
	     *
	     * // using the "_.matches" callback shorthand
	     * _.every(users, { 'age': 36 });
	     * // => false
	     */
	    function every(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var evens = _.filter([1, 2, 3, 4], function(n) { return n % 2 == 0; });
	     * // => [2, 4]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.pluck(_.filter(users, 'active'), 'user');
	     * // => ['fred']
	     *
	     * // using the "_.matches" callback shorthand
	     * _.pluck(_.filter(users, { 'age': 36 }), 'user');
	     * // => ['barney']
	     */
	    function filter(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.result(_.find(users, function(chr) { return chr.age < 40; }), 'user');
	     * // => 'barney'
	     *
	     * // using the "_.matches" callback shorthand
	     * _.result(_.find(users, { 'age': 1 }), 'user');
	     * // => 'pebbles'
	     *
	     * // using the "_.property" callback shorthand
	     * _.result(_.find(users, 'active'), 'user');
	     * // => 'fred'
	     */
	    function find(collection, predicate, thisArg) {
	      if (isArray(collection)) {
	        var index = findIndex(collection, predicate, thisArg);
	        return index > -1 ? collection[index] : undefined;
	      }
	      predicate = getCallback(predicate, thisArg, 3);
	      return baseFind(collection, predicate, baseEach);
	    }

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) { return n % 2 == 1; });
	     * // => 3
	     */
	    function findLast(collection, predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 3);
	      return baseFind(collection, predicate, baseEachRight);
	    }

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning the first element that has equivalent property
	     * values.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'status': 'busy' },
	     *   { 'user': 'fred',   'age': 40, 'status': 'busy' }
	     * ];
	     *
	     * _.result(_.findWhere(users, { 'status': 'busy' }), 'user');
	     * // => 'barney'
	     *
	     * _.result(_.findWhere(users, { 'age': 40 }), 'user');
	     * // => 'fred'
	     */
	    function findWhere(collection, source) {
	      return find(collection, baseMatches(source));
	    }

	    /**
	     * Iterates over elements of `collection` invoking `iteratee` for each element.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection). Iterator functions may exit iteration early
	     * by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a `length` property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEach(function(n) { console.log(n); }).value();
	     * // => logs each value from left to right and returns the array
	     *
	     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(n, key) { console.log(n, key); });
	     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	     */
	    function forEach(collection, iteratee, thisArg) {
	      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
	        ? arrayEach(collection, iteratee)
	        : baseEach(collection, bindCallback(iteratee, thisArg, 3));
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2, 3]).forEachRight(function(n) { console.log(n); }).join(',');
	     * // => logs each value from right to left and returns the array
	     */
	    function forEachRight(collection, iteratee, thisArg) {
	      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
	        ? arrayEachRight(collection, iteratee)
	        : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) { return Math.floor(n); });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) { return this.floor(n); }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using the "_.property" callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        result[key] = [value];
	      }
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the last element responsible for generating the key. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keyData = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keyData, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) { return String.fromCharCode(object.code); });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) { return this.fromCharCode(object.code); }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });

	    /**
	     * Invokes the method named by `methodName` on each element in `collection`,
	     * returning an array of the results of each invoked method. Any additional
	     * arguments are provided to each invoked method. If `methodName` is a function
	     * it is invoked for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|string} methodName The name of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    function invoke(collection, methodName) {
	      return baseInvoke(collection, methodName, baseSlice(arguments, 2));
	    }

	    /**
	     * Creates an array of values by running each element in `collection` through
	     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * _.map([1, 2, 3], function(n) { return n * 3; });
	     * // => [3, 6, 9]
	     *
	     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(n) { return n * 3; });
	     * // => [3, 6, 9] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee, thisArg) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return func(collection, iteratee);
	    }

	    /**
	     * Gets the maximum value of `collection`. If `collection` is empty or falsey
	     * `-Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     *  If a property name or object is provided it is used to create a "_.property"
	     *  or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => -Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(users, function(chr) { return chr.age; });
	     * // => { 'user': 'fred', 'age': 40 };
	     *
	     * // using the "_.property" callback shorthand
	     * _.max(users, 'age');
	     * // => { 'user': 'fred', 'age': 40 };
	     */
	    var max = createExtremum(arrayMax);

	    /**
	     * Gets the minimum value of `collection`. If `collection` is empty or falsey
	     * `Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments; (value, index, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     *  If a property name or object is provided it is used to create a "_.property"
	     *  or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(users, function(chr) { return chr.age; });
	     * // => { 'user': 'barney', 'age': 36 };
	     *
	     * // using the "_.property" callback shorthand
	     * _.min(users, 'age');
	     * // => { 'user': 'barney', 'age': 36 };
	     */
	    var min = createExtremum(arrayMin, true);

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, while the second of which
	     * contains elements `predicate` returns falsey for. The predicate is bound
	     * to `thisArg` and invoked with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * _.partition([1, 2, 3], function(n) { return n % 2; });
	     * // => [[1, 3], [2]]
	     *
	     * _.partition([1.2, 2.3, 3.4], function(n) { return this.floor(n) % 2; }, Math);
	     * // => [[1, 3], [2]]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * // using the "_.matches" callback shorthand
	     * _.map(_.partition(users, { 'age': 1 }), function(array) { return _.pluck(array, 'user'); });
	     * // => [['pebbles'], ['barney', 'fred']]
	     *
	     * // using the "_.property" callback shorthand
	     * _.map(_.partition(users, 'active'), function(array) { return _.pluck(array, 'user'); });
	     * // => [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Gets the value of `key` from all elements in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {string} key The key of the property to pluck.
	     * @returns {Array} Returns the property values.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(users, 'user');
	     * // => ['barney', 'fred']
	     *
	     * var userIndex = _.indexBy(users, 'user');
	     * _.pluck(userIndex, 'age');
	     * // => [36, 40] (iteration order is not guaranteed)
	     */
	    function pluck(collection, key) {
	      return map(collection, baseProperty(key + ''));
	    }

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` through `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not provided the first element of `collection` is used as the initial
	     * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;
	     * (accumulator, value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var sum = _.reduce([1, 2, 3], function(sum, n) { return sum + n; });
	     * // => 6
	     *
	     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6, 'c': 9 } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator, thisArg) {
	      var func = isArray(collection) ? arrayReduce : baseReduce;
	      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     * _.reduceRight(array, function(flattened, other) { return flattened.concat(other); }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator, thisArg) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce;
	      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
	    }

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var odds = _.reject([1, 2, 3, 4], function(n) { return n % 2 == 0; });
	     * // => [1, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.pluck(_.reject(users, 'active'), 'user');
	     * // => ['barney']
	     *
	     * // using the "_.matches" callback shorthand
	     * _.pluck(_.reject(users, { 'age': 36 }), 'user');
	     * // => ['fred']
	     */
	    function reject(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, function(value, index, collection) {
	        return !predicate(value, index, collection);
	      });
	    }

	    /**
	     * Gets a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {*} Returns the random sample(s).
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
	        collection = toIterable(collection);
	        var length = collection.length;
	        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
	      }
	      var result = shuffle(collection);
	      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
	      return result;
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the Fisher-Yates
	     * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      collection = toIterable(collection);

	      var index = -1,
	          length = collection.length,
	          result = Array(length);

	      while (++index < length) {
	        var rand = baseRandom(0, index);
	        if (index != rand) {
	          result[index] = result[rand];
	        }
	        result[rand] = collection[index];
	      }
	      return result;
	    }

	    /**
	     * Gets the size of `collection` by returning `collection.length` for
	     * array-like values or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the size of `collection`.
	     * @example
	     *
	     * _.size([1, 2]);
	     * // => 2
	     *
	     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
	     * // => 3
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? collection.length : 0;
	      return isLength(length) ? length : keys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * The function returns as soon as it finds a passing value and does not iterate
	     * over the entire collection. The predicate is bound to `thisArg` and invoked
	     * with three arguments; (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.some(users, 'active');
	     * // => true
	     *
	     * // using the "_.matches" callback shorthand
	     * _.some(users, { 'age': 1 });
	     * // => false
	     */
	    function some(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through `iteratee`. This method performs
	     * a stable sort, that is, it preserves the original sort order of equal elements.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|Object|string} [iteratee=_.identity] The function
	     *  invoked per iteration. If a property name or an object is provided it is
	     *  used to create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(n) { return Math.sin(n); });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(n) { return this.sin(n); }, Math);
	     * // => [3, 1, 2]
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'pebbles' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * // using the "_.property" callback shorthand
	     * _.pluck(_.sortBy(users, 'user'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function sortBy(collection, iteratee, thisArg) {
	      var index = -1,
	          length = collection ? collection.length : 0,
	          result = isLength(length) ? Array(length) : [];

	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = null;
	      }
	      iteratee = getCallback(iteratee, thisArg, 3);
	      baseEach(collection, function(value, key, collection) {
	        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
	      });
	      return baseSortBy(result, compareAscending);
	    }

	    /**
	     * This method is like `_.sortBy` except that it sorts by property names
	     * instead of an iteratee function.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(string|string[])} props The property names to sort by,
	     *  specified as individual property names or arrays of property names.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 26 },
	     *   { 'user': 'fred',   'age': 30 }
	     * ];
	     *
	     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
	     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
	     */
	    function sortByAll(collection) {
	      var args = arguments;
	      if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {
	        args = [collection, args[1]];
	      }
	      var index = -1,
	          length = collection ? collection.length : 0,
	          props = baseFlatten(args, false, false, 1),
	          result = isLength(length) ? Array(length) : [];

	      baseEach(collection, function(value, key, collection) {
	        var length = props.length,
	            criteria = Array(length);

	        while (length--) {
	          criteria[length] = value == null ? undefined : value[props[length]];
	        }
	        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };
	      });
	      return baseSortBy(result, compareMultipleAscending);
	    }

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'status': 'busy', 'pets': ['hoppy'] },
	     *   { 'user': 'fred',   'age': 40, 'status': 'busy', 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.pluck(_.where(users, { 'age': 36 }), 'user');
	     * // => ['barney']
	     *
	     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
	     * // => ['fred']
	     *
	     * _.pluck(_.where(users, { 'status': 'busy' }), 'user');
	     * // => ['barney', 'fred']
	     */
	    function where(collection, source) {
	      return filter(collection, baseMatches(source));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Date
	     * @example
	     *
	     * _.defer(function(stamp) { console.log(_.now() - stamp); }, _.now());
	     * // => logs the number of milliseconds it took for the deferred function to be invoked
	     */
	    var now = nativeNow || function() {
	      return new Date().getTime();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it is called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'done saving!' after the two async saves have completed
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      n = nativeIsFinite(n = +n) ? n : 0;
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that accepts up to `n` arguments ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      if (guard && isIterateeCall(func, n, guard)) {
	        n = null;
	      }
	      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
	      return createWrapper(func, ARY_FLAG, null, null, null, null, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it is called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery('#add').on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        } else {
	          func = null;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and prepends any additional `_.bind` arguments to those provided to the
	     * bound function.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind` this method does not set the `length`
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [args] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // using placeholders
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    function bind(func, thisArg) {
	      var bitmask = BIND_FLAG;
	      if (arguments.length > 2) {
	        var partials = baseSlice(arguments, 2),
	            holders = replaceHolders(partials, bind.placeholder);

	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(func, bitmask, thisArg, partials, holders);
	    }

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all enumerable function
	     * properties, own and inherited, of `object` are bound.
	     *
	     * **Note:** This method does not set the `length` property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} [methodNames] The object method names to bind,
	     *  specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() { console.log('clicked ' + this.label); }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs' when the element is clicked
	     */
	    function bindAll(object) {
	      return baseBindAll(object,
	        arguments.length > 1
	          ? baseFlatten(arguments, false, false, 1)
	          : functions(object)
	      );
	    }

	    /**
	     * Creates a function that invokes the method at `object[key]` and prepends
	     * any additional `_.bindKey` arguments to those provided to the bound function.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist.
	     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [args] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // using placeholders
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    function bindKey(object, key) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (arguments.length > 2) {
	        var partials = baseSlice(arguments, 2),
	            holders = replaceHolders(partials, bindKey.placeholder);

	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(key, bitmask, object, partials, holders);
	    }

	    /**
	     * Creates a function that accepts one or more arguments of `func` that when
	     * called either invokes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` may be specified
	     * if `func.length` is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the `length` property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      if (guard && isIterateeCall(func, arity, guard)) {
	        arity = null;
	      }
	      var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the `length` property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      if (guard && isIterateeCall(func, arity, guard)) {
	        arity = null;
	      }
	      var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }

	    /**
	     * Creates a function that delays invoking `func` until after `wait` milliseconds
	     * have elapsed since the last time it was invoked. The created function comes
	     * with a `cancel` method to cancel delayed invocations. Provide an options
	     * object to indicate that `func` should be invoked on the leading and/or
	     * trailing edge of the `wait` timeout. Subsequent calls to the debounced
	     * function return the result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} wait The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	     *  delayed before it is invoked.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // ensure `batchLog` is invoked once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }));
	     *
	     * // cancel a debounced call
	     * var todoChanges = _.debounce(batchLog, 1000);
	     * Object.observe(models.todo, todoChanges);
	     *
	     * Object.observe(models, function(changes) {
	     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
	     *     todoChanges.cancel();
	     *   }
	     * }, ['delete']);
	     *
	     * // ...at some point `models.todo` is changed
	     * models.todo.completed = true;
	     *
	     * // ...before 1 second has passed `models.todo` is deleted
	     * // which cancels the debounced `todoChanges` call
	     * delete models.todo;
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = wait < 0 ? 0 : wait;
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = options.leading;
	        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
	        trailing = 'trailing' in options ? options.trailing : trailing;
	      }

	      function cancel() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        if (maxTimeoutId) {
	          clearTimeout(maxTimeoutId);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	      }

	      function delayed() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0 || remaining > wait) {
	          if (maxTimeoutId) {
	            clearTimeout(maxTimeoutId);
	          }
	          var isCalled = trailingCall;
	          maxTimeoutId = timeoutId = trailingCall = undefined;
	          if (isCalled) {
	            lastCalled = now();
	            result = func.apply(thisArg, args);
	            if (!timeoutId && !maxTimeoutId) {
	              args = thisArg = null;
	            }
	          }
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      }

	      function maxDelayed() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (trailing || (maxWait !== wait)) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = null;
	          }
	        }
	      }

	      function debounced() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);

	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0 || remaining > maxWait;

	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = null;
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) { console.log(text); }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    function defer(func) {
	      return baseDelay(func, 1, arguments, 1);
	    }

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) { console.log(text); }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    function delay(func, wait) {
	      return baseDelay(func, wait, arguments, 2);
	    }

	    /**
	     * Creates a function that returns the result of invoking the provided
	     * functions with the `this` binding of the created function, where each
	     * successive invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function add(x, y) {
	     *   return x + y;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow(add, square);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    function flow() {
	      var funcs = arguments,
	          length = funcs.length;

	      if (!length) {
	        return function() { return arguments[0]; };
	      }
	      if (!arrayEvery(funcs, isFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var index = 0,
	            result = funcs[index].apply(this, arguments);

	        while (++index < length) {
	          result = funcs[index].call(this, result);
	        }
	        return result;
	      };
	    }

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the provided functions from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias backflow, compose
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function add(x, y) {
	     *   return x + y;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight(square, add);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    function flowRight() {
	      var funcs = arguments,
	          fromIndex = funcs.length - 1;

	      if (fromIndex < 0) {
	        return function() { return arguments[0]; };
	      }
	      if (!arrayEvery(funcs, isFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var index = fromIndex,
	            result = funcs[index].apply(this, arguments);

	        while (index--) {
	          result = funcs[index].call(this, result);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is coerced to a string and used as the
	     * cache key. The `func` is invoked with the `this` binding of the memoized
	     * function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the ES `Map` method interface
	     * of `get`, `has`, and `set`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var upperCase = _.memoize(function(string) {
	     *   return string.toUpperCase();
	     * });
	     *
	     * upperCase('fred');
	     * // => 'FRED'
	     *
	     * // modifying the result cache
	     * upperCase.cache.set('fred', 'BARNEY');
	     * upperCase('fred');
	     * // => 'BARNEY'
	     *
	     * // replacing `_.memoize.Cache`
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'barney' };
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'fred' }
	     *
	     * _.memoize.Cache = WeakMap;
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'barney' }
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var cache = memoized.cache,
	            key = resolver ? resolver.apply(this, arguments) : arguments[0];

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, arguments);
	        cache.set(key, result);
	        return result;
	      };
	      memoized.cache = new memoize.Cache;
	      return memoized;
	    }

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        return !predicate.apply(this, arguments);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first call. The `func` is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */
	    function once(func) {
	      return before(func, 2);
	    }

	    /**
	     * Creates a function that invokes `func` with `partial` arguments prepended
	     * to those provided to the new function. This method is like `_.bind` except
	     * it does **not** alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the `length` property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [args] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // using placeholders
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    function partial(func) {
	      var partials = baseSlice(arguments, 1),
	          holders = replaceHolders(partials, partial.placeholder);

	      return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
	    }

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to those provided to the new function.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the `length` property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [args] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // using placeholders
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    function partialRight(func) {
	      var partials = baseSlice(arguments, 1),
	          holders = replaceHolders(partials, partialRight.placeholder);

	      return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
	    }

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified indexes where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, 2, 0, 1);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     *
	     * var map = _.rearg(_.map, [1, 0]);
	     * map(function(n) { return n * 3; }, [1, 2, 3]);
	     * // => [3, 6, 9]
	     */
	    function rearg(func) {
	      var indexes = baseFlatten(arguments, false, false, 1);
	      return createWrapper(func, REARG_FLAG, null, null, null, indexes);
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and the array of arguments provided to the created function much like
	     * [Function#apply](http://es5.github.io/#x15.3.4.3).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} The function to spread arguments over.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {*} Returns the new function.
	     * @example
	     *
	     * var spread = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * spread(['Fred', 'hello']);
	     * // => 'Fred says hello'
	     *
	     * // with a Promise
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * var add = function(x, y) {
	     *   return x + y;
	     * };
	     *
	     * numbers.then(_.spread(add));
	     * // => a Promise of 76
	     */
	    function spread(func, thisArg) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function(array) {
	        return func.apply(thisArg, array);
	      };
	    }

	    /**
	     * Creates a function that only invokes `func` at most once per every `wait`
	     * milliseconds. The created function comes with a `cancel` method to cancel
	     * delayed invocations. Provide an options object to indicate that `func`
	     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
	     * Subsequent calls to the throttled function return the result of the last
	     * `func` call.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} wait The number of milliseconds to throttle invocations to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * var throttled =  _.throttle(renewToken, 300000, { 'trailing': false })
	     * jQuery('.interactive').on('click', throttled);
	     *
	     * // cancel a trailing throttled call
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      debounceOptions.leading = leading;
	      debounceOptions.maxWait = +wait;
	      debounceOptions.trailing = trailing;
	      return debounce(func, wait, debounceOptions);
	    }

	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      wrapper = wrapper == null ? identity : wrapper;
	      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
	     * otherwise they are assigned by reference. If `customizer` is provided it is
	     * invoked to produce the cloned values. If `customizer` returns `undefined`
	     * cloning is handled by the method instead. The `customizer` is bound to
	     * `thisArg` and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the structured clone algorithm.
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var shallow = _.clone(users);
	     * shallow[0] === users[0];
	     * // => true
	     *
	     * var deep = _.clone(users, true);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var body = _.clone(document.body, function(value) {
	     *   return _.isElement(value) ? value.cloneNode(false) : undefined;
	     * });
	     *
	     * body === document.body
	     * // => false
	     * body.nodeName
	     * // => BODY
	     * body.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, customizer, thisArg) {
	      // Juggle arguments.
	      if (typeof isDeep != 'boolean' && isDeep != null) {
	        thisArg = customizer;
	        customizer = isIterateeCall(value, isDeep, thisArg) ? null : isDeep;
	        isDeep = false;
	      }
	      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
	      return baseClone(value, isDeep, customizer);
	    }

	    /**
	     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
	     * to produce the cloned values. If `customizer` returns `undefined` cloning
	     * is handled by the method instead. The `customizer` is bound to `thisArg`
	     * and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the structured clone algorithm.
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var deep = _.cloneDeep(users);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.cloneDeep(document.body, function(value) {
	     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
	     * });
	     *
	     * body === document.body
	     * // => false
	     * body.nodeName
	     * // => BODY
	     * body.childNodes.length;
	     * // => 20
	     */
	    function cloneDeep(value, customizer, thisArg) {
	      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
	      return baseClone(value, true, customizer);
	    }

	    /**
	     * Checks if `value` is classified as an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * (function() { return _.isArguments(arguments); })();
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      var length = isObjectLike(value) ? value.length : undefined;
	      return (isLength(length) && objToString.call(value) == argsTag) || false;
	    }

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * (function() { return _.isArray(arguments); })();
	     * // => false
	     */
	    var isArray = nativeIsArray || function(value) {
	      return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
	    };

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
	    }

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    function isDate(value) {
	      return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
	    }

	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return (value && value.nodeType === 1 && isObjectLike(value) &&
	        objToString.call(value).indexOf('Element') > -1) || false;
	    }
	    // Fallback for environments without DOM support.
	    if (!support.dom) {
	      isElement = function(value) {
	        return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
	      };
	    }

	    /**
	     * Checks if a value is empty. A value is considered empty unless it is an
	     * `arguments` object, array, string, or jQuery-like collection with a length
	     * greater than `0` or an object with own enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      var length = value.length;
	      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
	          (isObjectLike(value) && isFunction(value.splice)))) {
	        return !length;
	      }
	      return !keys(value).length;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent. If `customizer` is provided it is invoked to compare values.
	     * If `customizer` returns `undefined` comparisons are handled by the method
	     * instead. The `customizer` is bound to `thisArg` and invoked with three
	     * arguments; (value, other [, index|key]).
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Functions and DOM nodes
	     * are **not** supported. Provide a customizer function to extend support
	     * for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * object == other;
	     * // => false
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * // using a customizer callback
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqual(array, other, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isEqual(value, other, customizer, thisArg) {
	      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
	      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
	        return value === other;
	      }
	      var result = customizer ? customizer(value, other) : undefined;
	      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on ES `Number.isFinite`. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(10);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => false
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite(Object(10));
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    var isFinite = nativeNumIsFinite || function(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    };

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	      // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	      return typeof value == 'function' || false;
	    }
	    // Fallback for environments that return incorrect `typeof` operator results.
	    if (isFunction(/x/) || (Uint8Array && !isFunction(Uint8Array))) {
	      isFunction = function(value) {
	        // The use of `Object#toString` avoids issues with the `typeof` operator
	        // in older versions of Chrome and Safari which return 'function' for regexes
	        // and Safari 8 equivalents which return 'object' for typed array constructors.
	        return objToString.call(value) == funcTag;
	      };
	    }

	    /**
	     * Checks if `value` is the language type of `Object`.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // Avoid a V8 JIT bug in Chrome 19-20.
	      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	      var type = typeof value;
	      return type == 'function' || (value && type == 'object') || false;
	    }

	    /**
	     * Performs a deep comparison between `object` and `source` to determine if
	     * `object` contains equivalent property values. If `customizer` is provided
	     * it is invoked to compare values. If `customizer` returns `undefined`
	     * comparisons are handled by the method instead. The `customizer` is bound
	     * to `thisArg` and invoked with three arguments; (value, other, index|key).
	     *
	     * **Note:** This method supports comparing properties of arrays, booleans,
	     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
	     * and DOM nodes are **not** supported. Provide a customizer function to extend
	     * support for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     *
	     * // using a customizer callback
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatch(object, source, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isMatch(object, source, customizer, thisArg) {
	      var props = keys(source),
	          length = props.length;

	      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
	      if (!customizer && length == 1) {
	        var key = props[0],
	            value = source[key];

	        if (isStrictComparable(value)) {
	          return object != null && value === object[key] && hasOwnProperty.call(object, key);
	        }
	      }
	      var values = Array(length),
	          strictCompareFlags = Array(length);

	      while (length--) {
	        value = values[length] = source[props[length]];
	        strictCompareFlags[length] = isStrictComparable(value);
	      }
	      return baseIsMatch(object, props, values, strictCompareFlags, customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is not the same as native `isNaN` which returns `true`
	     * for `undefined` and other non-numeric values. See the [ES5 spec](https://es5.github.io/#x15.1.2.4)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a native function.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (value == null) {
	        return false;
	      }
	      if (objToString.call(value) == funcTag) {
	        return reNative.test(fnToString.call(value));
	      }
	      return (isObjectLike(value) && reHostCtor.test(value)) || false;
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	     * as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4);
	     * // => true
	     *
	     * _.isNumber(NaN);
	     * // => true
	     *
	     * _.isNumber('8.4');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * **Note:** This method assumes objects created by the `Object` constructor
	     * have no inherited enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
	      if (!(value && objToString.call(value) == objectTag)) {
	        return false;
	      }
	      var valueOf = value.valueOf,
	          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

	      return objProto
	        ? (value == objProto || getPrototypeOf(value) == objProto)
	        : shimIsPlainObject(value);
	    };

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    function isRegExp(value) {
	      return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
	    }

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    function isTypedArray(value) {
	      return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
	    }

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return typeof value == 'undefined';
	    }

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3);
	     * // => [2, 3]
	     */
	    function toArray(value) {
	      var length = value ? value.length : 0;
	      if (!isLength(length)) {
	        return values(value);
	      }
	      if (!length) {
	        return [];
	      }
	      return arrayCopy(value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable
	     * properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return baseCopy(value, keysIn(value));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources overwrite property assignments of previous sources.
	     * If `customizer` is provided it is invoked to produce the assigned values.
	     * The `customizer` is bound to `thisArg` and invoked with five arguments;
	     * (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using a customizer callback
	     * var defaults = _.partialRight(_.assign, function(value, other) {
	     *   return typeof value == 'undefined' ? other : value;
	     * });
	     *
	     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var assign = createAssigner(baseAssign);

	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties, guard) {
	      var result = baseCreate(prototype);
	      if (guard && isIterateeCall(prototype, properties, guard)) {
	        properties = null;
	      }
	      return properties ? baseCopy(properties, result, keys(properties)) : result;
	    }

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional defaults of the same property are ignored.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    function defaults(object) {
	      if (object == null) {
	        return object;
	      }
	      var args = arrayCopy(arguments);
	      args.push(assignDefaults);
	      return assign.apply(undefined, args);
	    }

	    /**
	     * This method is like `_.findIndex` except that it returns the key of the
	     * first element `predicate` returns truthy for, instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(chr) { return chr.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // using the "_.matches" callback shorthand
	     * _.findKey(users, { 'age': 1 });
	     * // => 'pebbles'
	     *
	     * // using the "_.property" callback shorthand
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 3);
	      return baseFind(object, predicate, baseForOwn, true);
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * If a property name is provided for `predicate` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `predicate` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(chr) { return chr.age < 40; });
	     * // => returns `pebbles` assuming `_.findKey` returns `barney`
	     *
	     * // using the "_.matches" callback shorthand
	     * _.findLastKey(users, { 'age': 36 });
	     * // => 'barney'
	     *
	     * // using the "_.property" callback shorthand
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 3);
	      return baseFind(object, predicate, baseForOwnRight, true);
	    }

	    /**
	     * Iterates over own and inherited enumerable properties of an object invoking
	     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments; (value, key, object). Iterator functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
	     */
	    function forIn(object, iteratee, thisArg) {
	      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
	        iteratee = bindCallback(iteratee, thisArg, 3);
	      }
	      return baseFor(object, iteratee, keysIn);
	    }

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
	     */
	    function forInRight(object, iteratee, thisArg) {
	      iteratee = bindCallback(iteratee, thisArg, 3);
	      return baseForRight(object, iteratee, keysIn);
	    }

	    /**
	     * Iterates over own enumerable properties of an object invoking `iteratee`
	     * for each property. The `iteratee` is bound to `thisArg` and invoked with
	     * three arguments; (value, key, object). Iterator functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {
	     *   console.log(key);
	     * });
	     * // => logs '0', '1', and 'length' (iteration order is not guaranteed)
	     */
	    function forOwn(object, iteratee, thisArg) {
	      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
	        iteratee = bindCallback(iteratee, thisArg, 3);
	      }
	      return baseForOwn(object, iteratee);
	    }

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
	     */
	    function forOwnRight(object, iteratee, thisArg) {
	      iteratee = bindCallback(iteratee, thisArg, 3);
	      return baseForRight(object, iteratee, keys);
	    }

	    /**
	     * Creates an array of function property names from all enumerable properties,
	     * own and inherited, of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['all', 'any', 'bind', ...]
	     */
	    function functions(object) {
	      return baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Checks if `key` exists as a direct property of `object` instead of an
	     * inherited property.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
	     * @example
	     *
	     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
	     * // => true
	     */
	    function has(object, key) {
	      return object ? hasOwnProperty.call(object, key) : false;
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite property
	     * assignments of previous values unless `multiValue` is `true`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {boolean} [multiValue] Allow multiple values per key.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * _.invert({ 'first': 'fred', 'second': 'barney' });
	     * // => { 'fred': 'first', 'barney': 'second' }
	     *
	     * // without `multiValue`
	     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' });
	     * // => { 'fred': 'third', 'barney': 'second' }
	     *
	     * // with `multiValue`
	     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' }, true);
	     * // => { 'fred': ['first', 'third'], 'barney': ['second'] }
	     */
	    function invert(object, multiValue, guard) {
	      if (guard && isIterateeCall(object, multiValue, guard)) {
	        multiValue = null;
	      }
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index],
	            value = object[key];

	        if (multiValue) {
	          if (hasOwnProperty.call(result, value)) {
	            result[value].push(key);
	          } else {
	            result[value] = [key];
	          }
	        }
	        else {
	          result[value] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      if (object) {
	        var Ctor = object.constructor,
	            length = object.length;
	      }
	      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	         (typeof object != 'function' && (length && isLength(length)))) {
	        return shimKeys(object);
	      }
	      return isObject(object) ? nativeKeys(object) : [];
	    };

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      if (object == null) {
	        return [];
	      }
	      if (!isObject(object)) {
	        object = Object(object);
	      }
	      var length = object.length;
	      length = (length && isLength(length) &&
	        (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

	      var Ctor = object.constructor,
	          index = -1,
	          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	          result = Array(length),
	          skipIndexes = length > 0;

	      while (++index < length) {
	        result[index] = (index + '');
	      }
	      for (var key in object) {
	        if (!(skipIndexes && isIndex(key, length)) &&
	            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through `iteratee`. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * If a property name is provided for `iteratee` the created "_.property"
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for `iteratee` the created "_.matches" style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration. If a property name or object is provided it is used to
	     *  create a "_.property" or "_.matches" style callback respectively.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(n) { return n * 3; });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using the "_.property" callback shorthand
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee, thisArg) {
	      var result = {};
	      iteratee = getCallback(iteratee, thisArg, 3);

	      baseForOwn(object, function(value, key, object) {
	        result[key] = iteratee(value, key, object);
	      });
	      return result;
	    }

	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * overwrite property assignments of previous sources. If `customizer` is
	     * provided it is invoked to produce the merged values of the destination and
	     * source properties. If `customizer` returns `undefined` merging is handled
	     * by the method instead. The `customizer` is bound to `thisArg` and invoked
	     * with five arguments; (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize merging properties.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     *
	     * // using a customizer callback
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(object, other, function(a, b) {
	     *   return _.isArray(a) ? a.concat(b) : undefined;
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */
	    var merge = createAssigner(baseMerge);

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable properties of `object` that are not omitted.
	     * Property names may be specified as individual arguments or as arrays of
	     * property names. If `predicate` is provided it is invoked for each property
	     * of `object` omitting the properties `predicate` returns truthy for. The
	     * predicate is bound to `thisArg` and invoked with three arguments;
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to omit, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.omit(object, 'age');
	     * // => { 'user': 'fred' }
	     *
	     * _.omit(object, _.isNumber);
	     * // => { 'user': 'fred' }
	     */
	    function omit(object, predicate, thisArg) {
	      if (object == null) {
	        return {};
	      }
	      if (typeof predicate != 'function') {
	        var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
	        return pickByArray(object, baseDifference(keysIn(object), props));
	      }
	      predicate = bindCallback(predicate, thisArg, 3);
	      return pickByCallback(object, function(value, key, object) {
	        return !predicate(value, key, object);
	      });
	    }

	    /**
	     * Creates a two dimensional array of the key-value pairs for `object`,
	     * e.g. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	     */
	    function pairs(object) {
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed of the picked `object` properties. Property
	     * names may be specified as individual arguments or as arrays of property
	     * names. If `predicate` is provided it is invoked for each property of `object`
	     * picking the properties `predicate` returns truthy for. The predicate is
	     * bound to `thisArg` and invoked with three arguments; (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.pick(object, 'user');
	     * // => { 'user': 'fred' }
	     *
	     * _.pick(object, _.isString);
	     * // => { 'user': 'fred' }
	     */
	    function pick(object, predicate, thisArg) {
	      if (object == null) {
	        return {};
	      }
	      return typeof predicate == 'function'
	        ? pickByCallback(object, bindCallback(predicate, thisArg, 3))
	        : pickByArray(object, baseFlatten(arguments, false, false, 1));
	    }

	    /**
	     * Resolves the value of property `key` on `object`. If the value of `key` is
	     * a function it is invoked with the `this` binding of `object` and its result
	     * is returned, else the property value is returned. If the property value is
	     * `undefined` the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the property to resolve.
	     * @param {*} [defaultValue] The value returned if the property value
	     *  resolves to `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': _.constant(40) };
	     *
	     * _.result(object, 'user');
	     * // => 'fred'
	     *
	     * _.result(object, 'age');
	     * // => 40
	     *
	     * _.result(object, 'status', 'busy');
	     * // => 'busy'
	     *
	     * _.result(object, 'status', _.constant('busy'));
	     * // => 'busy'
	     */
	    function result(object, key, defaultValue) {
	      var value = object == null ? undefined : object[key];
	      if (typeof value == 'undefined') {
	        value = defaultValue;
	      }
	      return isFunction(value) ? value.call(object) : value;
	    }

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own enumerable
	     * properties through `iteratee`, with each invocation potentially mutating
	     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
	     * with four arguments; (accumulator, value, key, object). Iterator functions
	     * may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var squares = _.transform([1, 2, 3, 4, 5, 6], function(result, n) {
	     *   n *= n;
	     *   if (n % 2) {
	     *     return result.push(n) < 3;
	     *   }
	     * });
	     * // => [1, 9, 25]
	     *
	     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6, 'c': 9 }
	     */
	    function transform(object, iteratee, accumulator, thisArg) {
	      var isArr = isArray(object) || isTypedArray(object);
	      iteratee = getCallback(iteratee, thisArg, 4);

	      if (accumulator == null) {
	        if (isArr || isObject(object)) {
	          var Ctor = object.constructor;
	          if (isArr) {
	            accumulator = isArray(object) ? new Ctor : [];
	          } else {
	            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
	          }
	        } else {
	          accumulator = {};
	        }
	      }
	      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Creates an array of the own enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property values
	     * of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number is returned.
	     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
	     * number is returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      if (floating && isIterateeCall(min, max, floating)) {
	        max = floating = null;
	      }
	      var noMin = min == null,
	          noMax = max == null;

	      if (floating == null) {
	        if (noMax && typeof min == 'boolean') {
	          floating = min;
	          min = 1;
	        }
	        else if (typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	        noMax = false;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to camel case.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/CamelCase) for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__foo_bar__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
	    });

	    /**
	     * Capitalizes the first character of `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('fred');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      string = baseToString(string);
	      return string && (string.charAt(0).toUpperCase() + string.slice(1));
	    }

	    /**
	     * Deburrs `string` by converting latin-1 supplementary letters to basic latin letters.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = baseToString(string);
	      return string && string.replace(reLatin1, deburrLetter);
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search from.
	     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = baseToString(string);
	      target = (target + '');

	      var length = string.length;
	      position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;
	      return position >= 0 && string.indexOf(target, position) == position;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', "'", and '`', in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional characters
	     * use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't require escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value.
	     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in Internet Explorer < 9, they can break out
	     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
	     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
	     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
	     *
	     * When working with HTML you should always quote attribute values to reduce
	     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
	      string = baseToString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
	     * "+", "(", ")", "[", "]", "{" and "}" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = baseToString(string);
	      return (string && reHasRegExpChars.test(string))
	        ? string.replace(reRegExpChars, '\\$&')
	        : string;
	    }

	    /**
	     * Converts `string` to kebab case (a.k.a. spinal case).
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles) for
	     * more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__foo_bar__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Pads `string` on the left and right sides if it is shorter then the given
	     * padding length. The `chars` string may be truncated if the number of padding
	     * characters can't be evenly divided by the padding length.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = baseToString(string);
	      length = +length;

	      var strLength = string.length;
	      if (strLength >= length || !nativeIsFinite(length)) {
	        return string;
	      }
	      var mid = (length - strLength) / 2,
	          leftLength = floor(mid),
	          rightLength = ceil(mid);

	      chars = createPad('', rightLength, chars);
	      return chars.slice(0, leftLength) + string + chars;
	    }

	    /**
	     * Pads `string` on the left side if it is shorter then the given padding
	     * length. The `chars` string may be truncated if the number of padding
	     * characters exceeds the padding length.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padLeft('abc', 6);
	     * // => '   abc'
	     *
	     * _.padLeft('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padLeft('abc', 3);
	     * // => 'abc'
	     */
	    function padLeft(string, length, chars) {
	      string = baseToString(string);
	      return string && (createPad(string, length, chars) + string);
	    }

	    /**
	     * Pads `string` on the right side if it is shorter then the given padding
	     * length. The `chars` string may be truncated if the number of padding
	     * characters exceeds the padding length.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padRight('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padRight('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padRight('abc', 3);
	     * // => 'abc'
	     */
	    function padRight(string, length, chars) {
	      string = baseToString(string);
	      return string && (string + createPad(string, length, chars));
	    }

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
	     * in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the ES5 implementation of `parseInt`.
	     * See the [ES5 spec](https://es5.github.io/#E) for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard && isIterateeCall(string, radix, guard)) {
	        radix = 0;
	      }
	      return nativeParseInt(string, radix);
	    }
	    // Fallback for environments with pre-ES5 implementations.
	    if (nativeParseInt(whitespace + '08') != 8) {
	      parseInt = function(string, radix, guard) {
	        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
	        // Chrome fails to trim leading <BOM> whitespace characters.
	        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
	        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
	          radix = 0;
	        } else if (radix) {
	          radix = +radix;
	        }
	        string = trim(string);
	        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
	      };
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=0] The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n) {
	      var result = '';
	      string = baseToString(string);
	      n = +n;
	      if (n < 1 || !string || !nativeIsFinite(n)) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = floor(n / 2);
	        string += string;
	      } while (n);

	      return result;
	    }

	    /**
	     * Converts `string` to snake case.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Snake_case) for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--foo-bar');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string` to start case.
	     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__foo_bar__');
	     * // => 'Foo Bar'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = baseToString(string);
	      position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
	      return string.lastIndexOf(target, position) == position;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is provided it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes sourceURLs for easier debugging.
	     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for more details.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [options.variable] The data object variable name.
	     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // using the HTML "escape" delimiter to escape data property values
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // using custom template delimiters
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using backslashes to treat delimiters as plain text
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // using the `imports` option to import `jQuery` as `jq`
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     *   var __t, __p = '';
	     *   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     *   return __p;
	     * }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, otherOptions) {
	      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      //var settings = lodash.templateSettings;

	      //if (otherOptions && isIterateeCall(string, options, otherOptions)) {
	        //options = otherOptions = null;
	      //}
	      //string = baseToString(string);
	      //options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

	      //var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
	          //importsKeys = keys(imports),
	          //importsValues = baseValues(imports, importsKeys);

	      //var isEscaping,
	          //isEvaluating,
	          //index = 0,
	          //interpolate = options.interpolate || reNoMatch,
	          //source = "__p += '";

	      //// Compile the regexp to match each delimiter.
	      //var reDelimiters = RegExp(
	        //(options.escape || reNoMatch).source + '|' +
	        //interpolate.source + '|' +
	        //(interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        //(options.evaluate || reNoMatch).source + '|$'
	      //, 'g');

	      //// Use a sourceURL for easier debugging.
	      //var sourceURL = '//# sourceURL=' +
	        //('sourceURL' in options
	          //? options.sourceURL
	          //: ('lodash.templateSources[' + (++templateCounter) + ']')
	        //) + '\n';

	      //string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        //interpolateValue || (interpolateValue = esTemplateValue);

	        //// Escape characters that can't be included in string literals.
	        //source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        //// Replace delimiters with snippets.
	        //if (escapeValue) {
	          //isEscaping = true;
	          //source += "' +\n__e(" + escapeValue + ") +\n'";
	        //}
	        //if (evaluateValue) {
	          //isEvaluating = true;
	          //source += "';\n" + evaluateValue + ";\n__p += '";
	        //}
	        //if (interpolateValue) {
	          //source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        //}
	        //index = offset + match.length;

	        //// The JS engine embedded in Adobe products requires returning the `match`
	        //// string in order to produce the correct `offset` value.
	        //return match;
	      //});

	      //source += "';\n";

	      //// If `variable` is not specified wrap a with-statement around the generated
	      //// code to add the data object to the top of the scope chain.
	      //var variable = options.variable;
	      //if (!variable) {
	        //source = 'with (obj) {\n' + source + '\n}\n';
	      //}
	      //// Cleanup code by stripping empty strings.
	      //source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        //.replace(reEmptyStringMiddle, '$1')
	        //.replace(reEmptyStringTrailing, '$1;');

	      //// Frame code as the function body.
	      //source = 'function(' + (variable || 'obj') + ') {\n' +
	        //(variable
	          //? ''
	          //: 'obj || (obj = {});\n'
	        //) +
	        //"var __t, __p = ''" +
	        //(isEscaping
	           //? ', __e = _.escape'
	           //: ''
	        //) +
	        //(isEvaluating
	          //? ', __j = Array.prototype.join;\n' +
	            //"function print() { __p += __j.call(arguments, '') }\n"
	          //: ';\n'
	        //) +
	        //source +
	        //'return __p\n}';

	      //var result = attempt(function() {
	        //return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
	      //});

	      //// Provide the compiled function's source by its `toString` method or
	      //// the `source` property as a convenience for inlining compiled templates.
	      //result.source = source;
	      //if (isError(result)) {
	        //throw result;
	      //}
	      //return result;
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar]
	     */
	    function trim(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
	      }
	      chars = (chars + '');
	      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimLeft('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimLeft('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimLeft(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string))
	      }
	      return string.slice(charsLeftIndex(string, (chars + '')));
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimRight('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimRight('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimRight(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(0, trimmedRightIndex(string) + 1)
	      }
	      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
	    }

	    /**
	     * Truncates `string` if it is longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object|number} [options] The options object or maximum string length.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.trunc('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', 24);
	     * // => 'hi-diddly-ho there, n...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': ' ' });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': /,? +/ });
	     * //=> 'hi-diddly-ho there...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', { 'omission': ' [...]' });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function trunc(string, options, guard) {
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = null;
	      }
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (options != null) {
	        if (isObject(options)) {
	          var separator = 'separator' in options ? options.separator : separator;
	          length = 'length' in options ? +options.length || 0 : length;
	          omission = 'omission' in options ? baseToString(options.omission) : omission;
	        } else {
	          length = +options || 0;
	        }
	      }
	      string = baseToString(string);
	      if (length >= string.length) {
	        return string;
	      }
	      var end = length - omission.length;
	      if (end < 1) {
	        return omission;
	      }
	      var result = string.slice(0, end);
	      if (separator == null) {
	        return result + omission;
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              newEnd,
	              substring = string.slice(0, end);

	          if (!separator.global) {
	            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            newEnd = match.index;
	          }
	          result = result.slice(0, newEnd == null ? end : newEnd);
	        }
	      } else if (string.indexOf(separator, end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
	     * corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
	     * entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = baseToString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      if (guard && isIterateeCall(string, pattern, guard)) {
	        pattern = null;
	      }
	      string = baseToString(string);
	      return string.match(pattern || reWords) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} func The function to attempt.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // avoid throwing errors for invalid selectors
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    function attempt(func) {
	      try {
	        return func.apply(undefined, baseSlice(arguments, 1));
	      } catch(e) {
	        return isError(e) ? e : Error(e);
	      }
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and arguments of the created function. If `func` is a property name the
	     * created callback returns the property value for a given element. If `func`
	     * is an object the created callback returns `true` for elements that contain
	     * the equivalent object properties, otherwise it returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias iteratee
	     * @category Utility
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
	     *   if (!match) {
	     *     return callback(func, thisArg);
	     *   }
	     *   return function(object) {
	     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(users, 'age__gt36');
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function callback(func, thisArg, guard) {
	      if (guard && isIterateeCall(func, thisArg, guard)) {
	        thisArg = null;
	      }
	      return isObjectLike(func)
	        ? matches(func)
	        : baseCallback(func, thisArg);
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var getter = _.constant(object);
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function which performs a deep comparison between a given object
	     * and `source`, returning `true` if the given object has equivalent property
	     * values, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * var matchesAge = _.matches({ 'age': 36 });
	     *
	     * _.filter(users, matchesAge);
	     * // => [{ 'user': 'barney', 'age': 36 }]
	     *
	     * _.find(users, matchesAge);
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }

	    /**
	     * Adds all own enumerable function properties of a source object to the
	     * destination object. If `object` is a function then methods are added to
	     * its prototype as well.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function|Object} [object=this] object The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added
	     *  are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * // use `_.runInContext` to avoid potential conflicts (esp. in Node.js)
	     * var _ = require('lodash').runInContext();
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      if (options == null) {
	        var isObj = isObject(source),
	            props = isObj && keys(source),
	            methodNames = props && props.length && baseFunctions(source, props);

	        if (!(methodNames ? methodNames.length : isObj)) {
	          methodNames = false;
	          options = source;
	          source = object;
	          object = this;
	        }
	      }
	      if (!methodNames) {
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = true,
	          index = -1,
	          isFunc = isFunction(object),
	          length = methodNames.length;

	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      while (++index < length) {
	        var methodName = methodNames[index],
	            func = source[methodName];

	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = (function(func) {
	            return function() {
	              var chainAll = this.__chain__;
	              if (chain || chainAll) {
	                var result = object(this.__wrapped__);
	                (result.__actions__ = arrayCopy(this.__actions__)).push({ 'func': func, 'args': arguments, 'thisArg': object });
	                result.__chain__ = chainAll;
	                return result;
	              }
	              var args = [this.value()];
	              push.apply(args, arguments);
	              return func.apply(object, args);
	            };
	          }(func));
	        }
	      }
	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      context._ = oldDash;
	      return this;
	    }

	    /**
	     * A no-operation function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function which returns the property value of `key` on a given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * var getName = _.property('user');
	     *
	     * _.map(users, getName);
	     * // => ['fred', barney']
	     *
	     * _.pluck(_.sortBy(users, getName), 'user');
	     * // => ['barney', 'fred']
	     */
	    function property(key) {
	      return baseProperty(key + '');
	    }

	    /**
	     * The inverse of `_.property`; this method creates a function which returns
	     * the property value of a given key on `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to inspect.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40, 'active': true };
	     * _.map(['active', 'user'], _.propertyOf(object));
	     * // => [true, 'fred']
	     *
	     * var object = { 'a': 3, 'b': 1, 'c': 2 };
	     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));
	     * // => ['b', 'c', 'a']
	     */
	    function propertyOf(object) {
	      return function(key) {
	        return object == null ? undefined : object[key];
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. If `start` is less than `end` a
	     * zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      if (step && isIterateeCall(start, end, step)) {
	        end = step = null;
	      }
	      start = +start || 0;
	      step = step == null ? 1 : (+step || 0);

	      if (end == null) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
	      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
	      var index = -1,
	          length = nativeMax(ceil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * Invokes the iteratee function `n` times, returning an array of the results
	     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
	     * one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) { mage.castSpell(n); });
	     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively
	     *
	     * _.times(3, function(n) { this.cast(n); }, mage);
	     * // => also invokes `mage.castSpell(n)` three times
	     */
	    function times(n, iteratee, thisArg) {
	      n = +n;

	      // Exit early to avoid a JSC JIT bug in Safari 8
	      // where `Array(0)` is treated as `Array(1)`.
	      if (n < 1 || !nativeIsFinite(n)) {
	        return [];
	      }
	      var index = -1,
	          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

	      iteratee = bindCallback(iteratee, thisArg, 1);
	      while (++index < n) {
	        if (index < MAX_ARRAY_LENGTH) {
	          result[index] = iteratee(index);
	        } else {
	          iteratee(index);
	        }
	      }
	      return result;
	    }

	    /**
	     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return baseToString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    // Ensure `new LodashWrapper` is an instance of `lodash`.
	    LodashWrapper.prototype = baseCreate(lodash.prototype);

	    // Ensure `new LazyWraper` is an instance of `LodashWrapper`
	    LazyWrapper.prototype = baseCreate(LodashWrapper.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    // Add functions to the `Map` cache.
	    MapCache.prototype['delete'] = mapDelete;
	    MapCache.prototype.get = mapGet;
	    MapCache.prototype.has = mapHas;
	    MapCache.prototype.set = mapSet;

	    // Add functions to the `Set` cache.
	    SetCache.prototype.push = cachePush;

	    // Assign cache to `_.memoize`.
	    memoize.Cache = MapCache;

	    // Add functions that return wrapped values when chaining.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.callback = callback;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortByAll = sortByAll;
	    lodash.spread = spread;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.unzip = unzip;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;

	    // Add aliases.
	    lodash.backflow = flowRight;
	    lodash.collect = map;
	    lodash.compose = flowRight;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.iteratee = callback;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;

	    // Add functions to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add functions that return unwrapped values when chaining.
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.deburr = deburr;
	    lodash.endsWith = endsWith;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.findWhere = findWhere;
	    lodash.first = first;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isMatch = isMatch;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.max = max;
	    lodash.min = min;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padLeft = padLeft;
	    lodash.padRight = padRight;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.result = result;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.template = template;
	    lodash.trim = trim;
	    lodash.trimLeft = trimLeft;
	    lodash.trimRight = trimRight;
	    lodash.trunc = trunc;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.words = words;

	    // Add aliases.
	    lodash.all = every;
	    lodash.any = some;
	    lodash.contains = includes;
	    lodash.detect = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.head = first;
	    lodash.include = includes;
	    lodash.inject = reduce;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), false);

	    /*------------------------------------------------------------------------*/

	    // Add functions capable of returning wrapped and unwrapped values when chaining.
	    lodash.sample = sample;

	    lodash.prototype.sample = function(n) {
	      if (!this.__chain__ && n == null) {
	        return sample(this.value());
	      }
	      return this.thru(function(value) {
	        return sample(value, n);
	      });
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var isFilter = index == LAZY_FILTER_FLAG,
	          isWhile = index == LAZY_WHILE_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
	        var result = this.clone(),
	            filtered = result.__filtered__,
	            iteratees = result.__iteratees__ || (result.__iteratees__ = []);

	        result.__filtered__ = filtered || isFilter || (isWhile && result.__dir__ < 0);
	        iteratees.push({ 'iteratee': getCallback(iteratee, thisArg, 3), 'type': index });
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      var countName = '__' + methodName + 'Count__',
	          whileName = methodName + 'While';

	      LazyWrapper.prototype[methodName] = function(n) {
	        n = n == null ? 1 : nativeMax(+n || 0, 0);

	        var result = this.clone();
	        if (result.__filtered__) {
	          var value = result[countName];
	          result[countName] = index ? nativeMin(value, n) : (value + n);
	        } else {
	          var views = result.__views__ || (result.__views__ = []);
	          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };

	      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
	        return this.reverse()[whileName](predicate, thisArg).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods for `_.first` and `_.last`.
	    arrayEach(['first', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right': '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
	    arrayEach(['initial', 'rest'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[dropName](1);
	      };
	    });

	    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
	    arrayEach(['pluck', 'where'], function(methodName, index) {
	      var operationName = index ? 'filter' : 'map',
	          createCallback = index ? baseMatches : baseProperty;

	      LazyWrapper.prototype[methodName] = function(value) {
	        return this[operationName](createCallback(index ? value : (value + '')));
	      };
	    });

	    LazyWrapper.prototype.dropWhile = function(iteratee, thisArg) {
	      var done;
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return this.filter(function(value, index, array) {
	        return done || (done = !iteratee(value, index, array));
	      });
	    };

	    LazyWrapper.prototype.reject = function(iteratee, thisArg) {
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return this.filter(function(value, index, array) {
	        return !iteratee(value, index, array);
	      });
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = start == null ? 0 : (+start || 0);
	      var result = start < 0 ? this.takeRight(-start) : this.drop(start);

	      if (typeof end != 'undefined') {
	        end = (+end || 0);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName],
	          retUnwrapped = /^(?:first|last)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = arguments,
	            chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isLazy = value instanceof LazyWrapper,
	            onlyLazy = isLazy && !isHybrid;

	        if (retUnwrapped && !chainAll) {
	          return onlyLazy
	            ? func.call(value)
	            : lodashFunc.call(lodash, this.value());
	        }
	        var interceptor = function(value) {
	          var otherArgs = [value];
	          push.apply(otherArgs, args);
	          return lodashFunc.apply(lodash, otherArgs);
	        };
	        if (isLazy || isArray(value)) {
	          var wrapper = onlyLazy ? value : new LazyWrapper(this),
	              result = func.apply(wrapper, args);

	          if (!retUnwrapped && (isHybrid || result.__actions__)) {
	            var actions = result.__actions__ || (result.__actions__ = []);
	            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
	          }
	          return new LodashWrapper(result, chainAll);
	        }
	        return this.thru(interceptor);
	      };
	    });

	    // Add `Array.prototype` functions to `lodash.prototype`.
	    arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          return func.apply(this.value(), args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(value, args);
	        });
	      };
	    });

	    // Add functions to the lazy wrapper.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chaining functions to the lodash wrapper.
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add function aliases to the lodash wrapper.
	    lodash.prototype.collect = lodash.prototype.map;
	    lodash.prototype.head = lodash.prototype.first;
	    lodash.prototype.select = lodash.prototype.filter;
	    lodash.prototype.tail = lodash.prototype.rest;

	    return lodash;
	  }

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose lodash to the global object when an AMD loader is present to avoid
	    // errors in cases where lodash is loaded by a script tag and not intended
	    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
	    // more details.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for Node.js or RingoJS.
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // Export for Narwhal or Rhino -require.
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // Export for a browser or Rhino.
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46)(module), (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var buffer = __webpack_require__(1);
	var assert = __webpack_require__(8);

	var js = __webpack_require__(4);
	var $ = __webpack_require__(5);

	function equals(a, b) {
	  if (a.length !== b.length) {
	    return false;
	  }
	  var length = a.length;
	  for (var i = 0; i < length; i++) {
	    if (a[i] !== b[i]) {
	      return false;
	    }
	  }
	  return true;
	}

	module.exports = {
	  /**
	   * Fill a buffer with a value.
	   *
	   * @param {Buffer} buffer
	   * @param {number} value
	   * @return {Buffer}
	   */
	  fill: function fill(buffer, value) {
	    $.checkArgumentType(buffer, 'Buffer', 'buffer');
	    $.checkArgumentType(value, 'number', 'value');
	    var length = buffer.length;
	    for (var i = 0; i < length; i++) {
	      buffer[i] = value;
	    }
	    return buffer;
	  },

	  /**
	   * Returns true if the given argument is an instance of a buffer. Tests for
	   * both node's Buffer and Uint8Array
	   *
	   * @param {*} arg
	   * @return {boolean}
	   */
	  isBuffer: function isBuffer(arg) {
	    return buffer.Buffer.isBuffer(arg) || arg instanceof Uint8Array;
	  },

	  /**
	   * Returns a zero-filled byte array
	   *
	   * @param {number} bytes
	   * @return {Buffer}
	   */
	  emptyBuffer: function emptyBuffer(bytes) {
	    $.checkArgumentType(bytes, 'number', 'bytes');
	    var result = new buffer.Buffer(bytes);
	    for (var i = 0; i < bytes; i++) {
	      result.write('\0', i);
	    }
	    return result;
	  },

	  /**
	   * Concatenates a buffer
	   *
	   * Shortcut for <tt>buffer.Buffer.concat</tt>
	   */
	  concat: buffer.Buffer.concat,

	  equals: equals,
	  equal: equals,

	  /**
	   * Transforms a number from 0 to 255 into a Buffer of size 1 with that value
	   *
	   * @param {number} integer
	   * @return {Buffer}
	   */
	  integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {
	    $.checkArgumentType(integer, 'number', 'integer');
	    return new buffer.Buffer([integer & 0xff]);
	  },

	  /**
	   * Transform a 4-byte integer into a Buffer of length 4.
	   *
	   * @param {number} integer
	   * @return {Buffer}
	   */
	  integerAsBuffer: function integerAsBuffer(integer) {
	    $.checkArgumentType(integer, 'number', 'integer');
	    var bytes = [];
	    bytes.push((integer >> 24) & 0xff);
	    bytes.push((integer >> 16) & 0xff);
	    bytes.push((integer >> 8) & 0xff);
	    bytes.push(integer & 0xff);
	    return new Buffer(bytes);
	  },

	  /**
	   * Transform the first 4 values of a Buffer into a number, in little endian encoding
	   *
	   * @param {Buffer} buffer
	   * @return {number}
	   */
	  integerFromBuffer: function integerFromBuffer(buffer) {
	    $.checkArgumentType(buffer, 'Buffer', 'buffer');
	    return buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
	  },

	  /**
	   * Transforms the first byte of an array into a number ranging from -128 to 127
	   * @param {Buffer} buffer
	   * @return {number}
	   */
	  integerFromSingleByteBuffer: function integerFromBuffer(buffer) {
	    $.checkArgumentType(buffer, 'Buffer', 'buffer');
	    return buffer[0];
	  },

	  /**
	   * Transforms a buffer into a string with a number in hexa representation
	   *
	   * Shorthand for <tt>buffer.toString('hex')</tt>
	   *
	   * @param {Buffer} buffer
	   * @return {string}
	   */
	  bufferToHex: function bufferToHex(buffer) {
	    $.checkArgumentType(buffer, 'Buffer', 'buffer');
	    return buffer.toString('hex');
	  },

	  /**
	   * Reverse a buffer
	   * @param {Buffer} param
	   * @return {Buffer}
	   */
	  reverse: function reverse(param) {
	    $.checkArgumentType(param, 'Buffer', 'param');
	    var ret = new buffer.Buffer(param.length);
	    for (var i = 0; i < param.length; i++) {
	      ret[i] = param[param.length - i - 1];
	    }
	    return ret;
	  },

	  /**
	   * Transforms an hexa encoded string into a Buffer with binary values
	   *
	   * Shorthand for <tt>Buffer(string, 'hex')</tt>
	   *
	   * @param {string} string
	   * @return {Buffer}
	   */
	  hexToBuffer: function hexToBuffer(string) {
	    assert(js.isHexa(string));
	    return new buffer.Buffer(string, 'hex');
	  }
	};

	module.exports.NULL_HASH = module.exports.fill(new Buffer(32), 0);
	module.exports.EMPTY_BUFFER = new Buffer(0);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);

	/**
	 * Determines whether a string contains only hexadecimal values
	 *
	 * @name JSUtil.isHexa
	 * @param {string} value
	 * @return {boolean} true if the string is the hexa representation of a number
	 */
	var isHexa = function isHexa(value) {
	  if (!_.isString(value)) {
	    return false;
	  }
	  return /^[0-9a-fA-F]+$/.test(value);
	};

	/**
	 * @namespace JSUtil
	 */
	module.exports = {
	  /**
	   * Test if an argument is a valid JSON object. If it is, returns a truthy
	   * value (the json object decoded), so no double JSON.parse call is necessary
	   *
	   * @param {string} arg
	   * @return {Object|boolean} false if the argument is not a JSON string.
	   */
	  isValidJSON: function isValidJSON(arg) {
	    var parsed;
	    try {
	      parsed = JSON.parse(arg);
	    } catch (e) {
	      return false;
	    }
	    if (typeof(parsed) === 'object') {
	      return true;
	    }
	    return false;
	  },
	  isHexa: isHexa,
	  isHexaString: isHexa,

	  /**
	   * Clone an array
	   */
	  cloneArray: function(array) {
	    return [].concat(array);
	  },

	  /**
	   * Define immutable properties on a target object
	   *
	   * @param {Object} target - An object to be extended
	   * @param {Object} values - An object of properties
	   * @return {Object} The target object
	   */
	  defineImmutable: function defineImmutable(target, values){
	    Object.keys(values).forEach(function(key){
	      Object.defineProperty(target, key, {
	        configurable: false,
	        enumerable: true,
	        value: values[key]
	      });
	    });
	    return target;
	  }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var errors = __webpack_require__(15);
	var _ = __webpack_require__(2);

	module.exports = {
	  checkState: function(condition, message) {
	    if (!condition) {
	      throw new errors.InvalidState(message);
	    }
	  },
	  checkArgument: function(condition, argumentName, message) {
	    if (!condition) {
	      throw new errors.InvalidArgument(argumentName, message);
	    }
	  },
	  checkArgumentType: function(argument, type, argumentName) {
	    argumentName = argumentName || '(unknown name)';
	    if (_.isString(type)) {
	      if (type === 'Buffer') {
	        var BufferUtil = __webpack_require__(3);
	        if (!BufferUtil.isBuffer(argument)) {
	          throw new errors.InvalidArgumentType(argument, type, argumentName);
	        }
	      } else if (typeof argument !== type) {
	        throw new errors.InvalidArgumentType(argument, type, argumentName);
	      }
	    } else {
	      if (!(argument instanceof type)) {
	        throw new errors.InvalidArgumentType(argument, type.name, argumentName);
	      }
	    }
	  }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _BN = __webpack_require__(10);
	var $ = __webpack_require__(5);
	var _ = __webpack_require__(2);

	var BN = function BN(n, base) {
	  if (!(this instanceof BN)) {
	    return new BN(n, base);
	  }
	  _BN.apply(this, arguments);
	};

	BN.prototype = _BN.prototype;

	var reversebuf = function(buf) {
	  var buf2 = new Buffer(buf.length);
	  for (var i = 0; i < buf.length; i++) {
	    buf2[i] = buf[buf.length - 1 - i];
	  }
	  return buf2;
	};

	BN.fromNumber = function(n) {
	  $.checkArgument(_.isNumber(n));
	  return BN(n);
	};

	BN.prototype.toNumber = function() {
	  return parseInt(this.toString(10), 10);
	};

	BN.fromString = function(str) {
	  $.checkArgument(_.isString(str));
	  return BN(str);
	};

	BN.fromBuffer = function(buf, opts) {
	  if (typeof opts !== 'undefined' && opts.endian === 'little') {
	    buf = reversebuf(buf);
	  }
	  var hex = buf.toString('hex');
	  var bn = new BN(hex, 16);
	  return bn;
	};

	BN.trim = function(buf, natlen) {
	  return buf.slice(natlen - buf.length, buf.length);
	};

	BN.pad = function(buf, natlen, size) {
	  var rbuf = new Buffer(size);
	  for (var i = 0; i < buf.length; i++) {
	    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];
	  }
	  for (i = 0; i < size - natlen; i++) {
	    rbuf[i] = 0;
	  }
	  return rbuf;
	};

	BN.prototype.toBuffer = function(opts) {
	  var buf, hex;
	  if (opts && opts.size) {
	    hex = this.toString(16, 2);
	    var natlen = hex.length / 2;
	    buf = new Buffer(hex, 'hex');

	    if (natlen === opts.size) {
	      buf = buf;
	    } else if (natlen > opts.size) {
	      buf = BN.trim(buf, natlen);
	    } else if (natlen < opts.size) {
	      buf = BN.pad(buf, natlen, opts.size);
	    }
	  } else {
	    hex = this.toString(16, 2);
	    buf = new Buffer(hex, 'hex');
	  }

	  if (typeof opts !== 'undefined' && opts.endian === 'little') {
	    buf = reversebuf(buf);
	  }

	  return buf;
	};

	// signed magnitude buffer
	// most significant bit represents sign (0 = positive, -1 = negative)
	BN.fromSM = function(buf, opts) {
	  var ret;
	  if (buf.length === 0) {
	    return BN.fromBuffer(new Buffer([0]));
	  }

	  var endian = 'big';
	  if (opts) {
	    endian = opts.endian;
	  }
	  if (endian === 'little') {
	    buf = reversebuf(buf);
	  }

	  if (buf[0] & 0x80) {
	    buf[0] = buf[0] & 0x7f;
	    ret = BN.fromBuffer(buf);
	    ret.neg().copy(ret);
	  } else {
	    ret = BN.fromBuffer(buf);
	  }
	  return ret;
	};

	BN.prototype.toSMBigEndian = function() {
	  var buf;
	  if (this.cmp(0) === -1) {
	    buf = this.neg().toBuffer();
	    if (buf[0] & 0x80) {
	      buf = Buffer.concat([new Buffer([0x80]), buf]);
	    } else {
	      buf[0] = buf[0] | 0x80;
	    }
	  } else {
	    buf = this.toBuffer();
	    if (buf[0] & 0x80) {
	      buf = Buffer.concat([new Buffer([0x00]), buf]);
	    }
	  }

	  if (buf.length === 1 & buf[0] === 0) {
	    buf = new Buffer([]);
	  }
	  return buf;
	};
	BN.prototype.toSM = function(opts) {
	  var endian = opts ? opts.endian : 'big';
	  var buf = this.toSMBigEndian();

	  if (endian === 'little') {
	    buf = reversebuf(buf);
	  }
	  return buf;
	};

	// This is analogous to the constructor for CScriptNum in bitcoind. Many ops in
	// bitcoind's script interpreter use CScriptNum, which is not really a proper
	// bignum. Instead, an error is thrown if trying to input a number bigger than
	// 4 bytes. We copy that behavior here.
	BN.fromScriptNumBuffer = function(buf, fRequireMinimal) {
	  var nMaxNumSize = 4;
	  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));
	  if (fRequireMinimal && buf.length > 0) {
	    // Check that the number is encoded with the minimum possible
	    // number of bytes.
	    //
	    // If the most-significant-byte - excluding the sign bit - is zero
	    // then we're not minimal. Note how this test also rejects the
	    // negative-zero encoding, 0x80.
	    if ((buf[buf.length - 1] & 0x7f) === 0) {
	      // One exception: if there's more than one byte and the most
	      // significant bit of the second-most-significant-byte is set
	      // it would conflict with the sign bit. An example of this case
	      // is +-255, which encode to 0xff00 and 0xff80 respectively.
	      // (big-endian).
	      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {
	        throw new Error('non-minimally encoded script number');
	      }
	    }
	  }
	  return BN.fromSM(buf, {
	    endian: 'little'
	  });
	};

	// The corollary to the above, with the notable exception that we do not throw
	// an error if the output is larger than four bytes. (Which can happen if
	// performing a numerical operation that results in an overflow to more than 4
	// bytes).
	BN.prototype.toScriptNumBuffer = function() {
	  return this.toSM({
	    endian: 'little'
	  });
	};

	var decorate = function decorate(name) {
	  BN.prototype['_' + name] = BN.prototype[name];
	  var f = function(b) {
	    if (typeof b === 'string') {
	      b = new BN(b);
	    } else if (typeof b === 'number') {
	      b = new BN(b.toString());
	    }
	    return this['_' + name](b);
	  };
	  BN.prototype[name] = f;
	};

	BN.prototype.gt = function(b) {
	  return this.cmp(b) > 0;
	};

	BN.prototype.lt = function(b) {
	  return this.cmp(b) < 0;
	};

	decorate('add');
	decorate('sub');
	decorate('mul');
	decorate('mod');
	decorate('div');
	decorate('cmp');
	decorate('gt');
	decorate('lt');

	module.exports = BN;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var hashjs = __webpack_require__(20);
	var sha512 = __webpack_require__(106);
	var crypto = __webpack_require__(47);
	var BufferUtil = __webpack_require__(3);
	var $ = __webpack_require__(5);

	var Hash = module.exports;

	Hash.sha1 = function(buf) {
	  $.checkArgument(BufferUtil.isBuffer(buf));
	  return crypto.createHash('sha1').update(buf).digest();
	};

	Hash.sha1.blocksize = 512;

	Hash.sha256 = function(buf) {
	  $.checkArgument(BufferUtil.isBuffer(buf));
	  return crypto.createHash('sha256').update(buf).digest();
	};

	Hash.sha256.blocksize = 512;

	Hash.sha256sha256 = function(buf) {
	  $.checkArgument(BufferUtil.isBuffer(buf));
	  return Hash.sha256(Hash.sha256(buf));
	};

	Hash.ripemd160 = function(buf) {
	  $.checkArgument(BufferUtil.isBuffer(buf));
	  var hash = (new hashjs.ripemd160()).update(buf).digest();
	  return new Buffer(hash);
	};

	Hash.sha256ripemd160 = function(buf) {
	  $.checkArgument(BufferUtil.isBuffer(buf));
	  return Hash.ripemd160(Hash.sha256(buf));
	};

	Hash.sha512 = function(buf) {
	  $.checkArgument(BufferUtil.isBuffer(buf));
	  var hash = sha512(buf);
	  return new Buffer(hash);
	};

	Hash.sha512.blocksize = 1024;

	Hash.hmac = function(hashf, data, key) {
	  //http://en.wikipedia.org/wiki/Hash-based_message_authentication_code
	  //http://tools.ietf.org/html/rfc4868#section-2
	  $.checkArgument(BufferUtil.isBuffer(data));
	  $.checkArgument(BufferUtil.isBuffer(key));
	  $.checkArgument(hashf.blocksize);

	  var blocksize = hashf.blocksize / 8;

	  if (key.length > blocksize) {
	    key = hashf(key);
	  } else if (key < blocksize) {
	    var fill = new Buffer(blocksize);
	    fill.fill(0);
	    key.copy(fill);
	    key = fill;
	  }

	  var o_key = new Buffer(blocksize);
	  o_key.fill(0x5c);

	  var i_key = new Buffer(blocksize);
	  i_key.fill(0x36);

	  var o_key_pad = new Buffer(blocksize);
	  var i_key_pad = new Buffer(blocksize);
	  for (var i = 0; i < blocksize; i++) {
	    o_key_pad[i] = o_key[i] ^ key[i];
	    i_key_pad[i] = i_key[i] ^ key[i];
	  }

	  return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));
	};

	Hash.sha256hmac = function(data, key) {
	  return Hash.hmac(Hash.sha256, data, key);
	};

	Hash.sha512hmac = function(data, key) {
	  return Hash.hmac(Hash.sha512, data, key);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	// when used in node, this will actually load the util module we depend on
	// versus loading the builtin util module as happens otherwise
	// this is a bug in node module loading as far as I am concerned
	var util = __webpack_require__(16);

	var pSlice = Array.prototype.slice;
	var hasOwn = Object.prototype.hasOwnProperty;

	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  }
	  else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = stackStartFunction.name;
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && !isFinite(value)) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}

	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}

	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;

	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }

	    return true;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b)) {
	    return a === b;
	  }
	  var aIsArgs = isArguments(a),
	      bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  var ka = objectKeys(a),
	      kb = objectKeys(b),
	      key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }

	  return false;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }

	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};

	assert.ifError = function(err) { if (err) {throw err;}};

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(60);

	module.exports.Interpreter = __webpack_require__(84);


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// Utils

	function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	}

	function assertEqual(l, r, msg) {
	  if (l != r)
	    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
	}

	// Could use `inherits` module, but don't want to move from single file
	// architecture yet.
	function inherits(ctor, superCtor) {
	  ctor.super_ = superCtor
	  var TempCtor = function () {}
	  TempCtor.prototype = superCtor.prototype
	  ctor.prototype = new TempCtor()
	  ctor.prototype.constructor = ctor
	}

	// BN

	function BN(number, base, endian) {
	  // May be `new BN(bn)` ?
	  if (number !== null &&
	      typeof number === 'object' &&
	      Array.isArray(number.words)) {
	    return number;
	  }

	  this.sign = false;
	  this.words = null;
	  this.length = 0;

	  // Reduction context
	  this.red = null;

	  if (base === 'le' || base === 'be') {
	    endian = base;
	    base = 10;
	  }

	  if (number !== null)
	    this._init(number || 0, base || 10, endian || 'be');
	}
	if (true)
	  module.exports = BN;

	BN.BN = BN;
	BN.wordSize = 26;

	BN.prototype._init = function init(number, base, endian) {
	  if (typeof number === 'number') {
	    if (number < 0) {
	      this.sign = true;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [ number & 0x3ffffff ];
	      this.length = 1;
	    } else {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    }
	    return;
	  } else if (typeof number === 'object') {
	    return this._initArray(number, base, endian);
	  }
	  if (base === 'hex')
	    base = 16;
	  assert(base === (base | 0) && base >= 2 && base <= 36);

	  number = number.toString().replace(/\s+/g, '');
	  var start = 0;
	  if (number[0] === '-')
	    start++;

	  if (base === 16)
	    this._parseHex(number, start);
	  else
	    this._parseBase(number, base, start);

	  if (number[0] === '-')
	    this.sign = true;

	  this.strip();
	};

	BN.prototype._initArray = function _initArray(number, base, endian) {
	  // Perhaps a Uint8Array
	  assert(typeof number.length === 'number');
	  this.length = Math.ceil(number.length / 3);
	  this.words = new Array(this.length);
	  for (var i = 0; i < this.length; i++)
	    this.words[i] = 0;

	  var off = 0;
	  if (endian === 'be') {
	    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
	      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j++;
	      }
	    }
	  } else if (endian === 'le') {
	    for (var i = 0, j = 0; i < number.length; i += 3) {
	      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j++;
	      }
	    }
	  }
	  return this.strip();
	};

	BN.prototype._parseHex = function parseHex(number, start) {
	  // Create possibly bigger array to ensure that it fits the number
	  this.length = Math.ceil((number.length - start) / 6);
	  this.words = new Array(this.length);
	  for (var i = 0; i < this.length; i++)
	    this.words[i] = 0;

	  // Scan 24-bit chunks and add them to the number
	  var off = 0;
	  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
	    var w = parseInt(number.slice(i, i + 6), 16);
	    this.words[j] |= (w << off) & 0x3ffffff;
	    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	    off += 24;
	    if (off >= 26) {
	      off -= 26;
	      j++;
	    }
	  }
	  if (i + 6 !== start) {
	    var w = parseInt(number.slice(start, i + 6), 16);
	    this.words[j] |= (w << off) & 0x3ffffff;
	    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	  }
	  this.strip();
	};

	BN.prototype._parseBase = function parseBase(number, base, start) {
	  // Initialize as zero
	  this.words = [ 0 ];
	  this.length = 1;

	  var word = 0;
	  var q = 1;
	  var p = 0;
	  var bigQ = null;
	  for (var i = start; i < number.length; i++) {
	    var digit;
	    var ch = number[i];
	    if (base === 10 || ch <= '9')
	      digit = ch | 0;
	    else if (ch >= 'a')
	      digit = ch.charCodeAt(0) - 97 + 10;
	    else
	      digit = ch.charCodeAt(0) - 65 + 10;
	    word *= base;
	    word += digit;
	    q *= base;
	    p++;

	    if (q > 0xfffff) {
	      assert(q <= 0x3ffffff);
	      if (!bigQ)
	        bigQ = new BN(q);
	      this.mul(bigQ).copy(this);
	      this.iadd(new BN(word));
	      word = 0;
	      q = 1;
	      p = 0;
	    }
	  }
	  if (p !== 0) {
	    this.mul(new BN(q)).copy(this);
	    this.iadd(new BN(word));
	  }
	};

	BN.prototype.copy = function copy(dest) {
	  dest.words = new Array(this.length);
	  for (var i = 0; i < this.length; i++)
	    dest.words[i] = this.words[i];
	  dest.length = this.length;
	  dest.sign = this.sign;
	  dest.red = this.red;
	};

	BN.prototype.clone = function clone() {
	  var r = new BN(null);
	  this.copy(r);
	  return r;
	};

	// Remove leading `0` from `this`
	BN.prototype.strip = function strip() {
	  while (this.length > 1 && this.words[this.length - 1] === 0)
	    this.length--;
	  return this._normSign();
	};

	BN.prototype._normSign = function _normSign() {
	  // -0 = 0
	  if (this.length === 1 && this.words[0] === 0)
	    this.sign = false;
	  return this;
	};

	BN.prototype.inspect = function inspect() {
	  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	};

	/*

	var zeros = [];
	var groupSizes = [];
	var groupBases = [];

	var s = '';
	var i = -1;
	while (++i < BN.wordSize) {
	  zeros[i] = s;
	  s += '0';
	}
	groupSizes[0] = 0;
	groupSizes[1] = 0;
	groupBases[0] = 0;
	groupBases[1] = 0;
	var base = 2 - 1;
	while (++base < 36 + 1) {
	  var groupSize = 0;
	  var groupBase = 1;
	  // TODO: <=
	  while (groupBase < (1 << BN.wordSize) / base) {
	    groupBase *= base;
	    groupSize += 1;
	  }
	  groupSizes[base] = groupSize;
	  groupBases[base] = groupBase;
	}

	*/

	var zeros = [
	  '',
	  '0',
	  '00',
	  '000',
	  '0000',
	  '00000',
	  '000000',
	  '0000000',
	  '00000000',
	  '000000000',
	  '0000000000',
	  '00000000000',
	  '000000000000',
	  '0000000000000',
	  '00000000000000',
	  '000000000000000',
	  '0000000000000000',
	  '00000000000000000',
	  '000000000000000000',
	  '0000000000000000000',
	  '00000000000000000000',
	  '000000000000000000000',
	  '0000000000000000000000',
	  '00000000000000000000000',
	  '000000000000000000000000',
	  '0000000000000000000000000'
	];

	var groupSizes = [
	  0, 0,
	  25, 16, 12, 11, 10, 9, 8,
	  8, 7, 7, 7, 7, 6, 6,
	  6, 6, 6, 6, 6, 5, 5,
	  5, 5, 5, 5, 5, 5, 5,
	  5, 5, 5, 5, 5, 5, 5
	];

	var groupBases = [
	  0, 0,
	  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	];

	BN.prototype.toString = function toString(base, padding) {
	  base = base || 10;
	  if (base === 16 || base === 'hex') {
	    var out = '';
	    var off = 0;
	    var padding = padding | 0 || 1;
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = this.words[i];
	      var word = (((w << off) | carry) & 0xffffff).toString(16);
	      carry = (w >>> (24 - off)) & 0xffffff;
	      if (carry !== 0 || i !== this.length - 1)
	        out = zeros[6 - word.length] + word + out;
	      else
	        out = word + out;
	      off += 2;
	      if (off >= 26) {
	        off -= 26;
	        i--;
	      }
	    }
	    if (carry !== 0)
	      out = carry.toString(16) + out;
	    while (out.length % padding !== 0)
	      out = '0' + out;
	    if (this.sign)
	      out = '-' + out;
	    return out;
	  } else if (base === (base | 0) && base >= 2 && base <= 36) {
	    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	    var groupSize = groupSizes[base];
	    // var groupBase = Math.pow(base, groupSize);
	    var groupBase = groupBases[base];
	    var out = '';
	    var c = this.clone();
	    c.sign = false;
	    while (c.cmpn(0) !== 0) {
	      var r = c.modn(groupBase).toString(base);
	      c = c.idivn(groupBase);

	      if (c.cmpn(0) !== 0)
	        out = zeros[groupSize - r.length] + r + out;
	      else
	        out = r + out;
	    }
	    if (this.cmpn(0) === 0)
	      out = '0' + out;
	    if (this.sign)
	      out = '-' + out;
	    return out;
	  } else {
	    assert(false, 'Base should be between 2 and 36');
	  }
	};

	BN.prototype.toJSON = function toJSON() {
	  return this.toString(16);
	};

	BN.prototype.toArray = function toArray() {
	  this.strip();
	  var res = new Array(this.byteLength());
	  res[0] = 0;

	  var q = this.clone();
	  for (var i = 0; q.cmpn(0) !== 0; i++) {
	    var b = q.andln(0xff);
	    q.ishrn(8);

	    // Assume big-endian
	    res[res.length - i - 1] = b;
	  }

	  return res;
	};

	/*
	function genCountBits(bits) {
	  var arr = [];

	  for (var i = bits - 1; i >= 0; i--) {
	    var bit = '0x' + (1 << i).toString(16);
	    arr.push('w >= ' + bit + ' ? ' + (i + 1));
	  }

	  return new Function('w', 'return ' + arr.join(' :\n') + ' :\n0;');
	};

	BN.prototype._countBits = genCountBits(26);
	*/

	// Sadly chrome apps could not contain `new Function()` calls
	BN.prototype._countBits = function _countBits(w) {
	  return w >= 0x2000000 ? 26 :
	         w >= 0x1000000 ? 25 :
	         w >= 0x800000 ? 24 :
	         w >= 0x400000 ? 23 :
	         w >= 0x200000 ? 22 :
	         w >= 0x100000 ? 21 :
	         w >= 0x80000 ? 20 :
	         w >= 0x40000 ? 19 :
	         w >= 0x20000 ? 18 :
	         w >= 0x10000 ? 17 :
	         w >= 0x8000 ? 16 :
	         w >= 0x4000 ? 15 :
	         w >= 0x2000 ? 14 :
	         w >= 0x1000 ? 13 :
	         w >= 0x800 ? 12 :
	         w >= 0x400 ? 11 :
	         w >= 0x200 ? 10 :
	         w >= 0x100 ? 9 :
	         w >= 0x80 ? 8 :
	         w >= 0x40 ? 7 :
	         w >= 0x20 ? 6 :
	         w >= 0x10 ? 5 :
	         w >= 0x8 ? 4 :
	         w >= 0x4 ? 3 :
	         w >= 0x2 ? 2 :
	         w >= 0x1 ? 1 :
	         0;
	};

	// Return number of used bits in a BN
	BN.prototype.bitLength = function bitLength() {
	  var hi = 0;
	  var w = this.words[this.length - 1];
	  var hi = this._countBits(w);
	  return (this.length - 1) * 26 + hi;
	};

	BN.prototype.byteLength = function byteLength() {
	  var hi = 0;
	  var w = this.words[this.length - 1];
	  return Math.ceil(this.bitLength() / 8);
	};

	// Return negative clone of `this`
	BN.prototype.neg = function neg() {
	  if (this.cmpn(0) === 0)
	    return this.clone();

	  var r = this.clone();
	  r.sign = !this.sign;
	  return r;
	};

	// Add `num` to `this` in-place
	BN.prototype.iadd = function iadd(num) {
	  // negative + positive
	  if (this.sign && !num.sign) {
	    this.sign = false;
	    var r = this.isub(num);
	    this.sign = !this.sign;
	    return this._normSign();

	  // positive + negative
	  } else if (!this.sign && num.sign) {
	    num.sign = false;
	    var r = this.isub(num);
	    num.sign = true;
	    return r._normSign();
	  }

	  // a.length > b.length
	  var a;
	  var b;
	  if (this.length > num.length) {
	    a = this;
	    b = num;
	  } else {
	    a = num;
	    b = this;
	  }

	  var carry = 0;
	  for (var i = 0; i < b.length; i++) {
	    var r = a.words[i] + b.words[i] + carry;
	    this.words[i] = r & 0x3ffffff;
	    carry = r >>> 26;
	  }
	  for (; carry !== 0 && i < a.length; i++) {
	    var r = a.words[i] + carry;
	    this.words[i] = r & 0x3ffffff;
	    carry = r >>> 26;
	  }

	  this.length = a.length;
	  if (carry !== 0) {
	    this.words[this.length] = carry;
	    this.length++;
	  // Copy the rest of the words
	  } else if (a !== this) {
	    for (; i < a.length; i++)
	      this.words[i] = a.words[i];
	  }

	  return this;
	};

	// Add `num` to `this`
	BN.prototype.add = function add(num) {
	  if (num.sign && !this.sign) {
	    num.sign = false;
	    var res = this.sub(num);
	    num.sign = true;
	    return res;
	  } else if (!num.sign && this.sign) {
	    this.sign = false;
	    var res = num.sub(this);
	    this.sign = true;
	    return res;
	  }

	  if (this.length > num.length)
	    return this.clone().iadd(num);
	  else
	    return num.clone().iadd(this);
	};

	// Subtract `num` from `this` in-place
	BN.prototype.isub = function isub(num) {
	  // this - (-num) = this + num
	  if (num.sign) {
	    num.sign = false;
	    var r = this.iadd(num);
	    num.sign = true;
	    return r._normSign();

	  // -this - num = -(this + num)
	  } else if (this.sign) {
	    this.sign = false;
	    this.iadd(num);
	    this.sign = true;
	    return this._normSign();
	  }

	  // At this point both numbers are positive
	  var cmp = this.cmp(num);

	  // Optimization - zeroify
	  if (cmp === 0) {
	    this.sign = false;
	    this.length = 1;
	    this.words[0] = 0;
	    return this;
	  }

	  // a > b
	  if (cmp > 0) {
	    var a = this;
	    var b = num;
	  } else {
	    var a = num;
	    var b = this;
	  }

	  var carry = 0;
	  for (var i = 0; i < b.length; i++) {
	    var r = a.words[i] - b.words[i] - carry;
	    if (r < 0) {
	      r += 0x4000000;
	      carry = 1;
	    } else {
	      carry = 0;
	    }
	    this.words[i] = r;
	  }
	  for (; carry !== 0 && i < a.length; i++) {
	    var r = a.words[i] - carry;
	    if (r < 0) {
	      r += 0x4000000;
	      carry = 1;
	    } else {
	      carry = 0;
	    }
	    this.words[i] = r;
	  }

	  // Copy rest of the words
	  if (carry === 0 && i < a.length && a !== this)
	    for (; i < a.length; i++)
	      this.words[i] = a.words[i];
	  this.length = Math.max(this.length, i);

	  if (a !== this)
	    this.sign = true;

	  return this.strip();
	};

	// Subtract `num` from `this`
	BN.prototype.sub = function sub(num) {
	  return this.clone().isub(num);
	};

	/*
	// NOTE: This could be potentionally used to generate loop-less multiplications
	function _genCombMulTo(alen, blen) {
	  var len = alen + blen - 1;
	  var src = [
	    'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
	        'mask = 0x3ffffff, shift = 0x4000000;',
	    'out.length = ' + len + ';'
	  ];
	  for (var k = 0; k < len; k++) {
	    var minJ = Math.max(0, k - alen + 1);
	    var maxJ = Math.min(k, blen - 1);

	    for (var j = minJ; j <= maxJ; j++) {
	      var i = k - j;
	      var mul = 'a[' + i + '] * b[' + j + ']';

	      if (j === minJ) {
	        src.push('w = ' + mul + ' + c;');
	        src.push('c = (w / shift) | 0;');
	      } else {
	        src.push('w += ' + mul + ';');
	        src.push('c += (w / shift) | 0;');
	      }
	      src.push('w &= mask;');
	    }
	    src.push('o[' + k + '] = w;');
	  }
	  src.push('if (c !== 0) {',
	           '  o[' + k + '] = c;',
	           '  out.length++;',
	           '}',
	           'return out;');

	  return src.join('\n');
	}
	*/

	BN.prototype._smallMulTo = function _smallMulTo(num, out) {
	  out.sign = num.sign !== this.sign;
	  out.length = this.length + num.length;

	  var carry = 0;
	  for (var k = 0; k < out.length - 1; k++) {
	    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	    // note that ncarry could be >= 0x3ffffff
	    var ncarry = carry >>> 26;
	    var rword = carry & 0x3ffffff;
	    var maxJ = Math.min(k, num.length - 1);
	    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
	      var i = k - j;
	      var a = this.words[i] | 0;
	      var b = num.words[j] | 0;
	      var r = a * b;

	      var lo = r & 0x3ffffff;
	      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	      lo = (lo + rword) | 0;
	      rword = lo & 0x3ffffff;
	      ncarry = (ncarry + (lo >>> 26)) | 0;
	    }
	    out.words[k] = rword;
	    carry = ncarry;
	  }
	  if (carry !== 0) {
	    out.words[k] = carry;
	  } else {
	    out.length--;
	  }

	  return out.strip();
	};

	BN.prototype._bigMulTo = function _bigMulTo(num, out) {
	  out.sign = num.sign !== this.sign;
	  out.length = this.length + num.length;

	  var carry = 0;
	  var hncarry = 0;
	  for (var k = 0; k < out.length - 1; k++) {
	    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	    // note that ncarry could be >= 0x3ffffff
	    var ncarry = hncarry;
	    hncarry = 0;
	    var rword = carry & 0x3ffffff;
	    var maxJ = Math.min(k, num.length - 1);
	    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
	      var i = k - j;
	      var a = this.words[i] | 0;
	      var b = num.words[j] | 0;
	      var r = a * b;

	      var lo = r & 0x3ffffff;
	      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	      lo = (lo + rword) | 0;
	      rword = lo & 0x3ffffff;
	      ncarry = (ncarry + (lo >>> 26)) | 0;

	      hncarry += ncarry >>> 26;
	      ncarry &= 0x3ffffff;
	    }
	    out.words[k] = rword;
	    carry = ncarry;
	    ncarry = hncarry;
	  }
	  if (carry !== 0) {
	    out.words[k] = carry;
	  } else {
	    out.length--;
	  }

	  return out.strip();
	};

	BN.prototype.mulTo = function mulTo(num, out) {
	  var res;
	  if (this.length + num.length < 63)
	    res = this._smallMulTo(num, out);
	  else
	    res = this._bigMulTo(num, out);
	  return res;
	};

	// Multiply `this` by `num`
	BN.prototype.mul = function mul(num) {
	  var out = new BN(null);
	  out.words = new Array(this.length + num.length);
	  return this.mulTo(num, out);
	};

	// In-place Multiplication
	BN.prototype.imul = function imul(num) {
	  if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
	    this.words[0] = 0;
	    this.length = 1;
	    return this;
	  }

	  var tlen = this.length;
	  var nlen = num.length;

	  this.sign = num.sign !== this.sign;
	  this.length = this.length + num.length;
	  this.words[this.length - 1] = 0;

	  var lastCarry = 0;
	  for (var k = this.length - 2; k >= 0; k--) {
	    // Sum all words with the same `i + j = k` and accumulate `carry`,
	    // note that carry could be >= 0x3ffffff
	    var carry = 0;
	    var rword = 0;
	    var maxJ = Math.min(k, nlen - 1);
	    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
	      var i = k - j;
	      var a = this.words[i];
	      var b = num.words[j];
	      var r = a * b;

	      var lo = r & 0x3ffffff;
	      carry += (r / 0x4000000) | 0;
	      lo += rword;
	      rword = lo & 0x3ffffff;
	      carry += lo >>> 26;
	    }
	    this.words[k] = rword;
	    this.words[k + 1] += carry;
	    carry = 0;
	  }

	  // Propagate overflows
	  var carry = 0;
	  for (var i = 1; i < this.length; i++) {
	    var w = this.words[i] + carry;
	    this.words[i] = w & 0x3ffffff;
	    carry = w >>> 26;
	  }

	  return this.strip();
	};

	// `this` * `this`
	BN.prototype.sqr = function sqr() {
	  return this.mul(this);
	};

	// `this` * `this` in-place
	BN.prototype.isqr = function isqr() {
	  return this.mul(this);
	};

	// Shift-left in-place
	BN.prototype.ishln = function ishln(bits) {
	  assert(typeof bits === 'number' && bits >= 0);
	  var r = bits % 26;
	  var s = (bits - r) / 26;
	  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

	  var o = this.clone();
	  if (r !== 0) {
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var newCarry = this.words[i] & carryMask;
	      var c = (this.words[i] - newCarry) << r;
	      this.words[i] = c | carry;
	      carry = newCarry >>> (26 - r);
	    }
	    if (carry) {
	      this.words[i] = carry;
	      this.length++;
	    }
	  }

	  if (s !== 0) {
	    for (var i = this.length - 1; i >= 0; i--)
	      this.words[i + s] = this.words[i];
	    for (var i = 0; i < s; i++)
	      this.words[i] = 0;
	    this.length += s;
	  }

	  return this.strip();
	};

	// Shift-right in-place
	// NOTE: `hint` is a lowest bit before trailing zeroes
	// NOTE: if `extended` is true - { lo: ..., hi: } object will be returned
	BN.prototype.ishrn = function ishrn(bits, hint, extended) {
	  assert(typeof bits === 'number' && bits >= 0);
	  if (hint)
	    hint = (hint - (hint % 26)) / 26;
	  else
	    hint = 0;

	  var r = bits % 26;
	  var s = Math.min((bits - r) / 26, this.length);
	  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	  var maskedWords = extended;

	  hint -= s;
	  hint = Math.max(0, hint);

	  // Extended mode, copy masked part
	  if (maskedWords) {
	    for (var i = 0; i < s; i++)
	      maskedWords.words[i] = this.words[i];
	    maskedWords.length = s;
	  }

	  if (s === 0) {
	    // No-op, we should not move anything at all
	  } else if (this.length > s) {
	    this.length -= s;
	    for (var i = 0; i < this.length; i++)
	      this.words[i] = this.words[i + s];
	  } else {
	    this.words[0] = 0;
	    this.length = 1;
	  }

	  var carry = 0;
	  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= hint); i--) {
	    var word = this.words[i];
	    this.words[i] = (carry << (26 - r)) | (word >>> r);
	    carry = word & mask;
	  }

	  // Push carried bits as a mask
	  if (maskedWords && carry !== 0)
	    maskedWords.words[maskedWords.length++] = carry;

	  if (this.length === 0) {
	    this.words[0] = 0;
	    this.length = 1;
	  }

	  this.strip();
	  if (extended)
	    return { hi: this, lo: maskedWords };

	  return this;
	};

	// Shift-left
	BN.prototype.shln = function shln(bits) {
	  return this.clone().ishln(bits);
	};

	// Shift-right
	BN.prototype.shrn = function shrn(bits) {
	  return this.clone().ishrn(bits);
	};

	// Test if n bit is set
	BN.prototype.testn = function testn(bit) {
	  assert(typeof bit === 'number' && bit >= 0);
	  var r = bit % 26;
	  var s = (bit - r) / 26;
	  var q = 1 << r;

	  // Fast case: bit is much higher than all existing words
	  if (this.length <= s) {
	    return false;
	  }

	  // Check bit and return
	  var w = this.words[s];

	  return !!(w & q);
	};

	// Return only lowers bits of number (in-place)
	BN.prototype.imaskn = function imaskn(bits) {
	  assert(typeof bits === 'number' && bits >= 0);
	  var r = bits % 26;
	  var s = (bits - r) / 26;

	  assert(!this.sign, 'imaskn works only with positive numbers');

	  if (r !== 0)
	    s++;
	  this.length = Math.min(s, this.length);

	  if (r !== 0) {
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    this.words[this.length - 1] &= mask;
	  }

	  return this.strip();
	};

	// Return only lowers bits of number
	BN.prototype.maskn = function maskn(bits) {
	  return this.clone().imaskn(bits);
	};

	// Add plain number `num` to `this`
	BN.prototype.iaddn = function iaddn(num) {
	  assert(typeof num === 'number');
	  if (num < 0)
	    return this.isubn(-num);

	  // Possible sign change
	  if (this.sign) {
	    if (this.length === 1 && this.words[0] < num) {
	      this.words[0] = num - this.words[0];
	      this.sign = false;
	      return this;
	    }

	    this.sign = false;
	    this.isubn(num);
	    this.sign = true;
	    return this;
	  }
	  this.words[0] += num;

	  // Carry
	  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	    this.words[i] -= 0x4000000;
	    if (i === this.length - 1)
	      this.words[i + 1] = 1;
	    else
	      this.words[i + 1]++;
	  }
	  this.length = Math.max(this.length, i + 1);

	  return this;
	};

	// Subtract plain number `num` from `this`
	BN.prototype.isubn = function isubn(num) {
	  assert(typeof num === 'number');
	  if (num < 0)
	    return this.iaddn(-num);

	  if (this.sign) {
	    this.sign = false;
	    this.iaddn(num);
	    this.sign = true;
	    return this;
	  }

	  this.words[0] -= num;

	  // Carry
	  for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	    this.words[i] += 0x4000000;
	    this.words[i + 1] -= 1;
	  }

	  return this.strip();
	};

	BN.prototype.addn = function addn(num) {
	  return this.clone().iaddn(num);
	};

	BN.prototype.subn = function subn(num) {
	  return this.clone().isubn(num);
	};

	BN.prototype.iabs = function iabs() {
	  this.sign = false;

	  return this
	};

	BN.prototype.abs = function abs() {
	  return this.clone().iabs();
	};

	BN.prototype._wordDiv = function _wordDiv(num, mode) {
	  var shift = this.length - num.length;

	  var a = this.clone();
	  var b = num;

	  var q = mode !== 'mod' && new BN(0);
	  var sign = false;

	  // Approximate quotient at each step
	  while (a.length > b.length) {
	    // NOTE: a.length is always >= 2, because of the condition .div()
	    var hi = a.words[a.length - 1] * 0x4000000 + a.words[a.length - 2];
	    var sq = (hi / b.words[b.length - 1]);
	    var sqhi = (sq / 0x4000000) | 0;
	    var sqlo = sq & 0x3ffffff;
	    sq = new BN(null);
	    sq.words = [ sqlo, sqhi ];
	    sq.length = 2;

	    // Collect quotient
	    var shift = (a.length - b.length - 1) * 26;
	    if (q) {
	      var t = sq.shln(shift);
	      if (a.sign)
	        q.isub(t);
	      else
	        q.iadd(t);
	    }

	    sq = sq.mul(b).ishln(shift);
	    if (a.sign)
	      a.iadd(sq)
	    else
	      a.isub(sq);
	  }
	  // At this point a.length <= b.length
	  while (a.ucmp(b) >= 0) {
	    // NOTE: a.length is always >= 2, because of the condition above
	    var hi = a.words[a.length - 1];
	    var sq = new BN((hi / b.words[b.length - 1]) | 0);
	    var shift = (a.length - b.length) * 26;

	    if (q) {
	      var t = sq.shln(shift);
	      if (a.sign)
	        q.isub(t);
	      else
	        q.iadd(t);
	    }

	    sq = sq.mul(b).ishln(shift);

	    if (a.sign)
	      a.iadd(sq);
	    else
	      a.isub(sq);
	  }

	  if (a.sign) {
	    if (q)
	      q.isubn(1);
	    a.iadd(b);
	  }
	  return { div: q ? q : null, mod: a };
	};

	BN.prototype.divmod = function divmod(num, mode) {
	  assert(num.cmpn(0) !== 0);

	  if (this.sign && !num.sign) {
	    var res = this.neg().divmod(num, mode);
	    var div;
	    var mod;
	    if (mode !== 'mod')
	      div = res.div.neg();
	    if (mode !== 'div')
	      mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
	    return {
	      div: div,
	      mod: mod
	    };
	  } else if (!this.sign && num.sign) {
	    var res = this.divmod(num.neg(), mode);
	    var div;
	    if (mode !== 'mod')
	      div = res.div.neg();
	    return { div: div, mod: res.mod };
	  } else if (this.sign && num.sign) {
	    return this.neg().divmod(num.neg(), mode);
	  }

	  // Both numbers are positive at this point

	  // Strip both numbers to approximate shift value
	  if (num.length > this.length || this.cmp(num) < 0)
	    return { div: new BN(0), mod: this };

	  // Very short reduction
	  if (num.length === 1) {
	    if (mode === 'div')
	      return { div: this.divn(num.words[0]), mod: null };
	    else if (mode === 'mod')
	      return { div: null, mod: new BN(this.modn(num.words[0])) };
	    return {
	      div: this.divn(num.words[0]),
	      mod: new BN(this.modn(num.words[0]))
	    };
	  }

	  return this._wordDiv(num, mode);
	};

	// Find `this` / `num`
	BN.prototype.div = function div(num) {
	  return this.divmod(num, 'div').div;
	};

	// Find `this` % `num`
	BN.prototype.mod = function mod(num) {
	  return this.divmod(num, 'mod').mod;
	};

	// Find Round(`this` / `num`)
	BN.prototype.divRound = function divRound(num) {
	  var dm = this.divmod(num);

	  // Fast case - exact division
	  if (dm.mod.cmpn(0) === 0)
	    return dm.div;

	  var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

	  var half = num.shrn(1);
	  var r2 = num.andln(1);
	  var cmp = mod.cmp(half);

	  // Round down
	  if (cmp < 0 || r2 === 1 && cmp === 0)
	    return dm.div;

	  // Round up
	  return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
	};

	BN.prototype.modn = function modn(num) {
	  assert(num <= 0x3ffffff);
	  var p = (1 << 26) % num;

	  var acc = 0;
	  for (var i = this.length - 1; i >= 0; i--)
	    acc = (p * acc + this.words[i]) % num;

	  return acc;
	};

	// In-place division by number
	BN.prototype.idivn = function idivn(num) {
	  assert(num <= 0x3ffffff);

	  var carry = 0;
	  for (var i = this.length - 1; i >= 0; i--) {
	    var w = this.words[i] + carry * 0x4000000;
	    this.words[i] = (w / num) | 0;
	    carry = w % num;
	  }

	  return this.strip();
	};

	BN.prototype.divn = function divn(num) {
	  return this.clone().idivn(num);
	};

	BN.prototype._egcd = function _egcd(x1, p) {
	  assert(!p.sign);
	  assert(p.cmpn(0) !== 0);

	  var a = this;
	  var b = p.clone();

	  if (a.sign)
	    a = a.mod(p);
	  else
	    a = a.clone();

	  var x2 = new BN(0);
	  while (b.isEven())
	    b.ishrn(1);
	  var delta = b.clone();
	  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	    while (a.isEven()) {
	      a.ishrn(1);
	      if (x1.isEven())
	        x1.ishrn(1);
	      else
	        x1.iadd(delta).ishrn(1);
	    }
	    while (b.isEven()) {
	      b.ishrn(1);
	      if (x2.isEven())
	        x2.ishrn(1);
	      else
	        x2.iadd(delta).ishrn(1);
	    }
	    if (a.cmp(b) >= 0) {
	      a.isub(b);
	      x1.isub(x2);
	    } else {
	      b.isub(a);
	      x2.isub(x1);
	    }
	  }
	  if (a.cmpn(1) === 0)
	    return x1;
	  else
	    return x2;
	};

	BN.prototype.gcd = function gcd(num) {
	  if (this.cmpn(0) === 0)
	    return num.clone();
	  if (num.cmpn(0) === 0)
	    return this.clone();

	  var a = this.clone();
	  var b = num.clone();
	  a.sign = false;
	  b.sign = false;

	  // Remove common factor of two
	  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	    a.ishrn(1);
	    b.ishrn(1);
	  }

	  while (a.isEven())
	    a.ishrn(1);

	  do {
	    while (b.isEven())
	      b.ishrn(1);

	    // Swap `a` and `b` to make `a` always bigger than `b`
	    if (a.cmp(b) < 0) {
	      var t = a;
	      a = b;
	      b = t;
	    }
	    a.isub(a.div(b).mul(b));
	  } while (a.cmpn(0) !== 0 && b.cmpn(0) !== 0);
	  if (a.cmpn(0) === 0)
	    return b.ishln(shift);
	  else
	    return a.ishln(shift);
	};

	// Invert number in the field F(num)
	BN.prototype.invm = function invm(num) {
	  return this._egcd(new BN(1), num).mod(num);
	};

	BN.prototype.isEven = function isEven(num) {
	  return (this.words[0] & 1) === 0;
	};

	BN.prototype.isOdd = function isOdd(num) {
	  return (this.words[0] & 1) === 1;
	};

	// And first word and num
	BN.prototype.andln = function andln(num) {
	  return this.words[0] & num;
	};

	// Increment at the bit position in-line
	BN.prototype.bincn = function bincn(bit) {
	  assert(typeof bit === 'number');
	  var r = bit % 26;
	  var s = (bit - r) / 26;
	  var q = 1 << r;

	  // Fast case: bit is much higher than all existing words
	  if (this.length <= s) {
	    for (var i = this.length; i < s + 1; i++)
	      this.words[i] = 0;
	    this.words[s] |= q;
	    this.length = s + 1;
	    return this;
	  }

	  // Add bit and propagate, if needed
	  var carry = q;
	  for (var i = s; carry !== 0 && i < this.length; i++) {
	    var w = this.words[i];
	    w += carry;
	    carry = w >>> 26;
	    w &= 0x3ffffff;
	    this.words[i] = w;
	  }
	  if (carry !== 0) {
	    this.words[i] = carry;
	    this.length++;
	  }
	  return this;
	};

	BN.prototype.cmpn = function cmpn(num) {
	  var sign = num < 0;
	  if (sign)
	    num = -num;

	  if (this.sign && !sign)
	    return -1;
	  else if (!this.sign && sign)
	    return 1;

	  num &= 0x3ffffff;
	  this.strip();

	  var res;
	  if (this.length > 1) {
	    res = 1;
	  } else {
	    var w = this.words[0];
	    res = w === num ? 0 : w < num ? -1 : 1;
	  }
	  if (this.sign)
	    res = -res;
	  return res;
	};

	// Compare two numbers and return:
	// 1 - if `this` > `num`
	// 0 - if `this` == `num`
	// -1 - if `this` < `num`
	BN.prototype.cmp = function cmp(num) {
	  if (this.sign && !num.sign)
	    return -1;
	  else if (!this.sign && num.sign)
	    return 1;

	  var res = this.ucmp(num);
	  if (this.sign)
	    return -res;
	  else
	    return res;
	};

	// Unsigned comparison
	BN.prototype.ucmp = function ucmp(num) {
	  // At this point both numbers have the same sign
	  if (this.length > num.length)
	    return 1;
	  else if (this.length < num.length)
	    return -1;

	  var res = 0;
	  for (var i = this.length - 1; i >= 0; i--) {
	    var a = this.words[i];
	    var b = num.words[i];

	    if (a === b)
	      continue;
	    if (a < b)
	      res = -1;
	    else if (a > b)
	      res = 1;
	    break;
	  }
	  return res;
	};

	//
	// A reduce context, could be using montgomery or something better, depending
	// on the `m` itself.
	//
	BN.red = function red(num) {
	  return new Red(num);
	};

	BN.prototype.toRed = function toRed(ctx) {
	  assert(!this.red, 'Already a number in reduction context');
	  assert(!this.sign, 'red works only with positives');
	  return ctx.convertTo(this)._forceRed(ctx);
	};

	BN.prototype.fromRed = function fromRed() {
	  assert(this.red, 'fromRed works only with numbers in reduction context');
	  return this.red.convertFrom(this);
	};

	BN.prototype._forceRed = function _forceRed(ctx) {
	  this.red = ctx;
	  return this;
	};

	BN.prototype.forceRed = function forceRed(ctx) {
	  assert(!this.red, 'Already a number in reduction context');
	  return this._forceRed(ctx);
	};

	BN.prototype.redAdd = function redAdd(num) {
	  assert(this.red, 'redAdd works only with red numbers');
	  return this.red.add(this, num);
	};

	BN.prototype.redIAdd = function redIAdd(num) {
	  assert(this.red, 'redIAdd works only with red numbers');
	  return this.red.iadd(this, num);
	};

	BN.prototype.redSub = function redSub(num) {
	  assert(this.red, 'redSub works only with red numbers');
	  return this.red.sub(this, num);
	};

	BN.prototype.redISub = function redISub(num) {
	  assert(this.red, 'redISub works only with red numbers');
	  return this.red.isub(this, num);
	};

	BN.prototype.redShl = function redShl(num) {
	  assert(this.red, 'redShl works only with red numbers');
	  return this.red.shl(this, num);
	};

	BN.prototype.redMul = function redMul(num) {
	  assert(this.red, 'redMul works only with red numbers');
	  this.red._verify2(this, num);
	  return this.red.mul(this, num);
	};

	BN.prototype.redIMul = function redIMul(num) {
	  assert(this.red, 'redMul works only with red numbers');
	  this.red._verify2(this, num);
	  return this.red.imul(this, num);
	};

	BN.prototype.redSqr = function redSqr() {
	  assert(this.red, 'redSqr works only with red numbers');
	  this.red._verify1(this);
	  return this.red.sqr(this);
	};

	BN.prototype.redISqr = function redISqr() {
	  assert(this.red, 'redISqr works only with red numbers');
	  this.red._verify1(this);
	  return this.red.isqr(this);
	};

	// Square root over p
	BN.prototype.redSqrt = function redSqrt() {
	  assert(this.red, 'redSqrt works only with red numbers');
	  this.red._verify1(this);
	  return this.red.sqrt(this);
	};

	BN.prototype.redInvm = function redInvm() {
	  assert(this.red, 'redInvm works only with red numbers');
	  this.red._verify1(this);
	  return this.red.invm(this);
	};

	// Return negative clone of `this` % `red modulo`
	BN.prototype.redNeg = function redNeg() {
	  assert(this.red, 'redNeg works only with red numbers');
	  this.red._verify1(this);
	  return this.red.neg(this);
	};

	BN.prototype.redPow = function redPow(num) {
	  assert(this.red && !num.red, 'redPow(normalNum)');
	  this.red._verify1(this);
	  return this.red.pow(this, num);
	};

	// Prime numbers with efficient reduction
	var primes = {
	  k256: null,
	  p224: null,
	  p192: null,
	  p25519: null
	};

	// Pseudo-Mersenne prime
	function MPrime(name, p) {
	  // P = 2 ^ N - K
	  this.name = name;
	  this.p = new BN(p, 16);
	  this.n = this.p.bitLength();
	  this.k = new BN(1).ishln(this.n).isub(this.p);

	  this.tmp = this._tmp();
	}

	MPrime.prototype._tmp = function _tmp() {
	  var tmp = new BN(null);
	  tmp.words = new Array(Math.ceil(this.n / 13));
	  return tmp;
	};

	MPrime.prototype.ireduce = function ireduce(num) {
	  // Assumes that `num` is less than `P^2`
	  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	  var r = num;
	  var rlen;

	  do {
	    var pair = r.ishrn(this.n, 0, this.tmp);
	    r = this.imulK(pair.hi);
	    r = r.iadd(pair.lo);
	    rlen = r.bitLength();
	  } while (rlen > this.n);

	  var cmp = rlen < this.n ? -1 : r.cmp(this.p);
	  if (cmp === 0) {
	    r.words[0] = 0;
	    r.length = 1;
	  } else if (cmp > 0) {
	    r.isub(this.p);
	  } else {
	    r.strip();
	  }

	  return r;
	};

	MPrime.prototype.imulK = function imulK(num) {
	  return num.imul(this.k);
	};

	function K256() {
	  MPrime.call(
	    this,
	    'k256',
	    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	}
	inherits(K256, MPrime);

	K256.prototype.imulK = function imulK(num) {
	  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	  num.words[num.length] = 0;
	  num.words[num.length + 1] = 0;
	  num.length += 2;

	  var uhi = 0;
	  var hi = 0;
	  var lo = 0;
	  for (var i = 0; i < num.length; i++) {
	    var w = num.words[i];
	    hi += w * 0x40;
	    lo += w * 0x3d1;
	    hi += (lo / 0x4000000) | 0;
	    uhi += (hi / 0x4000000) | 0;
	    hi &= 0x3ffffff;
	    lo &= 0x3ffffff;

	    num.words[i] = lo;

	    lo = hi;
	    hi = uhi;
	    uhi = 0;
	  }

	  // Fast length reduction
	  if (num.words[num.length - 1] === 0)
	    num.length--;
	  if (num.words[num.length - 1] === 0)
	    num.length--;
	  return num;
	};

	function P224() {
	  MPrime.call(
	    this,
	    'p224',
	    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	}
	inherits(P224, MPrime);

	function P192() {
	  MPrime.call(
	    this,
	    'p192',
	    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	}
	inherits(P192, MPrime);

	function P25519() {
	  // 2 ^ 255 - 19
	  MPrime.call(
	    this,
	    '25519',
	    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	}
	inherits(P25519, MPrime);

	P25519.prototype.imulK = function imulK(num) {
	  // K = 0x13
	  var carry = 0;
	  for (var i = 0; i < num.length; i++) {
	    var hi = num.words[i] * 0x13 + carry;
	    var lo = hi & 0x3ffffff;
	    hi >>>= 26;

	    num.words[i] = lo;
	    carry = hi;
	  }
	  if (carry !== 0)
	    num.words[num.length++] = carry;
	  return num;
	};

	// Exported mostly for testing purposes, use plain name instead
	BN._prime = function prime(name) {
	  // Cached version of prime
	  if (primes[name])
	    return primes[name];

	  var prime;
	  if (name === 'k256')
	    prime = new K256();
	  else if (name === 'p224')
	    prime = new P224();
	  else if (name === 'p192')
	    prime = new P192();
	  else if (name === 'p25519')
	    prime = new P25519();
	  else
	    throw new Error('Unknown prime ' + name);
	  primes[name] = prime;

	  return prime;
	}

	//
	// Base reduction engine
	//
	function Red(m) {
	  if (typeof m === 'string') {
	    var prime = BN._prime(m);
	    this.m = prime.p;
	    this.prime = prime;
	  } else {
	    this.m = m;
	    this.prime = null;
	  }
	}

	Red.prototype._verify1 = function _verify1(a) {
	  assert(!a.sign, 'red works only with positives');
	  assert(a.red, 'red works only with red numbers');
	};

	Red.prototype._verify2 = function _verify2(a, b) {
	  assert(!a.sign && !b.sign, 'red works only with positives');
	  assert(a.red && a.red === b.red,
	         'red works only with red numbers');
	};

	Red.prototype.imod = function imod(a) {
	  if (this.prime)
	    return this.prime.ireduce(a)._forceRed(this);
	  return a.mod(this.m)._forceRed(this);
	};

	Red.prototype.neg = function neg(a) {
	  var r = a.clone();
	  r.sign = !r.sign;
	  return r.iadd(this.m)._forceRed(this);
	};

	Red.prototype.add = function add(a, b) {
	  this._verify2(a, b);

	  var res = a.add(b);
	  if (res.cmp(this.m) >= 0)
	    res.isub(this.m);
	  return res._forceRed(this);
	};

	Red.prototype.iadd = function iadd(a, b) {
	  this._verify2(a, b);

	  var res = a.iadd(b);
	  if (res.cmp(this.m) >= 0)
	    res.isub(this.m);
	  return res;
	};

	Red.prototype.sub = function sub(a, b) {
	  this._verify2(a, b);

	  var res = a.sub(b);
	  if (res.cmpn(0) < 0)
	    res.iadd(this.m);
	  return res._forceRed(this);
	};

	Red.prototype.isub = function isub(a, b) {
	  this._verify2(a, b);

	  var res = a.isub(b);
	  if (res.cmpn(0) < 0)
	    res.iadd(this.m);
	  return res;
	};

	Red.prototype.shl = function shl(a, num) {
	  this._verify1(a);
	  return this.imod(a.shln(num));
	};

	Red.prototype.imul = function imul(a, b) {
	  this._verify2(a, b);
	  return this.imod(a.imul(b));
	};

	Red.prototype.mul = function mul(a, b) {
	  this._verify2(a, b);
	  return this.imod(a.mul(b));
	};

	Red.prototype.isqr = function isqr(a) {
	  return this.imul(a, a);
	};

	Red.prototype.sqr = function sqr(a) {
	  return this.mul(a, a);
	};

	Red.prototype.sqrt = function sqrt(a) {
	  if (a.cmpn(0) === 0)
	    return a.clone();

	  var mod3 = this.m.andln(3);
	  assert(mod3 % 2 === 1);

	  // Fast case
	  if (mod3 === 3) {
	    var pow = this.m.add(new BN(1)).ishrn(2);
	    var r = this.pow(a, pow);
	    return r;
	  }

	  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	  //
	  // Find Q and S, that Q * 2 ^ S = (P - 1)
	  var q = this.m.subn(1);
	  var s = 0;
	  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
	    s++;
	    q.ishrn(1);
	  }
	  assert(q.cmpn(0) !== 0);

	  var one = new BN(1).toRed(this);
	  var nOne = one.redNeg();

	  // Find quadratic non-residue
	  // NOTE: Max is such because of generalized Riemann hypothesis.
	  var lpow = this.m.subn(1).ishrn(1);
	  var z = this.m.bitLength();
	  z = new BN(2 * z * z).toRed(this);
	  while (this.pow(z, lpow).cmp(nOne) !== 0)
	    z.redIAdd(nOne);

	  var c = this.pow(z, q);
	  var r = this.pow(a, q.addn(1).ishrn(1));
	  var t = this.pow(a, q);
	  var m = s;
	  while (t.cmp(one) !== 0) {
	    var tmp = t;
	    for (var i = 0; tmp.cmp(one) !== 0; i++)
	      tmp = tmp.redSqr();
	    assert(i < m);
	    var b = this.pow(c, new BN(1).ishln(m - i - 1));

	    r = r.redMul(b);
	    c = b.redSqr();
	    t = t.redMul(c);
	    m = i;
	  }

	  return r;
	};

	Red.prototype.invm = function invm(a) {
	  var inv = a._egcd(new BN(1), this.m);
	  if (inv.sign) {
	    inv.sign = false;
	    return this.imod(inv).redNeg();
	  } else {
	    return this.imod(inv);
	  }
	};

	Red.prototype.pow = function pow(a, num) {
	  var w = [];
	  var q = num.clone();
	  while (q.cmpn(0) !== 0) {
	    w.push(q.andln(1));
	    q.ishrn(1);
	  }

	  // Skip leading zeroes
	  var res = a;
	  for (var i = 0; i < w.length; i++, res = this.sqr(res))
	    if (w[i] !== 0)
	      break;

	  if (++i < w.length) {
	    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
	      if (w[i] === 0)
	        continue;
	      res = this.mul(res, q);
	    }
	  }

	  return res;
	};

	Red.prototype.convertTo = function convertTo(num) {
	  return num.clone();
	};

	Red.prototype.convertFrom = function convertFrom(num) {
	  var res = num.clone();
	  res.red = null;
	  return res;
	};

	//
	// Montgomery method engine
	//

	BN.mont = function mont(num) {
	  return new Mont(num);
	};

	function Mont(m) {
	  Red.call(this, m);

	  this.shift = this.m.bitLength();
	  if (this.shift % 26 !== 0)
	    this.shift += 26 - (this.shift % 26);
	  this.r = new BN(1).ishln(this.shift);
	  this.r2 = this.imod(this.r.sqr());
	  this.rinv = this.r.invm(this.m);

	  // TODO(indutny): simplify it
	  this.minv = this.rinv.mul(this.r)
	                       .sub(new BN(1))
	                       .div(this.m)
	                       .neg()
	                       .mod(this.r);
	}
	inherits(Mont, Red);

	Mont.prototype.convertTo = function convertTo(num) {
	  return this.imod(num.shln(this.shift));
	};

	Mont.prototype.convertFrom = function convertFrom(num) {
	  var r = this.imod(num.mul(this.rinv));
	  r.red = null;
	  return r;
	};

	Mont.prototype.imul = function imul(a, b) {
	  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
	    a.words[0] = 0;
	    a.length = 1;
	    return a;
	  }

	  var t = a.imul(b);
	  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	  var u = t.isub(c).ishrn(this.shift);
	  var res = u;
	  if (u.cmp(this.m) >= 0)
	    res = u.isub(this.m);
	  else if (u.cmpn(0) < 0)
	    res = u.iadd(this.m);

	  return res._forceRed(this);
	};

	Mont.prototype.mul = function mul(a, b) {
	  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
	    return new BN(0)._forceRed(this);

	  var t = a.mul(b);
	  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	  var u = t.isub(c).ishrn(this.shift);
	  var res = u;
	  if (u.cmp(this.m) >= 0)
	    res = u.isub(this.m);
	  else if (u.cmpn(0) < 0)
	    res = u.iadd(this.m);

	  return res._forceRed(this);
	};

	Mont.prototype.invm = function invm(a) {
	  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	  var res = this.imod(a.invm(this.m).mul(this.r2));
	  return res._forceRed(this);
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var elliptic = exports;

	elliptic.version = __webpack_require__(118).version;
	elliptic.utils = __webpack_require__(97);
	elliptic.rand = __webpack_require__(98);
	elliptic.hmacDRBG = __webpack_require__(96);
	elliptic.curve = __webpack_require__(36);
	elliptic.curves = __webpack_require__(92);

	// Protocols
	elliptic.ec = __webpack_require__(93);


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var bufferUtil = __webpack_require__(3);
	var assert = __webpack_require__(8);

	var BufferWriter = function BufferWriter(obj) {
	  if (!(this instanceof BufferWriter))
	    return new BufferWriter(obj);
	  if (obj)
	    this.set(obj);
	  else
	    this.bufs = [];
	};

	BufferWriter.prototype.set = function(obj) {
	  this.bufs = obj.bufs || this.bufs || [];
	  return this;
	};

	BufferWriter.prototype.toBuffer = function() {
	  return this.concat();
	};

	BufferWriter.prototype.concat = function() {
	  return Buffer.concat(this.bufs);
	};

	BufferWriter.prototype.write = function(buf) {
	  assert(bufferUtil.isBuffer(buf));
	  this.bufs.push(buf);
	  return this;
	};

	BufferWriter.prototype.writeReverse = function(buf) {
	  assert(bufferUtil.isBuffer(buf));
	  this.bufs.push(bufferUtil.reverse(buf));
	  return this;
	};

	BufferWriter.prototype.writeUInt8 = function(n) {
	  var buf = new Buffer(1);
	  buf.writeUInt8(n, 0);
	  this.write(buf);
	  return this;
	};

	BufferWriter.prototype.writeUInt16BE = function(n) {
	  var buf = new Buffer(2);
	  buf.writeUInt16BE(n, 0);
	  this.write(buf);
	  return this;
	};

	BufferWriter.prototype.writeUInt16LE = function(n) {
	  var buf = new Buffer(2);
	  buf.writeUInt16LE(n, 0);
	  this.write(buf);
	  return this;
	};

	BufferWriter.prototype.writeUInt32BE = function(n) {
	  var buf = new Buffer(4);
	  buf.writeUInt32BE(n, 0);
	  this.write(buf);
	  return this;
	};

	BufferWriter.prototype.writeInt32LE = function(n) {
	  var buf = new Buffer(4);
	  buf.writeInt32LE(n, 0);
	  this.write(buf);
	  return this;
	};

	BufferWriter.prototype.writeUInt32LE = function(n) {
	  var buf = new Buffer(4);
	  buf.writeUInt32LE(n, 0);
	  this.write(buf);
	  return this;
	};

	BufferWriter.prototype.writeUInt64BEBN = function(bn) {
	  var buf = bn.toBuffer({size: 8});
	  this.write(buf);
	  return this;
	};

	BufferWriter.prototype.writeUInt64LEBN = function(bn) {
	  var buf = bn.toBuffer({size: 8});
	  var reversebuf = new Buffer(Array.apply(new Array(), buf).reverse());
	  this.write(reversebuf);
	  return this;
	};

	BufferWriter.prototype.writeVarintNum = function(n) {
	  var buf = BufferWriter.varintBufNum(n);
	  this.write(buf);
	  return this;
	};

	BufferWriter.prototype.writeVarintBN = function(bn) {
	  var buf = BufferWriter.varintBufBN(bn);
	  this.write(buf);
	  return this;
	};

	BufferWriter.varintBufNum = function(n) {
	  var buf = undefined;
	  if (n < 253) {
	    buf = new Buffer(1);
	    buf.writeUInt8(n, 0);
	  } else if (n < 0x10000) {
	    buf = new Buffer(1 + 2);
	    buf.writeUInt8(253, 0);
	    buf.writeUInt16LE(n, 1);
	  } else if (n < 0x100000000) {
	    buf = new Buffer(1 + 4);
	    buf.writeUInt8(254, 0);
	    buf.writeUInt32LE(n, 1);
	  } else {
	    buf = new Buffer(1 + 8);
	    buf.writeUInt8(255, 0);
	    buf.writeInt32LE(n & -1, 1);
	    buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);
	  }
	  return buf;
	};

	BufferWriter.varintBufBN = function(bn) {
	  var buf = undefined;
	  var n = bn.toNumber();
	  if (n < 253) {
	    buf = new Buffer(1);
	    buf.writeUInt8(n, 0);
	  } else if (n < 0x10000) {
	    buf = new Buffer(1 + 2);
	    buf.writeUInt8(253, 0);
	    buf.writeUInt16LE(n, 1);
	  } else if (n < 0x100000000) {
	    buf = new Buffer(1 + 4);
	    buf.writeUInt8(254, 0);
	    buf.writeUInt32LE(n, 1);
	  } else {
	    var bw = new BufferWriter();
	    bw.writeUInt8(255);
	    bw.writeUInt64LEBN(bn);
	    var buf = bw.concat();
	  }
	  return buf;
	};

	module.exports = BufferWriter;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var Address = __webpack_require__(17);
	var BN = __webpack_require__(6);
	var Point = __webpack_require__(23);
	var Hash = __webpack_require__(7);
	var JSUtil = __webpack_require__(4);
	var Network = __webpack_require__(19);
	var _ = __webpack_require__(2);
	var $ = __webpack_require__(5);

	/**
	 * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.
	 *
	 * There are two internal properties, `network` and `compressed`, that deal with importing
	 * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}
	 *
	 * @example
	 * ```javascript
	 * // instantiate from a private key
	 * var key = PublicKey(privateKey, true);
	 *
	 * // export to as a DER hex encoded string
	 * var exported = key.toString();
	 *
	 * // import the public key
	 * var imported = PublicKey.fromString(exported);
	 * ```
	 *
	 * @param {String} data - The encoded data in various formats
	 * @param {Object} extra - additional options
	 * @param {Network=} extra.network - Which network should the address for this public key be for
	 * @param {String=} extra.compressed - If the public key is compressed
	 * @returns {PublicKey} A new valid instance of an PublicKey
	 * @constructor
	 */
	var PublicKey = function PublicKey(data, extra) {

	  if (!(this instanceof PublicKey)) {
	    return new PublicKey(data, extra);
	  }

	  $.checkArgument(data, new TypeError('First argument is required, please include public key data.'));

	  if (data instanceof PublicKey) {
	    // Return copy, but as it's an immutable object, return same argument
	    return data;
	  }
	  extra = extra || {};

	  var info = this._classifyArgs(data, extra);

	  // validation
	  info.point.validate();

	  JSUtil.defineImmutable(this, {
	    point: info.point,
	    compressed: info.compressed,
	    network: info.network || Network.defaultNetwork
	  });

	  return this;
	};

	/**
	 * Internal function to differentiate between arguments passed to the constructor
	 * @param {*} data
	 * @param {Object} extra
	 */
	PublicKey.prototype._classifyArgs = function(data, extra) {
	  /* jshint maxcomplexity: 10 */
	  var info = {
	    compressed: _.isUndefined(extra.compressed) || extra.compressed,
	    network: _.isUndefined(extra.network) ? undefined : Network.get(extra.network)
	  };

	  // detect type of data
	  if (data instanceof Point) {
	    info.point = data;
	  } else if (PublicKey._isJSON(data)) {
	    info = PublicKey._transformJSON(data);
	  } else if (typeof(data) === 'string') {
	    info = PublicKey._transformDER(new Buffer(data, 'hex'));
	  } else if (PublicKey._isBuffer(data)) {
	    info = PublicKey._transformDER(data);
	  } else if (PublicKey._isPrivateKey(data)) {
	    info = PublicKey._transformPrivateKey(data);
	  } else {
	    throw new TypeError('First argument is an unrecognized data format.');
	  }
	  return info;
	};

	/**
	 * Internal function to detect if an object is a {@link PrivateKey}
	 *
	 * @param {*} param - object to test
	 * @returns {boolean}
	 * @private
	 */
	PublicKey._isPrivateKey = function(param) {
	  var PrivateKey = __webpack_require__(35);
	  return param instanceof PrivateKey;
	};

	/**
	 * Internal function to detect if an object is a Buffer
	 *
	 * @param {*} param - object to test
	 * @returns {boolean}
	 * @private
	 */
	PublicKey._isBuffer = function(param) {
	  return (param instanceof Buffer) || (param instanceof Uint8Array);
	};

	/**
	 * Internal function to detect if a param is a JSON string or plain object
	 *
	 * @param {*} param - value to test
	 * @returns {boolean}
	 * @private
	 */
	PublicKey._isJSON = function(json) {
	  return !!(JSUtil.isValidJSON(json) || (json.x && json.y));
	};

	/**
	 * Internal function to transform a private key into a public key point
	 *
	 * @param {PrivateKey} privkey - An instance of PrivateKey
	 * @returns {Object} An object with keys: point and compressed
	 * @private
	 */
	PublicKey._transformPrivateKey = function(privkey) {
	  $.checkArgument(PublicKey._isPrivateKey(privkey),
	    new TypeError('Must be an instance of PrivateKey'));
	  var info = {};
	  info.point = Point.getG().mul(privkey.bn);
	  info.compressed = privkey.compressed;
	  info.network = privkey.network;
	  return info;
	};

	/**
	 * Internal function to transform DER into a public key point
	 *
	 * @param {Buffer} buf - An hex encoded buffer
	 * @param {bool} [strict] - if set to false, will loosen some conditions
	 * @returns {Object} An object with keys: point and compressed
	 * @private
	 */
	PublicKey._transformDER = function(buf, strict) {
	  /* jshint maxstatements: 30 */
	  /* jshint maxcomplexity: 12 */
	  $.checkArgument(PublicKey._isBuffer(buf), new TypeError('Must be a hex buffer of DER encoded public key'));
	  var info = {};

	  strict = _.isUndefined(strict) ? true : strict;

	  var x;
	  var y;
	  var xbuf;
	  var ybuf;

	  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {
	    xbuf = buf.slice(1, 33);
	    ybuf = buf.slice(33, 65);
	    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {
	      throw new TypeError('Length of x and y must be 32 bytes');
	    }
	    x = BN(xbuf);
	    y = BN(ybuf);
	    info.point = new Point(x, y);
	    info.compressed = false;
	  } else if (buf[0] === 0x03) {
	    xbuf = buf.slice(1);
	    x = BN(xbuf);
	    info = PublicKey._transformX(true, x);
	    info.compressed = true;
	  } else if (buf[0] === 0x02) {
	    xbuf = buf.slice(1);
	    x = BN(xbuf);
	    info = PublicKey._transformX(false, x);
	    info.compressed = true;
	  } else {
	    throw new TypeError('Invalid DER format public key');
	  }
	  return info;
	};

	/**
	 * Internal function to transform X into a public key point
	 *
	 * @param {Boolean} odd - If the point is above or below the x axis
	 * @param {Point} x - The x point
	 * @returns {Object} An object with keys: point and compressed
	 * @private
	 */
	PublicKey._transformX = function(odd, x) {
	  $.checkArgument(typeof odd === 'boolean',
	    new TypeError('Must specify whether y is odd or not (true or false)'));
	  var info = {};
	  info.point = Point.fromX(odd, x);
	  return info;
	};

	/**
	 * Instantiate a PublicKey from JSON
	 *
	 * @param {String} json - A JSON string
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromJSON = function(json) {
	  $.checkArgument(PublicKey._isJSON(json),
	    new TypeError('Must be a valid JSON string or plain object'));
	  return new PublicKey(json);
	};

	/**
	 * Internal function to transform a JSON into a public key point
	 *
	 * @param {Buffer} buf - a JSON string or plain object
	 * @returns {Object} An object with keys: point and compressed
	 * @private
	 */
	PublicKey._transformJSON = function(json) {
	  if (JSUtil.isValidJSON(json)) {
	    json = JSON.parse(json);
	  }
	  var x = BN(json.x, 'hex');
	  var y = BN(json.y, 'hex');
	  var point = new Point(x, y);
	  return new PublicKey(point, {
	    compressed: json.compressed
	  });
	};

	/**
	 * Instantiate a PublicKey from a PrivateKey
	 *
	 * @param {PrivateKey} privkey - An instance of PrivateKey
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromPrivateKey = function(privkey) {
	  $.checkArgument(PublicKey._isPrivateKey(privkey), new TypeError('Must be an instance of PrivateKey'));
	  var info = PublicKey._transformPrivateKey(privkey);
	  return new PublicKey(info.point, {
	    compressed: info.compressed,
	    network: info.network
	  });
	};

	/**
	 * Instantiate a PublicKey from a Buffer
	 * @param {Buffer} buf - A DER hex buffer
	 * @param {bool} [strict] - if set to false, will loosen some conditions
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) {
	  $.checkArgument(PublicKey._isBuffer(buf),
	    new TypeError('Must be a hex buffer of DER encoded public key'));
	  var info = PublicKey._transformDER(buf, strict);
	  return new PublicKey(info.point, {
	    compressed: info.compressed
	  });
	};

	/**
	 * Instantiate a PublicKey from a Point
	 *
	 * @param {Point} point - A Point instance
	 * @param {boolean=} compressed - whether to store this public key as compressed format
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromPoint = function(point, compressed) {
	  $.checkArgument(point instanceof Point,
	    new TypeError('First argument must be an instance of Point.'));
	  return new PublicKey(point, {
	    compressed: compressed
	  });
	};

	/**
	 * Instantiate a PublicKey from a DER hex encoded string
	 *
	 * @param {String} str - A DER hex string
	 * @param {String} [encoding] - The type of string encoding
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromString = function(str, encoding) {
	  var buf = new Buffer(str, encoding || 'hex');
	  var info = PublicKey._transformDER(buf);
	  return new PublicKey(info.point, {
	    compressed: info.compressed
	  });
	};

	/**
	 * Instantiate a PublicKey from an X Point
	 *
	 * @param {Boolean} odd - If the point is above or below the x axis
	 * @param {Point} x - The x point
	 * @returns {PublicKey} A new valid instance of PublicKey
	 */
	PublicKey.fromX = function(odd, x) {
	  var info = PublicKey._transformX(odd, x);
	  return new PublicKey(info.point, {
	    compressed: info.compressed
	  });
	};

	/**
	 * Check if there would be any errors when initializing a PublicKey
	 *
	 * @param {String} data - The encoded data in various formats
	 * @param {String} [compressed] - If the public key is compressed
	 * @returns {null|Error} An error if exists
	 */
	PublicKey.getValidationError = function(data) {
	  var error;
	  try {
	    /* jshint nonew: false */
	    new PublicKey(data);
	  } catch (e) {
	    error = e;
	  }
	  return error;
	};

	/**
	 * Check if the parameters are valid
	 *
	 * @param {String} data - The encoded data in various formats
	 * @param {String} [compressed] - If the public key is compressed
	 * @returns {Boolean} If the public key would be valid
	 */
	PublicKey.isValid = function(data) {
	  return !PublicKey.getValidationError(data);
	};

	/**
	 * @returns {Object} A plain object of the PublicKey
	 */
	PublicKey.prototype.toObject = function toObject() {
	  return {
	    x: this.point.getX().toString('hex'),
	    y: this.point.getY().toString('hex'),
	    compressed: this.compressed
	  };
	};

	PublicKey.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	/**
	 * Will output the PublicKey to a DER Buffer
	 *
	 * @returns {Buffer} A DER hex encoded buffer
	 */
	PublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {
	  var x = this.point.getX();
	  var y = this.point.getY();

	  var xbuf = x.toBuffer({
	    size: 32
	  });
	  var ybuf = y.toBuffer({
	    size: 32
	  });

	  var prefix;
	  if (!this.compressed) {
	    prefix = new Buffer([0x04]);
	    return Buffer.concat([prefix, xbuf, ybuf]);
	  } else {
	    var odd = ybuf[ybuf.length - 1] % 2;
	    if (odd) {
	      prefix = new Buffer([0x03]);
	    } else {
	      prefix = new Buffer([0x02]);
	    }
	    return Buffer.concat([prefix, xbuf]);
	  }
	};

	/**
	 * Will return a sha256 + ripemd160 hash of the serialized public key
	 * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141
	 * @returns {Buffer}
	 */
	PublicKey.prototype._getID = function _getID() {
	  return Hash.sha256ripemd160(this.toBuffer());
	};

	/**
	 * Will return an address for the public key
	 *
	 * @returns {Address} An address generated from the public key
	 */
	PublicKey.prototype.toAddress = function(network) {
	  return Address.fromPublicKey(this, network || this.network);
	};

	/**
	 * Will output the PublicKey to a DER encoded hex string
	 *
	 * @returns {String} A DER hex encoded string
	 */
	PublicKey.prototype.toString = function() {
	  return this.toDER().toString('hex');
	};

	/**
	 * Will return a string formatted for the console
	 *
	 * @returns {String} Public key
	 */
	PublicKey.prototype.inspect = function() {
	  return '<PublicKey: ' + this.toString() +
	    (this.compressed ? '' : ', uncompressed') + '>';
	};


	module.exports = PublicKey;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var BN = __webpack_require__(6);
	var _ = __webpack_require__(2);
	var $ = __webpack_require__(5);
	var BufferUtil = __webpack_require__(3);

	var Signature = function Signature(r, s) {
	  if (!(this instanceof Signature)) {
	    return new Signature(r, s);
	  }
	  if (r instanceof BN) {
	    this.set({
	      r: r,
	      s: s
	    });
	  } else if (r) {
	    var obj = r;
	    this.set(obj);
	  }
	};

	/* jshint maxcomplexity: 7 */
	Signature.prototype.set = function(obj) {
	  this.r = obj.r || this.r || undefined;
	  this.s = obj.s || this.s || undefined;
	  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]
	  this.compressed = typeof obj.compressed !== 'undefined' ?
	    obj.compressed : this.compressed; //whether the recovered pubkey is compressed
	  return this;
	};

	Signature.fromCompact = function(buf) {
	  var sig = new Signature();
	  //TODO: handle uncompressed pubkeys
	  var compressed = true;
	  var i = buf.slice(0, 1)[0] - 27 - 4;
	  var b2 = buf.slice(1, 33);
	  var b3 = buf.slice(33, 65);

	  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));
	  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));
	  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));

	  sig.compressed = compressed;
	  sig.i = i;
	  sig.r = BN.fromBuffer(b2);
	  sig.s = BN.fromBuffer(b3);

	  return sig;
	};

	Signature.fromDER = function(buf, strict) {
	  var obj = Signature.parseDER(buf, strict);
	  var sig = new Signature();

	  sig.r = obj.r;
	  sig.s = obj.s;

	  return sig;
	};

	// The format used in a tx
	Signature.fromTxFormat = function(buf) {
	  var nhashtype = buf.readUInt8(buf.length - 1);
	  var derbuf = buf.slice(0, buf.length - 1);
	  var sig = new Signature.fromDER(derbuf, false);
	  sig.nhashtype = nhashtype;
	  return sig;
	};

	Signature.fromString = function(str) {
	  var buf = new Buffer(str, 'hex');
	  return Signature.fromDER(buf);
	};


	/**
	 * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.
	 */
	Signature.parseDER = function(buf, strict) {
	  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));
	  if (_.isUndefined(strict)) {
	    strict = true;
	  }

	  var header = buf[0];
	  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));

	  var length = buf[1];
	  var buflength = buf.slice(2).length;
	  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));

	  length = length < buflength ? length : buflength;

	  var rheader = buf[2 + 0];
	  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));

	  var rlength = buf[2 + 1];
	  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);
	  var r = BN.fromBuffer(rbuf);
	  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;
	  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));

	  var sheader = buf[2 + 2 + rlength + 0];
	  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));

	  var slength = buf[2 + 2 + rlength + 1];
	  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);
	  var s = BN.fromBuffer(sbuf);
	  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;
	  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));

	  var sumlength = 2 + 2 + rlength + 2 + slength;
	  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));

	  var obj = {
	    header: header,
	    length: length,
	    rheader: rheader,
	    rlength: rlength,
	    rneg: rneg,
	    rbuf: rbuf,
	    r: r,
	    sheader: sheader,
	    slength: slength,
	    sneg: sneg,
	    sbuf: sbuf,
	    s: s
	  };

	  return obj;
	};


	Signature.prototype.toCompact = function(i, compressed) {
	  i = typeof i === 'number' ? i : this.i;
	  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;

	  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {
	    throw new Error('i must be equal to 0, 1, 2, or 3');
	  }

	  var val = i + 27 + 4;
	  if (compressed === false)
	    val = val - 4;
	  var b1 = new Buffer([val]);
	  var b2 = this.r.toBuffer({
	    size: 32
	  });
	  var b3 = this.s.toBuffer({
	    size: 32
	  });
	  return Buffer.concat([b1, b2, b3]);
	};

	Signature.prototype.toBuffer = Signature.prototype.toDER = function() {
	  var rnbuf = this.r.toBuffer();
	  var snbuf = this.s.toBuffer();

	  var rneg = rnbuf[0] & 0x80 ? true : false;
	  var sneg = snbuf[0] & 0x80 ? true : false;

	  var rbuf = rneg ? Buffer.concat([new Buffer([0x00]), rnbuf]) : rnbuf;
	  var sbuf = sneg ? Buffer.concat([new Buffer([0x00]), snbuf]) : snbuf;

	  var rlength = rbuf.length;
	  var slength = sbuf.length;
	  var length = 2 + rlength + 2 + slength;
	  var rheader = 0x02;
	  var sheader = 0x02;
	  var header = 0x30;

	  var der = Buffer.concat([new Buffer([header, length, rheader, rlength]), rbuf, new Buffer([sheader, slength]), sbuf]);
	  return der;
	};

	Signature.prototype.toString = function() {
	  var buf = this.toDER();
	  return buf.toString('hex');
	};

	/**
	 * This function is translated from bitcoind's IsDERSignature and is used in
	 * the script interpreter.  This "DER" format actually includes an extra byte,
	 * the nhashtype, at the end. It is really the tx format, not DER format.
	 *
	 * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]
	 * Where R and S are not negative (their first byte has its highest bit not set), and not
	 * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
	 * in which case a single 0 byte is necessary and even required).
	 *
	 * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
	 */
	Signature.isTxDER = function(buf) {
	  if (buf.length < 9) {
	    //  Non-canonical signature: too short
	    return false;
	  }
	  if (buf.length > 73) {
	    // Non-canonical signature: too long
	    return false;
	  }
	  if (buf[0] !== 0x30) {
	    //  Non-canonical signature: wrong type
	    return false;
	  }
	  if (buf[1] !== buf.length - 3) {
	    //  Non-canonical signature: wrong length marker
	    return false;
	  }
	  var nLenR = buf[3];
	  if (5 + nLenR >= buf.length) {
	    //  Non-canonical signature: S length misplaced
	    return false;
	  }
	  var nLenS = buf[5 + nLenR];
	  if ((nLenR + nLenS + 7) !== buf.length) {
	    //  Non-canonical signature: R+S length mismatch
	    return false;
	  }

	  var R = buf.slice(4);
	  if (buf[4 - 2] !== 0x02) {
	    //  Non-canonical signature: R value type mismatch
	    return false;
	  }
	  if (nLenR === 0) {
	    //  Non-canonical signature: R length is zero
	    return false;
	  }
	  if (R[0] & 0x80) {
	    //  Non-canonical signature: R value negative
	    return false;
	  }
	  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {
	    //  Non-canonical signature: R value excessively padded
	    return false;
	  }

	  var S = buf.slice(6 + nLenR);
	  if (buf[6 + nLenR - 2] !== 0x02) {
	    //  Non-canonical signature: S value type mismatch
	    return false;
	  }
	  if (nLenS === 0) {
	    //  Non-canonical signature: S length is zero
	    return false;
	  }
	  if (S[0] & 0x80) {
	    //  Non-canonical signature: S value negative
	    return false;
	  }
	  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {
	    //  Non-canonical signature: S value excessively padded
	    return false;
	  }
	  return true;
	};

	/**
	 * Compares to bitcoind's IsLowDERSignature
	 * See also ECDSA signature algorithm which enforces this.
	 * See also BIP 62, "low S values in signatures"
	 */
	Signature.prototype.hasLowS = function() {
	  if (this.s.lt(1) ||
	    this.s.gt(BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0'))) {
	    return false;
	  }
	  return true;
	};

	/**
	 * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.
	 * Translated from bitcoind's IsDefinedHashtypeSignature
	 */
	Signature.prototype.hasDefinedHashtype = function() {
	  if (this.nhashtype < Signature.SIGHASH_ALL || this.nhashtype > Signature.SIGHASH_SINGLE) {
	    return false;
	  }
	  return true;
	};

	Signature.prototype.toTxFormat = function() {
	  var derbuf = this.toDER();
	  var buf = new Buffer(1);
	  buf.writeUInt8(this.nhashtype, 0);
	  return Buffer.concat([derbuf, buf]);
	};

	Signature.SIGHASH_ALL = 0x01;
	Signature.SIGHASH_NONE = 0x02;
	Signature.SIGHASH_SINGLE = 0x03;
	Signature.SIGHASH_ANYONECANPAY = 0x80;

	module.exports = Signature;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);

	function format(message, args) {
	  return message
	    .replace('{0}', args[0])
	    .replace('{1}', args[1])
	    .replace('{2}', args[2]);
	}
	var traverseNode = function(parent, errorDefinition) {
	  var NodeError = function() {
	    if (_.isString(errorDefinition.message)) {
	      this.message = format(errorDefinition.message, arguments);
	    } else if (_.isFunction(errorDefinition.message)) {
	      this.message = errorDefinition.message.apply(null, arguments);
	    } else {
	      throw new Error('Invalid error definition for ' + errorDefinition.name);
	    }
	    this.stack = this.message + '\n' + (new Error()).stack;
	  };
	  NodeError.prototype = Object.create(parent.prototype);
	  NodeError.prototype.name = parent.prototype.name + errorDefinition.name;
	  parent[errorDefinition.name] = NodeError;
	  if (errorDefinition.errors) {
	    childDefinitions(NodeError, errorDefinition.errors);
	  }
	  return NodeError;
	};

	/* jshint latedef: false */
	var childDefinitions = function(parent, childDefinitions) {
	  _.each(childDefinitions, function(childDefinition) {
	    traverseNode(parent, childDefinition);
	  });
	};
	/* jshint latedef: true */

	var traverseRoot = function(parent, errorsDefinition) {
	  childDefinitions(parent, errorsDefinition);
	  return parent;
	};


	var bitcore = {};
	bitcore.Error = function() {
	  this.message = 'Internal error';
	  this.stack = this.message + '\n' + (new Error()).stack;
	};
	bitcore.Error.prototype = Object.create(Error.prototype);
	bitcore.Error.prototype.name = 'bitcore.Error';


	var data = __webpack_require__(83);
	traverseRoot(bitcore.Error, data);

	module.exports = bitcore.Error;

	module.exports.extend = function(spec) {
	  return traverseNode(bitcore.Error, spec);
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(152);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(151);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(21)))

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _ = __webpack_require__(2);
	var $ = __webpack_require__(5);
	var base58check = __webpack_require__(27);
	var Networks = __webpack_require__(19);
	var Hash = __webpack_require__(7);
	var JSUtil = __webpack_require__(4);

	/**
	 * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,
	 * or an instance of {@link PublicKey} or {@link Script}.
	 *
	 * This is an immutable class, and if the first parameter provided to this constructor is an
	 * `Address` instance, the same argument will be returned.
	 *
	 * An address has two key properties: `network` and `type`. The type is either
	 * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string)
	 * or `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of {@link Network}.
	 * You can quickly check whether an address is of a given kind by using the methods
	 * `isPayToPublicKeyHash` and `isPayToScriptHash`
	 *
	 * @example
	 * ```javascript
	 * // validate that an input field is valid
	 * var error = Address.getValidationError(input, 'testnet');
	 * if (!error) {
	 *   var address = Address(input, 'testnet');
	 * } else {
	 *   // invalid network or checksum (typo?)
	 *   var message = error.messsage;
	 * }
	 *
	 * // get an address from a public key
	 * var address = Address(publicKey, 'testnet').toString();
	 * ```
	 *
	 * @param {*} data - The encoded data in various formats
	 * @param {Network|String|number} [network] - The network: 'livenet' or 'testnet'
	 * @param {String} [type] - The type of address: 'script' or 'pubkey'
	 * @returns {Address} A new valid and frozen instance of an Address
	 * @constructor
	 */
	function Address(data, network, type) {
	  /* jshint maxcomplexity: 12 */
	  /* jshint maxstatements: 20 */

	  if (!(this instanceof Address)) {
	    return new Address(data, network, type);
	  }

	  if (_.isArray(data) && _.isNumber(network)) {
	    return Address.createMultisig(data, network, type);
	  }

	  if (data instanceof Address) {
	    // Immutable instance
	    return data;
	  }

	  $.checkArgument(data, new TypeError('First argument is required, please include address data.'));

	  if (network && !Networks.get(network)) {
	    throw new TypeError('Second argument must be "livenet" or "testnet".');
	  }

	  if (type && (type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash)) {
	    throw new TypeError('Third argument must be "pubkeyhash" or "scripthash".');
	  }

	  var info = this._classifyArguments(data, network, type);

	  // set defaults if not set
	  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;
	  info.type = info.type || type || Address.PayToPublicKeyHash;

	  JSUtil.defineImmutable(this, {
	    hashBuffer: info.hashBuffer,
	    network: info.network,
	    type: info.type
	  });

	  return this;
	}

	/**
	 * Internal function used to split different kinds of arguments of the constructor
	 * @param {*} data - The encoded data in various formats
	 * @param {Network|String|number} [network] - The network: 'livenet' or 'testnet'
	 * @param {String} [type] - The type of address: 'script' or 'pubkey'
	 * @returns {Object} An "info" object with "type", "network", and "hashBuffer"
	 */
	Address.prototype._classifyArguments = function(data, network, type) {
	  var PublicKey = __webpack_require__(13);
	  var Script = __webpack_require__(9);
	  /* jshint maxcomplexity: 10 */
	  // transform and validate input data
	  if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {
	    return Address._transformHash(data);
	  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {
	    return Address._transformBuffer(data, network, type);
	  } else if (data instanceof PublicKey) {
	    return Address._transformPublicKey(data);
	  } else if (data instanceof Script) {
	    return Address._transformScript(data, network);
	  } else if (typeof(data) === 'string') {
	    return Address._transformString(data, network, type);
	  } else if (_.isObject(data)) {
	    return Address._transformObject(data);
	  } else {
	    throw new TypeError('First argument is an unrecognized data format.');
	  }
	};

	/** @static */
	Address.PayToPublicKeyHash = 'pubkeyhash';
	/** @static */
	Address.PayToScriptHash = 'scripthash';

	/**
	 * @param {Buffer} hash - An instance of a hash Buffer
	 * @returns {Object} An object with keys: hashBuffer
	 * @private
	 */
	Address._transformHash = function(hash){
	  var info = {};
	  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {
	    throw new TypeError('Address supplied is not a buffer.');
	  }
	  if (hash.length !== 20) {
	    throw new TypeError('Address hashbuffers must be exactly 20 bytes.');
	  }
	  info.hashBuffer = hash;
	  return info;
	};

	/**
	 * Deserializes an address serialized through `Address#toObject()`
	 * @param {Object} data
	 * @param {string} data.hash - the hash that this address encodes
	 * @param {string} data.type - either 'pubkeyhash' or 'scripthash'
	 * @param {Network=} data.network - the name of the network associated
	 * @return {Address}
	 */
	Address._transformObject = function(data) {
	  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');
	  $.checkArgument(data.type, 'Must provide a `type` property');
	  return {
	    hashBuffer: data.hash ? new Buffer(data.hash, 'hex') : data.hashBuffer,
	    network: Networks.get(data.network) || Networks.defaultNetwork,
	    type: data.type
	  };
	};

	/**
	 * Internal function to discover the network and type based on the first data byte
	 *
	 * @param {Buffer} buffer - An instance of a hex encoded address Buffer
	 * @returns {Object} An object with keys: network and type
	 * @private
	 */
	Address._classifyFromVersion = function(buffer){
	  var version = {};
	  version.network = Networks.get(buffer[0]);
	  switch (buffer[0]) { // the version byte
	    case Networks.livenet.pubkeyhash:
	      version.type = Address.PayToPublicKeyHash;
	      break;

	    case Networks.livenet.scripthash:
	      version.type = Address.PayToScriptHash;
	      break;

	    case Networks.testnet.pubkeyhash:
	      version.type = Address.PayToPublicKeyHash;
	      break;

	    case Networks.testnet.scripthash:
	      version.type = Address.PayToScriptHash;
	      break;
	  }
	  return version;
	};

	/**
	 * Internal function to transform a bitcoin address buffer
	 *
	 * @param {Buffer} buffer - An instance of a hex encoded address Buffer
	 * @param {String} [network] - The network: 'livenet' or 'testnet'
	 * @param {String} [type] - The type: 'pubkeyhash' or 'scripthash'
	 * @returns {Object} An object with keys: hashBuffer, network and type
	 * @private
	 */
	Address._transformBuffer = function(buffer, network, type){
	  /* jshint maxcomplexity: 9 */
	  var info = {};
	  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {
	    throw new TypeError('Address supplied is not a buffer.');
	  }
	  if (buffer.length !== 1 + 20) {
	    throw new TypeError('Address buffers must be exactly 21 bytes.');
	  }

	  network = Networks.get(network);
	  var bufferVersion = Address._classifyFromVersion(buffer);

	  if (!bufferVersion.network || (network && network !== bufferVersion.network)) {
	    throw new TypeError('Address has mismatched network type.');
	  }

	  if (!bufferVersion.type || ( type && type !== bufferVersion.type )) {
	    throw new TypeError('Address has mismatched type.');
	  }

	  info.hashBuffer = buffer.slice(1);
	  info.network = bufferVersion.network;
	  info.type = bufferVersion.type;
	  return info;
	};

	/**
	 * Internal function to transform a {@link PublicKey}
	 *
	 * @param {PublicKey} pubkey - An instance of PublicKey
	 * @returns {Object} An object with keys: hashBuffer, type
	 * @private
	 */
	Address._transformPublicKey = function(pubkey){
	  var PublicKey = __webpack_require__(13);
	  var info = {};
	  if (!(pubkey instanceof PublicKey)) {
	    throw new TypeError('Address must be an instance of PublicKey.');
	  }
	  info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());
	  info.type = Address.PayToPublicKeyHash;
	  return info;
	};

	/**
	 * Internal function to transform a {@link Script} into a `info` object.
	 *
	 * @param {Script} script - An instance of Script
	 * @returns {Object} An object with keys: hashBuffer, type
	 * @private
	 */
	Address._transformScript = function(script, network){
	  var Script = __webpack_require__(9);
	  var info = {};
	  if (!(script instanceof Script)) {
	    throw new TypeError('Address must be an instance of Script.');
	  }
	  if (script.isScriptHashOut()) {
	    info.hashBuffer = script.getData();
	    info.type = Address.PayToScriptHash;
	  } else if (script.isPublicKeyHashOut()) {
	    info.hashBuffer = script.getData();
	    info.type = Address.PayToPublicKeyHash;
	  } else {
	    info.hashBuffer = Hash.sha256ripemd160(script.toBuffer());
	    info.type = Address.PayToScriptHash;
	  }
	  info.network = Networks.get(network) || Networks.defaultNetwork;
	  return info;
	};

	/**
	 * Creates a P2SH address from a set of public keys and a threshold.
	 *
	 * The addresses will be sorted lexicographically, as that is the trend in bitcoin.
	 * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}
	 * interface.
	 *
	 * @param {Array} publicKeys - a set of public keys to create an address
	 * @param {number} threshold - the number of signatures needed to release the funds
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @return {Address}
	 */
	Address.createMultisig = function(publicKeys, threshold, network) {
	  var Script = __webpack_require__(9);
	  network = network || publicKeys[0].network;
	  return new Address(Script.buildMultisigOut(publicKeys, threshold), network || Networks.defaultNetwork);
	};

	/**
	 * Internal function to transform a bitcoin address string
	 *
	 * @param {String} data
	 * @param {String|Network} [network] - either a Network instance, 'livenet', or 'testnet'
	 * @param {String} [type] - The type: 'pubkeyhash' or 'scripthash'
	 * @returns {Object} An object with keys: hashBuffer, network and type
	 * @private
	 */
	Address._transformString = function(data, network, type){
	  if( typeof(data) !== 'string' ) {
	    throw new TypeError('Address supplied is not a string.');
	  }
	  var addressBuffer = base58check.decode(data);
	  var info = Address._transformBuffer(addressBuffer, network, type);
	  return info;
	};

	/**
	 * Instantiate an address from a PublicKey instance
	 *
	 * @param {PublicKey} data
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromPublicKey = function(data, network){
	  var info = Address._transformPublicKey(data);
	  network = network || Networks.defaultNetwork;
	  return new Address(info.hashBuffer, network, info.type);
	};

	/**
	 * Instantiate an address from a ripemd160 public key hash
	 *
	 * @param {Buffer} hash - An instance of buffer of the hash
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromPublicKeyHash = function(hash, network) {
	  var info = Address._transformHash(hash);
	  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);
	};

	/**
	 * Instantiate an address from a ripemd160 script hash
	 *
	 * @param {Buffer} hash - An instance of buffer of the hash
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromScriptHash = function(hash, network) {
	  var info = Address._transformHash(hash);
	  return new Address(info.hashBuffer, network, Address.PayToScriptHash);
	};

	/**
	 * Instantiate an address from a Script
	 *
	 * @param {Script} script - An instance of Script
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromScript = function(script, network) {
	  var info = Address._transformScript(script, network);
	  return new Address(info.hashBuffer, network, info.type);
	};

	/**
	 * Instantiate an address from a buffer of the address
	 *
	 * @param {Buffer} buffer - An instance of buffer of the address
	 * @param {String|Network} [network] - either a Network instance, 'livenet', or 'testnet'
	 * @param {String} [type] - The type of address: 'script' or 'pubkey'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromBuffer = function(buffer, network, type) {
	  var info = Address._transformBuffer(buffer, network, type);
	  return new Address(info.hashBuffer, info.network, info.type);
	};

	/**
	 * Instantiate an address from an address string
	 *
	 * @param {String} str - An string of the bitcoin address
	 * @param {String|Network} [network] - either a Network instance, 'livenet', or 'testnet'
	 * @param {String} [type] - The type of address: 'script' or 'pubkey'
	 * @returns {Address} A new valid and frozen instance of an Address
	 */
	Address.fromString = function(str, network, type) {
	  var info = Address._transformString(str, network, type);
	  return new Address(info.hashBuffer, info.network, info.type);
	};

	/**
	 * Instantiate an address from JSON
	 *
	 * @param {String} json - An JSON string or Object with keys: hash, network and type
	 * @returns {Address} A new valid instance of an Address
	 */
	Address.fromJSON = function fromJSON(json) {
	  if (JSUtil.isValidJSON(json)) {
	    json = JSON.parse(json);
	  }
	  $.checkState(
	    JSUtil.isHexa(json.hash),
	    'Unexpected hash property, "' + json.hash + '", expected to be hex.'
	  );
	  var hashBuffer = new Buffer(json.hash, 'hex');
	  return new Address(hashBuffer, json.network, json.type);
	};

	/**
	 * Will return a validation error if exists
	 *
	 * @example
	 * ```javascript
	 * // a network mismatch error
	 * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');
	 * ```
	 *
	 * @param {String} data - The encoded data
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @param {String} type - The type of address: 'script' or 'pubkey'
	 * @returns {null|Error} The corresponding error message
	 */
	Address.getValidationError = function(data, network, type) {
	  var error;
	  try {
	    /* jshint nonew: false */
	    new Address(data, network, type);
	  } catch (e) {
	    error = e;
	  }
	  return error;
	};

	/**
	 * Will return a boolean if an address is valid
	 *
	 * @example
	 * ```javascript
	 * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));
	 * ```
	 *
	 * @param {String} data - The encoded data
	 * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'
	 * @param {String} type - The type of address: 'script' or 'pubkey'
	 * @returns {boolean} The corresponding error message
	 */
	Address.isValid = function(data, network, type) {
	  return !Address.getValidationError(data, network, type);
	};

	/**
	 * Returns true if an address is of pay to public key hash type
	 * @return boolean
	 */
	Address.prototype.isPayToPublicKeyHash = function() {
	  return this.type === Address.PayToPublicKeyHash;
	};

	/**
	 * Returns true if an address is of pay to script hash type
	 * @return boolean
	 */
	Address.prototype.isPayToScriptHash = function() {
	  return this.type === Address.PayToScriptHash;
	};

	/**
	 * Will return a buffer representation of the address
	 *
	 * @returns {Buffer} Bitcoin address buffer
	 */
	Address.prototype.toBuffer = function() {
	  var version = new Buffer([this.network[this.type]]);
	  var buf = Buffer.concat([version, this.hashBuffer]);
	  return buf;
	};

	/**
	 * @returns {Object} A plain object with the address information
	 */
	Address.prototype.toObject = function toObject() {
	  return {
	    hash: this.hashBuffer.toString('hex'),
	    type: this.type,
	    network: this.network.toString()
	  };
	};

	/**
	 * @returns {String} A JSON representation of a plain object with the address information
	 */
	Address.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	/**
	 * Will return a the string representation of the address
	 *
	 * @returns {String} Bitcoin address
	 */
	Address.prototype.toString = function() {
	  return base58check.encode(this.toBuffer());
	};

	/**
	 * Will return a string formatted for the console
	 *
	 * @returns {String} Bitcoin address
	 */
	Address.prototype.inspect = function() {
	  return '<Address: ' + this.toString() + ', type: '+this.type+', network: '+this.network+'>';
	};

	module.exports = Address;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _ = __webpack_require__(2);
	var $ = __webpack_require__(5);
	var bufferUtil = __webpack_require__(3);
	var BN = __webpack_require__(6);

	var BufferReader = function BufferReader(buf) {
	  if (!(this instanceof BufferReader)) {
	    return new BufferReader(buf);
	  }
	  if (Buffer.isBuffer(buf)) {
	    this.set({
	      buf: buf
	    });
	  } else if (buf) {
	    var obj = buf;
	    this.set(obj);
	  }
	};

	BufferReader.prototype.set = function(obj) {
	  this.buf = obj.buf || this.buf || undefined;
	  this.pos = obj.pos || this.pos || 0;
	  return this;
	};

	BufferReader.prototype.eof = function() {
	  return this.pos >= this.buf.length;
	};

	BufferReader.prototype.finished = BufferReader.prototype.eof;

	BufferReader.prototype.read = function(len) {
	  $.checkArgument(!_.isUndefined(len), 'Must specify a length');
	  var buf = this.buf.slice(this.pos, this.pos + len);
	  this.pos = this.pos + len;
	  return buf;
	};

	BufferReader.prototype.readAll = function() {
	  var buf = this.buf.slice(this.pos, this.buf.length);
	  this.pos = this.buf.length;
	  return buf;
	};

	BufferReader.prototype.readUInt8 = function() {
	  var val = this.buf.readUInt8(this.pos);
	  this.pos = this.pos + 1;
	  return val;
	};

	BufferReader.prototype.readUInt16BE = function() {
	  var val = this.buf.readUInt16BE(this.pos);
	  this.pos = this.pos + 2;
	  return val;
	};

	BufferReader.prototype.readUInt16LE = function() {
	  var val = this.buf.readUInt16LE(this.pos);
	  this.pos = this.pos + 2;
	  return val;
	};

	BufferReader.prototype.readUInt32BE = function() {
	  var val = this.buf.readUInt32BE(this.pos);
	  this.pos = this.pos + 4;
	  return val;
	};

	BufferReader.prototype.readUInt32LE = function() {
	  var val = this.buf.readUInt32LE(this.pos);
	  this.pos = this.pos + 4;
	  return val;
	};

	BufferReader.prototype.readUInt64BEBN = function() {
	  var buf = this.buf.slice(this.pos, this.pos + 8);
	  var bn = BN.fromBuffer(buf);
	  this.pos = this.pos + 8;
	  return bn;
	};

	BufferReader.prototype.readUInt64LEBN = function() {
	  var buf = this.buf.slice(this.pos, this.pos + 8);
	  var reversebuf = BufferReader({
	    buf: buf
	  }).readReverse();
	  var bn = BN.fromBuffer(reversebuf);
	  this.pos = this.pos + 8;
	  return bn;
	};

	BufferReader.prototype.readVarintNum = function() {
	  var first = this.readUInt8();
	  switch (first) {
	    case 0xFD:
	      return this.readUInt16LE();
	    case 0xFE:
	      return this.readUInt32LE();
	    case 0xFF:
	      var bn = this.readUInt64LEBN();
	      var n = bn.toNumber();
	      if (n <= Math.pow(2, 53)) {
	        return n;
	      } else {
	        throw new Error('number too large to retain precision - use readVarintBN');
	      }
	      break;
	    default:
	      return first;
	  }
	};

	/**
	 * reads a length prepended buffer
	 */
	BufferReader.prototype.readVarLengthBuffer = function() {
	  var len = this.readVarintNum();
	  var buf = this.read(len);
	  $.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' +
	    'Expected to read: ' + len + ' and read ' + buf.length);
	  return buf;
	};

	BufferReader.prototype.readVarintBuf = function() {
	  var first = this.buf.readUInt8(this.pos);
	  switch (first) {
	    case 0xFD:
	      return this.read(1 + 2);
	    case 0xFE:
	      return this.read(1 + 4);
	    case 0xFF:
	      return this.read(1 + 8);
	    default:
	      return this.read(1);
	  }
	};

	BufferReader.prototype.readVarintBN = function() {
	  var first = this.readUInt8();
	  switch (first) {
	    case 0xFD:
	      return BN(this.readUInt16LE());
	    case 0xFE:
	      return BN(this.readUInt32LE());
	    case 0xFF:
	      return this.readUInt64LEBN();
	    default:
	      return BN(first);
	  }
	};

	BufferReader.prototype.reverse = function() {
	  var buf = new Buffer(this.buf.length);
	  for (var i = 0; i < buf.length; i++) {
	    buf[i] = this.buf[this.buf.length - 1 - i];
	  }
	  this.buf = buf;
	  return this;
	};

	BufferReader.prototype.readReverse = function(len) {
	  if (_.isUndefined(len)) {
	    len = this.buf.length;
	  }
	  var buf = this.buf.slice(this.pos, this.pos + len);
	  this.pos = this.pos + len;
	  return bufferUtil.reverse(buf);
	};

	module.exports = BufferReader;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(2);

	var BufferUtil = __webpack_require__(3);
	var networks = [];
	var networkMaps = {};

	/**
	 * A network is merely a map containing values that correspond to version
	 * numbers for each bitcoin network. Currently only supporting "livenet"
	 * (a.k.a. "mainnet") and "testnet".
	 * @constructor
	 */
	function Network() {}

	Network.prototype.toString = function toString() {
	  return this.name;
	};

	/**
	 * @function
	 * @member Networks#get
	 * Retrieves the network associated with a magic number or string.
	 * @param {string|number|Network} arg
	 * @param {string} key - if set, only check if the magic number associated with this name matches
	 * @return Network
	 */
	function getNetwork(arg, key) {
	  if (~networks.indexOf(arg)) {
	    return arg;
	  }
	  if (key) {
	    for (var index in networks) {
	      if (networks[index][key] === arg) {
	        return networks[index];
	      }
	    }
	    return undefined;
	  }
	  return networkMaps[arg];
	}

	/**
	 * @function
	 * @member Networks#add
	 * Will add a custom Network
	 * @param {Object} data
	 * @param {String} data.name - The name of the network
	 * @param {String} data.alias - The aliased name of the network
	 * @param {Number} data.pubkeyhash - The publickey hash prefix
	 * @param {Number} data.privatekey - The privatekey prefix
	 * @param {Number} data.scripthash - The scripthash prefix
	 * @param {Number} data.xpubkey - The extended public key magic
	 * @param {Number} data.xprivkey - The extended private key magic
	 * @param {Number} data.networkMagic - The network magic number
	 * @param {Number} data.port - The network port
	 * @param {Array}  data.dnsSeeds - An array of dns seeds
	 * @return Network
	 */
	function addNetwork(data) {

	  var network = new Network();

	  _.extend(network, {
	    name: data.name,
	    alias: data.alias,
	    pubkeyhash: data.pubkeyhash,
	    privatekey: data.privatekey,
	    scripthash: data.scripthash,
	    xpubkey: data.xpubkey,
	    xprivkey: data.xprivkey,
	    networkMagic: BufferUtil.integerAsBuffer(data.networkMagic),
	    port: data.port,
	    dnsSeeds: data.dnsSeeds
	  });

	  _.each(_.values(network), function(value) {
	    if (!_.isObject(value)) {
	      networkMaps[value] = network;
	    }
	  });

	  networks.push(network);

	  return network;

	}

	addNetwork({
	  name: 'livenet',
	  alias: 'mainnet',
	  pubkeyhash: 0x00,
	  privatekey: 0x80,
	  scripthash: 0x05,
	  xpubkey:  0x0488b21e,
	  xprivkey: 0x0488ade4,
	  networkMagic: 0xf9beb4d9,
	  port: 8333,
	  dnsSeeds: [
	    'seed.bitcoin.sipa.be',
	    'dnsseed.bluematt.me',
	    'dnsseed.bitcoin.dashjr.org',
	    'seed.bitcoinstats.com',
	    'seed.bitnodes.io',
	    'bitseed.xf2.org'
	  ]
	});

	addNetwork({
	  name: 'testnet',
	  alias: 'testnet',
	  pubkeyhash: 0x6f,
	  privatekey: 0xef,
	  scripthash: 0xc4,
	  xpubkey: 0x043587cf,
	  xprivkey: 0x04358394,
	  networkMagic: 0x0b110907,
	  port: 18333,
	  dnsSeeds: [
	    'testnet-seed.bitcoin.petertodd.org',
	    'testnet-seed.bluematt.me'
	  ],
	});

	/**
	* @instance
	* @member Networks#livenet
	*/
	var livenet = getNetwork('livenet');

	/**
	* @instance
	* @member Networks#testnet
	*/
	var testnet = getNetwork('testnet');

	/**
	 * @namespace Networks
	 */
	module.exports = {
	  add: addNetwork,
	  defaultNetwork: livenet,
	  livenet: livenet,
	  mainnet: livenet,
	  testnet: testnet,
	  get: getNetwork
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var hash = exports;

	hash.utils = __webpack_require__(103);
	hash.common = __webpack_require__(99);
	hash.sha = __webpack_require__(102);
	hash.ripemd = __webpack_require__(101);
	hash.hmac = __webpack_require__(100);

	// Proxy hash functions to the main object
	hash.sha1 = hash.sha.sha1;
	hash.sha256 = hash.sha.sha256;
	hash.sha224 = hash.sha.sha224;
	hash.ripemd160 = hash.ripemd.ripemd160;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};

	process.nextTick = (function () {
	    var canSetImmediate = typeof window !== 'undefined'
	    && window.setImmediate;
	    var canMutationObserver = typeof window !== 'undefined'
	    && window.MutationObserver;
	    var canPost = typeof window !== 'undefined'
	    && window.postMessage && window.addEventListener
	    ;

	    if (canSetImmediate) {
	        return function (f) { return window.setImmediate(f) };
	    }

	    var queue = [];

	    if (canMutationObserver) {
	        var hiddenDiv = document.createElement("div");
	        var observer = new MutationObserver(function () {
	            var queueList = queue.slice();
	            queue.length = 0;
	            queueList.forEach(function (fn) {
	                fn();
	            });
	        });

	        observer.observe(hiddenDiv, { attributes: true });

	        return function nextTick(fn) {
	            if (!queue.length) {
	                hiddenDiv.setAttribute('yes', 'no');
	            }
	            queue.push(fn);
	        };
	    }

	    if (canPost) {
	        window.addEventListener('message', function (ev) {
	            var source = ev.source;
	            if ((source === window || source === null) && ev.data === 'process-tick') {
	                ev.stopPropagation();
	                if (queue.length > 0) {
	                    var fn = queue.shift();
	                    fn();
	                }
	            }
	        }, true);

	        return function nextTick(fn) {
	            queue.push(fn);
	            window.postMessage('process-tick', '*');
	        };
	    }

	    return function nextTick(fn) {
	        setTimeout(fn, 0);
	    };
	})();

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(29);
	util.inherits = __webpack_require__(30);
	/*</replacement>*/

	var Readable = __webpack_require__(76);
	var Writable = __webpack_require__(52);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var BN = __webpack_require__(6);
	var bufferUtil = __webpack_require__(3);
	var ec = __webpack_require__(11).curves.secp256k1;
	var ecPoint = ec.curve.point.bind(ec.curve);
	var ecPointFromX = ec.curve.pointFromX.bind(ec.curve);

	/**
	 *
	 * Instantiate a valid secp256k1 Point from the X and Y coordinates.
	 *
	 * @param {BN|String} x - The X coordinate
	 * @param {BN|String} y - The Y coordinate
	 * @link https://github.com/indutny/elliptic
	 * @augments elliptic.curve.point
	 * @throws {Error} A validation error if exists
	 * @returns {Point} An instance of Point
	 * @constructor
	 */
	var Point = function Point(x, y, isRed) {
	  var point = ecPoint(x, y, isRed);
	  point.validate();
	  return point;
	};

	Point.prototype = Object.getPrototypeOf(ec.curve.point());

	/**
	 *
	 * Instantiate a valid secp256k1 Point from only the X coordinate
	 *
	 * @param {boolean} odd - If the Y coordinate is odd
	 * @param {BN|String} x - The X coordinate
	 * @throws {Error} A validation error if exists
	 * @returns {Point} An instance of Point
	 */
	Point.fromX = function fromX(odd, x){
	  var point = ecPointFromX(odd, x);
	  point.validate();
	  return point;
	};

	/**
	 *
	 * Will return a secp256k1 ECDSA base point.
	 *
	 * @link https://en.bitcoin.it/wiki/Secp256k1
	 * @returns {Point} An instance of the base point.
	 */
	Point.getG = function getG() {
	  return Point(ec.curve.g.getX(), ec.curve.g.getY());
	};

	/**
	 *
	 * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.
	 *
	 * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys
	 * @returns {BN} A BN instance of the number of points on the curve
	 */
	Point.getN = function getN() {
	  return BN(ec.curve.n.toArray());
	};

	Point.prototype._getX = Point.prototype.getX;

	/**
	 *
	 * Will return the X coordinate of the Point
	 *
	 * @returns {BN} A BN instance of the X coordinate
	 */
	Point.prototype.getX = function getX() {
	  return BN(this._getX().toArray());
	};

	Point.prototype._getY = Point.prototype.getY;

	/**
	 *
	 * Will return the Y coordinate of the Point
	 *
	 * @returns {BN} A BN instance of the Y coordinate
	 */
	Point.prototype.getY = function getY() {
	  return BN(this._getY().toArray());
	};

	/**
	 *
	 * Will determine if the point is valid
	 *
	 * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf
	 * @param {Point} An instance of Point
	 * @throws {Error} A validation error if exists
	 * @returns {Point} An instance of the same Point
	 */
	Point.prototype.validate = function validate() {

	  if (this.isInfinity()){
	    throw new Error('Point cannot be equal to Infinity');
	  }

	  if (this.getX().cmp(0) === 0 || this.getY().cmp(0) === 0){
	    throw new Error('Invalid x,y value for curve, cannot equal 0.');
	  }

	  var p2 = ecPointFromX(this.getY().isOdd(), this.getX());

	  if (p2.y.cmp(this.y) !== 0) {
	    throw new Error('Invalid y value for curve.');
	  }

	  var xValidRange = (this.getX().gt(-1) && this.getX().lt(Point.getN()));
	  var yValidRange = (this.getY().gt(-1) && this.getY().lt(Point.getN()));

	  if ( !xValidRange || !yValidRange ) {
	    throw new Error('Point does not lie on the curve');
	  }

	  //todo: needs test case
	  if (!(this.mul(Point.getN()).isInfinity())) {
	    throw new Error('Point times N must be infinity');
	  }

	  return this;

	};

	Point.pointToCompressed = function pointToCompressed(point) {
	  var xbuf = point.getX().toBuffer({size: 32});
	  var ybuf = point.getY().toBuffer({size: 32});

	  var prefix;
	  var odd = ybuf[ybuf.length - 1] % 2;
	  if (odd) {
	    prefix = new Buffer([0x03]);
	  } else {
	    prefix = new Buffer([0x02]);
	  }
	  return bufferUtil.concat([prefix, xbuf]);
	};

	module.exports = Point;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);
	var BN = __webpack_require__(6);
	var buffer = __webpack_require__(1);
	var bufferUtil = __webpack_require__(3);
	var JSUtil = __webpack_require__(4);
	var BufferWriter = __webpack_require__(12);
	var Script = __webpack_require__(9);

	function Output(params) {
	  if (!(this instanceof Output)) {
	    return new Output(params);
	  }
	  if (params) {
	    if (JSUtil.isValidJSON(params)) {
	      return Output.fromJSON(params);
	    }
	    return this._fromObject(params);
	  }
	}

	Object.defineProperty(Output.prototype, 'script', {
	  configurable: false,
	  writeable: false,
	  enumerable: true,
	  get: function() {
	    if (!this._script) {
	      this._script = new Script(this._scriptBuffer);
	    }
	    return this._script;
	  }
	});

	Object.defineProperty(Output.prototype, 'satoshis', {
	  configurable: false,
	  writeable: true,
	  enumerable: true,
	  get: function() {
	    return this._satoshis;
	  },
	  set: function(num) {
	    if (num instanceof BN) {
	      this._satoshisBN = num;
	      this._satoshis = num.toNumber();
	    } else if (_.isString(num)) {
	      this._satoshis = parseInt(num);
	      this._satoshisBN = BN.fromNumber(this._satoshis);
	    } else {
	      this._satoshisBN = BN.fromNumber(num);
	      this._satoshis = num;
	    }
	  }
	});

	Output.prototype._fromObject = function(param) {
	  this.satoshis = param.satoshis;
	  if (param.script || param.scriptBuffer) {
	    this.setScript(param.script || param.scriptBuffer);
	  }
	  return this;
	};

	Output.prototype.toObject = function toObject() {
	  return {
	    satoshis: this.satoshis,
	    script: this.script.toString()
	  };
	};

	Output.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	Output.fromJSON = function(json) {
	  if (JSUtil.isValidJSON(json)) {
	    json = JSON.parse(json);
	  }
	  return new Output({
	    satoshis: json.satoshis || -(-json.valuebn),
	    script: new Script(json.script)
	  });
	};

	Output.prototype.setScript = function(script) {
	  if (script instanceof Script) {
	    this._scriptBuffer = script.toBuffer();
	    this._script = script;
	  } else if (_.isString(script)) {
	    this._script = new Script(script);
	    this._scriptBuffer = this._script.toBuffer();
	  } else if (bufferUtil.isBuffer(script)) {
	    this._scriptBuffer = script;
	    this._script = null;
	  } else {
	    throw new TypeError('Unrecognized Argument');
	  }
	  return this;
	};

	Output.prototype.inspect = function() {
	  return '<Output (' + this.satoshis + ' sats) ' + this.script.inspect() + '>';
	};

	Output.fromBufferReader = function(br) {
	  var output = new Output();
	  output.satoshis = br.readUInt64LEBN();
	  var size = br.readVarintNum();
	  if (size !== 0) {
	    output._scriptBuffer = br.read(size);
	  } else {
	    output._scriptBuffer = new buffer.Buffer([]);
	  }
	  return output;
	};

	Output.prototype.toBufferWriter = function(writer) {
	  if (!writer) {
	    writer = new BufferWriter();
	  }
	  writer.writeUInt64LEBN(this._satoshisBN);
	  var script = this._scriptBuffer;
	  writer.writeVarintNum(script.length);
	  writer.write(script);
	  return writer;
	};

	module.exports = Output;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _ = __webpack_require__(2);
	var base58 = __webpack_require__(34);
	var buffer = __webpack_require__(1);
	var sha256sha256 = __webpack_require__(7).sha256sha256;

	var Base58Check = function Base58Check(obj) {
	  if (!(this instanceof Base58Check))
	    return new Base58Check(obj);
	  if (Buffer.isBuffer(obj)) {
	    var buf = obj;
	    this.fromBuffer(buf);
	  } else if (typeof obj === 'string') {
	    var str = obj;
	    this.fromString(str);
	  } else if (obj) {
	    this.set(obj);
	  }
	};

	Base58Check.prototype.set = function(obj) {
	  this.buf = obj.buf || this.buf || undefined;
	  return this;
	};

	Base58Check.validChecksum = function validChecksum(data, checksum) {
	  if (_.isString(data)) {
	    data = new buffer.Buffer(base58.decode(data));
	  }
	  if (_.isString(checksum)) {
	    checksum = new buffer.Buffer(base58.decode(checksum));
	  }
	  if (!checksum) {
	    checksum = data.slice(-4);
	    data = data.slice(0, -4);
	  }
	  return Base58Check.checksum(data).toString('hex') === checksum.toString('hex');
	};

	Base58Check.decode = function(s) {
	  if (typeof s !== 'string')
	    throw new Error('Input must be a string');

	  var buf = new Buffer(base58.decode(s));

	  if (buf.length < 4)
	    throw new Error("Input string too short");

	  var data = buf.slice(0, -4);
	  var csum = buf.slice(-4);

	  var hash = sha256sha256(data);
	  var hash4 = hash.slice(0, 4);

	  if (csum.toString('hex') !== hash4.toString('hex'))
	    throw new Error("Checksum mismatch");

	  return data;
	};

	Base58Check.checksum = function(buffer) {
	  return sha256sha256(buffer).slice(0, 4);
	};

	Base58Check.encode = function(buf) {
	  if (!Buffer.isBuffer(buf))
	    throw new Error('Input must be a buffer');
	  var checkedBuf = new Buffer(buf.length + 4);
	  var hash = Base58Check.checksum(buf);
	  buf.copy(checkedBuf);
	  hash.copy(checkedBuf, buf.length);
	  return base58.encode(checkedBuf);
	};

	Base58Check.prototype.fromBuffer = function(buf) {
	  this.buf = buf;
	  return this;
	};

	Base58Check.prototype.fromString = function(str) {
	  var buf = Base58Check.decode(str);
	  this.buf = buf;
	  return this;
	};

	Base58Check.prototype.toBuffer = function() {
	  return this.buf;
	};

	Base58Check.prototype.toString = function() {
	  return Base58Check.encode(this.buf);
	};

	module.exports = Base58Check;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var buffer = __webpack_require__(1);

	var Signature = __webpack_require__(14);
	var Script = __webpack_require__(9);
	var Output = __webpack_require__(24);
	var BufferReader = __webpack_require__(18);
	var BufferWriter = __webpack_require__(12);
	var BN = __webpack_require__(6);
	var Hash = __webpack_require__(7);
	var ECDSA = __webpack_require__(57);
	var $ = __webpack_require__(5);
	var _ = __webpack_require__(2);

	var SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';
	var BITS_64_ON = 'ffffffffffffffff';

	/**
	 * Returns a buffer of length 32 bytes with the hash that needs to be signed
	 * for OP_CHECKSIG.
	 *
	 * @name Signing.sighash
	 * @param {Transaction} transaction the transaction to sign
	 * @param {number} sighashType the type of the hash
	 * @param {number} inputNumber the input index for the signature
	 * @param {Script} subscript the script that will be signed
	 */
	var sighash = function sighash(transaction, sighashType, inputNumber, subscript) {
	  var Transaction = __webpack_require__(61);
	  var Input = __webpack_require__(42);

	  var i;
	  // Copy transaction
	  var txcopy = Transaction.shallowCopy(transaction);

	  // Copy script
	  subscript = new Script(subscript);
	  subscript.removeCodeseparators();

	  for (i = 0; i < txcopy.inputs.length; i++) {
	    // Blank signatures for other inputs
	    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());
	  }

	  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);

	  if ((sighashType & 31) === Signature.SIGHASH_NONE ||
	    (sighashType & 31) === Signature.SIGHASH_SINGLE) {

	    // clear all sequenceNumbers
	    for (i = 0; i < txcopy.inputs.length; i++) {
	      if (i !== inputNumber) {
	        txcopy.inputs[i].sequenceNumber = 0;
	      }
	    }
	  }

	  if ((sighashType & 31) === Signature.SIGHASH_NONE) {
	    txcopy.outputs = [];

	  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {
	    // The SIGHASH_SINGLE bug.
	    // https://bitcointalk.org/index.php?topic=260595.0
	    if (inputNumber > txcopy.outputs.length - 1) {
	      return new Buffer(SIGHASH_SINGLE_BUG, 'hex');
	    }
	    if (txcopy.outputs.length <= inputNumber) {
	      throw new Error('Missing output to sign');
	    }

	    txcopy.outputs.length = inputNumber + 1;

	    for (i = 0; i < inputNumber; i++) {
	      txcopy.outputs[i] = new Output({
	        satoshis: BN.fromBuffer(new buffer.Buffer(BITS_64_ON, 'hex')),
	        script: Script.empty()
	      });
	    }
	  }

	  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {
	    txcopy.inputs = [txcopy.inputs[inputNumber]];
	  }

	  var buf = new BufferWriter()
	    .write(txcopy.toBuffer())
	    .writeInt32LE(sighashType)
	    .toBuffer();
	  var ret = Hash.sha256sha256(buf);
	  ret = new BufferReader(ret).readReverse();
	  return ret;
	};

	/**
	 * Create a signature
	 *
	 * @name Signing.sign
	 * @param {Transaction} transaction
	 * @param {PrivateKey} privateKey
	 * @param {number} sighash
	 * @param {number} inputIndex
	 * @param {Script} subscript
	 * @return {Signature}
	 */
	function sign(transaction, privateKey, sighashType, inputIndex, subscript) {
	  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript);
	  var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({
	    nhashtype: sighashType
	  });
	  return sig;
	}

	/**
	 * Verify a signature
	 *
	 * @name Signing.verify
	 * @param {Transaction} transaction
	 * @param {Signature} signature
	 * @param {PublicKey} publicKey
	 * @param {number} inputIndex
	 * @param {Script} subscript
	 * @return {boolean}
	 */
	function verify(transaction, signature, publicKey, inputIndex, subscript) {
	  $.checkArgument(!_.isUndefined(transaction));
	  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));
	  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);
	  return ECDSA.verify(hashbuf, signature, publicKey, 'little');
	}

	/**
	 * @namespace Signing
	 */
	module.exports = {
	  sighash: sighash,
	  sign: sign,
	  verify: verify
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(26).EventEmitter;
	var inherits = __webpack_require__(149);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(146);
	Stream.Writable = __webpack_require__(148);
	Stream.Duplex = __webpack_require__(143);
	Stream.Transform = __webpack_require__(147);
	Stream.PassThrough = __webpack_require__(145);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var bitcore = module.exports;


	// crypto 
	bitcore.crypto = {};
	bitcore.crypto.BN = __webpack_require__(6);
	bitcore.crypto.ECDSA = __webpack_require__(57);
	bitcore.crypto.Hash = __webpack_require__(7);
	bitcore.crypto.Random = __webpack_require__(33);
	bitcore.crypto.Point = __webpack_require__(23);
	bitcore.crypto.Signature = __webpack_require__(14);

	// encoding
	bitcore.encoding = {};
	bitcore.encoding.Base58 = __webpack_require__(34);
	bitcore.encoding.Base58Check = __webpack_require__(27);
	bitcore.encoding.BufferReader = __webpack_require__(18);
	bitcore.encoding.BufferWriter = __webpack_require__(12);
	bitcore.encoding.Varint = __webpack_require__(82);

	// utilities
	bitcore.util = {};
	bitcore.util.buffer = __webpack_require__(3);
	bitcore.util.js = __webpack_require__(4);
	bitcore.util.preconditions = __webpack_require__(5);

	// errors thrown by the library
	bitcore.errors = __webpack_require__(15);

	// main bitcoin library
	bitcore.Address = __webpack_require__(17);
	bitcore.Block = __webpack_require__(55);
	bitcore.BlockHeader = __webpack_require__(56);
	bitcore.HDPrivateKey = __webpack_require__(58);
	bitcore.HDPublicKey = __webpack_require__(59);
	bitcore.Networks = __webpack_require__(19);
	bitcore.Opcode = __webpack_require__(40);
	bitcore.PrivateKey = __webpack_require__(35);
	bitcore.PublicKey = __webpack_require__(13);
	bitcore.Script = __webpack_require__(9);
	bitcore.Transaction = __webpack_require__(41);
	bitcore.URI = __webpack_require__(87);
	bitcore.Unit = __webpack_require__(44);

	// dependencies, subject to change
	bitcore.deps = {};
	bitcore.deps.bnjs = __webpack_require__(10);
	bitcore.deps.bs58 = __webpack_require__(63);
	bitcore.deps.Buffer = Buffer;
	bitcore.deps.elliptic = __webpack_require__(11);

	// Internal usage, exposed for testing/advanced tweaking
	bitcore._HDKeyCache = __webpack_require__(39);
	bitcore.Transaction.sighash = __webpack_require__(28);

	// module information
	bitcore.version = 'v'+__webpack_require__(119).version;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict';

	function Random() {
	}

	/* secure random bytes that sometimes throws an error due to lack of entropy */
	Random.getRandomBuffer = function(size) {
	  if (process.browser)
	    return Random.getRandomBufferBrowser(size);
	  else
	    return Random.getRandomBufferNode(size);
	};

	Random.getRandomBufferNode = function(size) {
	  var crypto = __webpack_require__(47);
	  return crypto.randomBytes(size);
	};

	Random.getRandomBufferBrowser = function(size) {
	  if (!window.crypto && !window.msCrypto)
	    throw new Error('window.crypto not available');

	  if (window.crypto && window.crypto.getRandomValues)
	    var crypto = window.crypto;
	  else if (window.msCrypto && window.msCrypto.getRandomValues) //internet explorer
	    var crypto = window.msCrypto;
	  else
	    throw new Error('window.crypto.getRandomValues not available');

	  var bbuf = new Uint8Array(size);
	  crypto.getRandomValues(bbuf);
	  var buf = new Buffer(bbuf);

	  return buf;
	};

	/* insecure random bytes, but it never fails */
	Random.getPseudoRandomBuffer = function(size) {
	  var b32 = 0x100000000;
	  var b = new Buffer(size);
	  var r;

	  for (var i = 0; i <= size; i++) {
	    var j = Math.floor(i / 4);
	    var k = i - j * 4;
	    if (k === 0) {
	      r = Math.random() * b32;
	      b[i] = r & 0xff;
	    } else {
	      b[i] = (r = r >>> 8) & 0xff;
	    }
	  }

	  return b;
	};

	module.exports = Random;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21), __webpack_require__(1).Buffer))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _ = __webpack_require__(2);
	var bs58 = __webpack_require__(63);
	var buffer = __webpack_require__(1);

	var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.split('');

	var Base58 = function Base58(obj) {
	  /* jshint maxcomplexity: 8 */
	  if (!(this instanceof Base58)) {
	    return new Base58(obj);
	  }
	  if (Buffer.isBuffer(obj)) {
	    var buf = obj;
	    this.fromBuffer(buf);
	  } else if (typeof obj === 'string') {
	    var str = obj;
	    this.fromString(str);
	  } else if (obj) {
	    this.set(obj);
	  }
	};

	Base58.validCharacters = function validCharacters(chars) {
	  if (buffer.Buffer.isBuffer(chars)) {
	    chars = chars.toString();
	  }
	  return _.all(_.map(chars, function(char) { return _.contains(ALPHABET, char); }));
	};

	Base58.prototype.set = function(obj) {
	  this.buf = obj.buf || this.buf || undefined;
	  return this;
	};

	Base58.encode = function(buf) {
	  if (!buffer.Buffer.isBuffer(buf)) {
	    throw new Error('Input should be a buffer');
	  }
	  return bs58.encode(buf);
	};

	Base58.decode = function(str) {
	  if (typeof str !== 'string') {
	    throw new Error('Input should be a string');
	  }
	  return new Buffer(bs58.decode(str));
	};

	Base58.prototype.fromBuffer = function(buf) {
	  this.buf = buf;
	  return this;
	};

	Base58.prototype.fromString = function(str) {
	  var buf = Base58.decode(str);
	  this.buf = buf;
	  return this;
	};

	Base58.prototype.toBuffer = function() {
	  return this.buf;
	};

	Base58.prototype.toString = function() {
	  return Base58.encode(this.buf);
	};

	module.exports = Base58;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _ = __webpack_require__(2);
	var Address = __webpack_require__(17);
	var base58check = __webpack_require__(27);
	var BN = __webpack_require__(6);
	var JSUtil = __webpack_require__(4);
	var Networks = __webpack_require__(19);
	var Point = __webpack_require__(23);
	var PublicKey = __webpack_require__(13);
	var Random = __webpack_require__(33);

	/**
	 * Instantiate a PrivateKey from a BN, Buffer and WIF.
	 *
	 * @example
	 * ```javascript
	 * // generate a new random key
	 * var key = PrivateKey();
	 *
	 * // get the associated address
	 * var address = key.toAddress();
	 *
	 * // encode into wallet export format
	 * var exported = key.toWIF();
	 *
	 * // instantiate from the exported (and saved) private key
	 * var imported = PrivateKey.fromWIF(exported);
	 * ```
	 *
	 * @param {string} data - The encoded data in various formats
	 * @param {Network|string} [network] - a {@link Network} object, or a string with the network name
	 * @returns {PrivateKey} A new valid instance of an PrivateKey
	 * @constructor
	 */
	var PrivateKey = function PrivateKey(data, network) {
	  /* jshint maxstatements: 20 */
	  /* jshint maxcomplexity: 8 */

	  if (!(this instanceof PrivateKey)) {
	    return new PrivateKey(data, network);
	  }
	  if (data instanceof PrivateKey) {
	    return data;
	  }

	  var info = this._classifyArguments(data, network);

	  // validation
	  if (!info.bn || info.bn.cmp(0) === 0){
	    throw new TypeError('Number can not be equal to zero, undefined, null or false');
	  }
	  if (!info.bn.lt(Point.getN())) {
	    throw new TypeError('Number must be less than N');
	  }
	  if (typeof(info.network) === 'undefined') {
	    throw new TypeError('Must specify the network ("livenet" or "testnet")');
	  }

	  JSUtil.defineImmutable(this, {
	    bn: info.bn,
	    compressed: info.compressed,
	    network: info.network
	  });

	  Object.defineProperty(this, 'publicKey', {
	    configurable: false,
	    enumerable: true,
	    get: this.toPublicKey.bind(this)
	  });

	  return this;

	};

	/**
	 * Internal helper to instantiate PrivateKey internal `info` object from
	 * different kinds of arguments passed to the constructor.
	 *
	 * @param {*} data
	 * @param {Network|string} [network] - a {@link Network} object, or a string with the network name
	 * @return {Object}
	 */
	PrivateKey.prototype._classifyArguments = function(data, network) {
	  /* jshint maxcomplexity: 10 */
	  var info = {
	    compressed: true,
	    network: network ? Networks.get(network) : Networks.defaultNetwork
	  };

	  // detect type of data
	  if (_.isUndefined(data) || _.isNull(data)){
	    info.bn = PrivateKey._getRandomBN();
	  } else if (data instanceof BN) {
	    info.bn = data;
	  } else if (data instanceof Buffer || data instanceof Uint8Array) {
	    info = PrivateKey._transformBuffer(data, network);
	  } else if (PrivateKey._isJSON(data)){
	    info = PrivateKey._transformJSON(data);
	  } else if (!network && Networks.get(data)) {
	    info.bn = PrivateKey._getRandomBN();
	    info.network = Networks.get(data);
	  } else if (typeof(data) === 'string'){
	    if (JSUtil.isHexa(data)) {
	      info.bn = BN(new Buffer(data, 'hex'));
	    } else {
	      info = PrivateKey._transformWIF(data, network);
	    }
	  } else {
	    throw new TypeError('First argument is an unrecognized data type.');
	  }
	  return info;
	};

	/**
	 * Internal function to get a random Big Number (BN)
	 *
	 * @returns {BN} A new randomly generated BN
	 * @private
	 */
	PrivateKey._getRandomBN = function(){
	  var condition;
	  var bn;
	  do {
	    var privbuf = Random.getRandomBuffer(32);
	    bn = BN.fromBuffer(privbuf);
	    condition = bn.lt(Point.getN());
	  } while (!condition);
	  return bn;
	};

	/**
	 * Internal function to detect if a param is a JSON string or plain object
	 *
	 * @param {*} param - value to test
	 * @returns {boolean}
	 * @private
	 */
	PrivateKey._isJSON = function(json) {
	  return JSUtil.isValidJSON(json) || (json.bn && json.network);
	};

	/**
	 * Internal function to transform a WIF Buffer into a private key
	 *
	 * @param {Buffer} buf - An WIF string
	 * @param {Network|string} [network] - a {@link Network} object, or a string with the network name
	 * @returns {Object} An object with keys: bn, network and compressed
	 * @private
	 */
	PrivateKey._transformBuffer = function(buf, network) {

	  var info = {};

	  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
	    info.compressed = true;
	  } else if (buf.length === 1 + 32) {
	    info.compressed = false;
	  } else {
	    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');
	  }

	  info.network = Networks.get(buf[0], 'privatekey');
	  if (buf[0] === Networks.livenet.privatekey) {
	    info.network = Networks.livenet;
	  } else if (buf[0] === Networks.testnet.privatekey) {
	    info.network = Networks.testnet;
	  } else {
	    throw new Error('Invalid network');
	  }

	  if (network && info.network !== Networks.get(network)) {
	    throw new TypeError('Private key network mismatch');
	  }

	  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));

	  return info;

	};

	/**
	 * Internal function to transform a WIF string into a private key
	 *
	 * @param {String} buf - An WIF string
	 * @returns {Object} An object with keys: bn, network and compressed
	 * @private
	 */
	PrivateKey._transformWIF = function(str, network) {
	  return PrivateKey._transformBuffer(base58check.decode(str), network);
	};

	/**
	 * Instantiate a PrivateKey from a JSON string
	 *
	 * @param {String} json - The JSON encoded private key string
	 * @returns {PrivateKey} A new valid instance of PrivateKey
	 */
	PrivateKey.fromJSON = function(json) {
	  if (!PrivateKey._isJSON(json)) {
	    throw new TypeError('Must be a valid JSON string or plain object');
	  }

	  return new PrivateKey(json);
	};


	/**
	 * Internal function to transform a JSON string on plain object into a private key
	 *
	 * @param {String} json - A JSON string or plain object
	 * @returns {Object} An object with keys: bn, network and compressed
	 * @private
	 */
	PrivateKey._transformJSON = function(json) {
	  if (JSUtil.isValidJSON(json)) {
	    json = JSON.parse(json);
	  }
	  var bn = BN(json.bn, 'hex');
	  return {
	    bn: bn,
	    network: json.network,
	    compressed: json.compressed
	  };
	};

	/**
	 * Instantiate a PrivateKey from a WIF string
	 *
	 * @param {String} str - The WIF encoded private key string
	 * @returns {PrivateKey} A new valid instance of PrivateKey
	 */
	PrivateKey.fromString = PrivateKey.fromWIF = function(str) {
	  return new PrivateKey(str);
	};

	/**
	 * Instantiate a PrivateKey from random bytes
	 *
	 * @param {String} [network] - Either "livenet" or "testnet"
	 * @returns {PrivateKey} A new valid instance of PrivateKey
	 */
	PrivateKey.fromRandom = function(network) {
	  var bn = PrivateKey._getRandomBN();
	  return new PrivateKey(bn, network);
	};

	/**
	 * Check if there would be any errors when initializing a PrivateKey
	 *
	 * @param {String} data - The encoded data in various formats
	 * @param {String} [network] - Either "livenet" or "testnet"
	 * @returns {null|Error} An error if exists
	 */

	PrivateKey.getValidationError = function(data, network) {
	  var error;
	  try {
	    /* jshint nonew: false */
	    new PrivateKey(data, network);
	  } catch (e) {
	    error = e;
	  }
	  return error;
	};

	/**
	 * Check if the parameters are valid
	 *
	 * @param {String} data - The encoded data in various formats
	 * @param {String} [network] - Either "livenet" or "testnet"
	 * @returns {Boolean} If the private key is would be valid
	 */
	PrivateKey.isValid = function(data, network){
	  return !PrivateKey.getValidationError(data, network);
	};

	/**
	 * Will output the PrivateKey encoded as hex string
	 *
	 * @returns {String}
	 */
	PrivateKey.prototype.toString = function() {
	  return this.toBuffer().toString('hex');
	};

	/**
	 * Will output the PrivateKey to a WIF string
	 *
	 * @returns {String} A WIP representation of the private key
	 */
	PrivateKey.prototype.toWIF = function() {
	  var network = this.network;
	  var compressed = this.compressed;

	  var buf;
	  if (compressed) {
	    buf = Buffer.concat([new Buffer([network.privatekey]),
	                         this.bn.toBuffer({size: 32}),
	                         new Buffer([0x01])]);
	  } else {
	    buf = Buffer.concat([new Buffer([network.privatekey]),
	                         this.bn.toBuffer({size: 32})]);
	  }

	  return base58check.encode(buf);
	};

	/**
	 * Will return the private key as a BN instance
	 *
	 * @returns {BN} A BN instance of the private key
	 */
	PrivateKey.prototype.toBigNumber = function(){
	  return this.bn;
	};

	/**
	 * Will return the private key as a BN buffer
	 *
	 * @returns {Buffer} A buffer of the private key
	 */
	PrivateKey.prototype.toBuffer = function(){
	  return this.bn.toBuffer();
	};

	/**
	 * Will return the corresponding public key
	 *
	 * @returns {PublicKey} A public key generated from the private key
	 */
	PrivateKey.prototype.toPublicKey = function(){
	  if (!this._pubkey) {
	    this._pubkey = PublicKey.fromPrivateKey(this);
	  }
	  return this._pubkey;
	};

	/**
	 * Will return an address for the private key
	 *
	 * @returns {Address} An address generated from the private key
	 */
	PrivateKey.prototype.toAddress = function() {
	  var pubkey = this.toPublicKey();
	  return Address.fromPublicKey(pubkey, this.network);
	};

	/**
	 * @returns {Object} A plain object representation
	 */
	PrivateKey.prototype.toObject = function toObject() {
	  return {
	    bn: this.bn.toString('hex'),
	    compressed: this.compressed,
	    network: this.network.toString()
	  };
	};

	PrivateKey.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	/**
	 * Will return a string formatted for the console
	 *
	 * @returns {String} Private key
	 */
	PrivateKey.prototype.inspect = function() {
	  var uncompressed = !this.compressed ? ', uncompressed' : '';
	  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';
	};

	module.exports = PrivateKey;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var curve = exports;

	curve.base = __webpack_require__(88);
	curve.short = __webpack_require__(91);
	curve.mont = __webpack_require__(90);
	curve.edwards = __webpack_require__(89);


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = xor;
	function xor(a, b) {
	  var len = Math.min(a.length, b.length);
	  var out = new Buffer(len);
	  var i = -1;
	  while (++i < len) {
	    out.writeUInt8(a[i] ^ b[i], i);
	  }
	  return out;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	  _cache: {},
	  _count: 0,
	  _eraseIndex: 0,
	  _usedList: {},
	  _usedIndex: {},
	  _CACHE_SIZE: 5000,

	  get: function(xkey, number, hardened) {
	    hardened = !!hardened;
	    var key = xkey + '/' + number + '/' + hardened;
	    if (this._cache[key]) {
	      this._cacheHit(key);
	      return this._cache[key];
	    }
	  },
	  set: function(xkey, number, hardened, derived) {
	    hardened = !!hardened;
	    var key = xkey + '/' + number + '/' + hardened;
	    this._cache[key] = derived;
	    this._cacheHit(key);
	  },
	  _cacheHit: function(key) {
	    if (this._usedIndex[key]) {
	      delete this._usedList[this._usedIndex[key]];
	    }
	    this._usedList[this._count] = key;
	    this._usedIndex[key] = this._count;
	    this._count++;
	    this._cacheRemove();
	  },
	  _cacheRemove: function() {
	    while (this._eraseIndex < this._count - this._CACHE_SIZE) {
	      if (this._usedList[this._eraseIndex]) {
	        var removeKey = this._usedList[this._eraseIndex];
	        delete this._usedIndex[removeKey];
	        delete this._cache[removeKey];
	      }
	      delete this._usedList[this._eraseIndex];
	      this._eraseIndex++;
	    }
	  }
	};


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _ = __webpack_require__(2);
	var $ = __webpack_require__(5);
	var BufferUtil = __webpack_require__(3);
	var JSUtil = __webpack_require__(4);

	function Opcode(num) {
	  if (!(this instanceof Opcode)) {
	    return new Opcode(num);
	  }

	  var value;

	  if (_.isNumber(num)) {
	    value = num;
	  } else if (_.isString(num)) {
	    value = Opcode.map[num];
	  } else {
	    throw new TypeError('Unrecognized num type: "' + typeof(num) + '" for Opcode');
	  }

	  JSUtil.defineImmutable(this, {
	    num: value
	  });

	  return this;
	}

	Opcode.fromBuffer = function(buf) {
	  $.checkArgument(BufferUtil.isBuffer(buf));
	  return new Opcode(Number('0x' + buf.toString('hex')));
	};

	Opcode.fromNumber = function(num) {
	  $.checkArgument(_.isNumber(num));
	  return new Opcode(num);
	};

	Opcode.fromString = function(str) {
	  $.checkArgument(_.isString(str));
	  var value = Opcode.map[str];
	  if (typeof value === 'undefined') {
	    throw new TypeError('Invalid opcodestr');
	  }
	  return new Opcode(value);
	};

	Opcode.prototype.toHex = function() {
	  return this.num.toString(16);
	};

	Opcode.prototype.toBuffer = function() {
	  return new Buffer(this.toHex(), 'hex');
	};

	Opcode.prototype.toNumber = function() {
	  return this.num;
	};

	Opcode.prototype.toString = function() {
	  var str = Opcode.reverseMap[this.num];
	  if (typeof str === 'undefined') {
	    throw new Error('Opcode does not have a string representation');
	  }
	  return str;
	};

	Opcode.smallInt = function(n) {
	  $.checkArgument(n >= 0 && n <= 16, 'Invalid Argument: n must be between 0 and 16');
	  if (n === 0) {
	    return Opcode('OP_0');
	  }
	  return new Opcode(Opcode.map.OP_1 + n - 1);
	};

	Opcode.map = {
	  // push value
	  OP_FALSE: 0,
	  OP_0: 0,
	  OP_PUSHDATA1: 76,
	  OP_PUSHDATA2: 77,
	  OP_PUSHDATA4: 78,
	  OP_1NEGATE: 79,
	  OP_RESERVED: 80,
	  OP_TRUE: 81,
	  OP_1: 81,
	  OP_2: 82,
	  OP_3: 83,
	  OP_4: 84,
	  OP_5: 85,
	  OP_6: 86,
	  OP_7: 87,
	  OP_8: 88,
	  OP_9: 89,
	  OP_10: 90,
	  OP_11: 91,
	  OP_12: 92,
	  OP_13: 93,
	  OP_14: 94,
	  OP_15: 95,
	  OP_16: 96,

	  // control
	  OP_NOP: 97,
	  OP_VER: 98,
	  OP_IF: 99,
	  OP_NOTIF: 100,
	  OP_VERIF: 101,
	  OP_VERNOTIF: 102,
	  OP_ELSE: 103,
	  OP_ENDIF: 104,
	  OP_VERIFY: 105,
	  OP_RETURN: 106,

	  // stack ops
	  OP_TOALTSTACK: 107,
	  OP_FROMALTSTACK: 108,
	  OP_2DROP: 109,
	  OP_2DUP: 110,
	  OP_3DUP: 111,
	  OP_2OVER: 112,
	  OP_2ROT: 113,
	  OP_2SWAP: 114,
	  OP_IFDUP: 115,
	  OP_DEPTH: 116,
	  OP_DROP: 117,
	  OP_DUP: 118,
	  OP_NIP: 119,
	  OP_OVER: 120,
	  OP_PICK: 121,
	  OP_ROLL: 122,
	  OP_ROT: 123,
	  OP_SWAP: 124,
	  OP_TUCK: 125,

	  // splice ops
	  OP_CAT: 126,
	  OP_SUBSTR: 127,
	  OP_LEFT: 128,
	  OP_RIGHT: 129,
	  OP_SIZE: 130,

	  // bit logic
	  OP_INVERT: 131,
	  OP_AND: 132,
	  OP_OR: 133,
	  OP_XOR: 134,
	  OP_EQUAL: 135,
	  OP_EQUALVERIFY: 136,
	  OP_RESERVED1: 137,
	  OP_RESERVED2: 138,

	  // numeric
	  OP_1ADD: 139,
	  OP_1SUB: 140,
	  OP_2MUL: 141,
	  OP_2DIV: 142,
	  OP_NEGATE: 143,
	  OP_ABS: 144,
	  OP_NOT: 145,
	  OP_0NOTEQUAL: 146,

	  OP_ADD: 147,
	  OP_SUB: 148,
	  OP_MUL: 149,
	  OP_DIV: 150,
	  OP_MOD: 151,
	  OP_LSHIFT: 152,
	  OP_RSHIFT: 153,

	  OP_BOOLAND: 154,
	  OP_BOOLOR: 155,
	  OP_NUMEQUAL: 156,
	  OP_NUMEQUALVERIFY: 157,
	  OP_NUMNOTEQUAL: 158,
	  OP_LESSTHAN: 159,
	  OP_GREATERTHAN: 160,
	  OP_LESSTHANOREQUAL: 161,
	  OP_GREATERTHANOREQUAL: 162,
	  OP_MIN: 163,
	  OP_MAX: 164,

	  OP_WITHIN: 165,

	  // crypto
	  OP_RIPEMD160: 166,
	  OP_SHA1: 167,
	  OP_SHA256: 168,
	  OP_HASH160: 169,
	  OP_HASH256: 170,
	  OP_CODESEPARATOR: 171,
	  OP_CHECKSIG: 172,
	  OP_CHECKSIGVERIFY: 173,
	  OP_CHECKMULTISIG: 174,
	  OP_CHECKMULTISIGVERIFY: 175,

	  // expansion
	  OP_NOP1: 176,
	  OP_NOP2: 177,
	  OP_NOP3: 178,
	  OP_NOP4: 179,
	  OP_NOP5: 180,
	  OP_NOP6: 181,
	  OP_NOP7: 182,
	  OP_NOP8: 183,
	  OP_NOP9: 184,
	  OP_NOP10: 185,

	  // template matching params
	  OP_PUBKEYHASH: 253,
	  OP_PUBKEY: 254,
	  OP_INVALIDOPCODE: 255
	};

	Opcode.reverseMap = [];

	for (var k in Opcode.map) {
	  Opcode.reverseMap[Opcode.map[k]] = k;
	}

	// Easier access to opcodes
	_.extend(Opcode, Opcode.map);

	/**
	 * @returns true if opcode is one of OP_0, OP_1, ..., OP_16
	 */
	Opcode.isSmallIntOp = function(opcode) {
	  if (opcode instanceof Opcode) {
	    opcode = opcode.toNumber();
	  }
	  return ((opcode === Opcode.map.OP_0) ||
	    ((opcode >= Opcode.map.OP_1) && (opcode <= Opcode.map.OP_16)));
	};

	module.exports = Opcode;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(61);

	module.exports.Input = __webpack_require__(42);
	module.exports.Output = __webpack_require__(24);
	module.exports.UnspentOutput = __webpack_require__(62);


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(43);

	module.exports.PublicKeyHash = __webpack_require__(86);
	module.exports.MultiSigScriptHash = __webpack_require__(85);


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);
	var errors = __webpack_require__(15);
	var BufferWriter = __webpack_require__(12);
	var buffer = __webpack_require__(1);
	var BufferUtil = __webpack_require__(3);
	var JSUtil = __webpack_require__(4);
	var Script = __webpack_require__(9);
	var Sighash = __webpack_require__(28);
	var Output = __webpack_require__(24);

	function Input(params) {
	  if (!(this instanceof Input)) {
	    return new Input(params);
	  }
	  if (params) {
	    return this._fromObject(params);
	  }
	}

	Object.defineProperty(Input.prototype, 'script', {
	  configurable: false,
	  writeable: false,
	  enumerable: true,
	  get: function() {
	    if (!this._script) {
	      this._script = new Script(this._scriptBuffer);
	    }
	    return this._script;
	  }
	});

	Input.prototype._fromObject = function(params) {
	  if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {
	    params.prevTxId = new buffer.Buffer(params.prevTxId, 'hex');
	  }
	  this.output = params.output ?
	     (params.output instanceof Output ? params.output : new Output(params.output)) : undefined;
	  this.prevTxId = params.prevTxId;
	  this.outputIndex = params.outputIndex;
	  this.sequenceNumber = params.sequenceNumber;
	  if (!_.isUndefined(params.script) || !_.isUndefined(params.scriptBuffer)) {
	    this.setScript(_.isUndefined(params.script) ? params.scriptBuffer : params.script);
	  } else {
	    throw new errors.Transaction.Input.MissingScript();
	  }
	  return this;
	};

	Input.prototype.toObject = function toObject() {
	  return {
	    prevTxId: this.prevTxId.toString('hex'),
	    outputIndex: this.outputIndex,
	    sequenceNumber: this.sequenceNumber,
	    script: this.script.toString(),
	    output: this.output ? this.output.toObject() : undefined
	  };
	};

	Input.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	Input.fromJSON = function(json) {
	  if (JSUtil.isValidJSON(json)) {
	    json = JSON.parse(json);
	  }
	  return new Input({
	    output: json.output ? new Output(json.output) : undefined,
	    prevTxId: json.prevTxId || json.txidbuf,
	    outputIndex: _.isUndefined(json.outputIndex) ? json.txoutnum : json.outputIndex,
	    sequenceNumber: json.sequenceNumber || json.seqnum,
	    scriptBuffer: new Script(json.script, 'hex')
	  });
	};

	Input.fromBufferReader = function(br) {
	  var input = new Input();
	  input.prevTxId = br.readReverse(32);
	  input.outputIndex = br.readUInt32LE();
	  input._scriptBuffer = br.readVarLengthBuffer();
	  input.sequenceNumber = br.readUInt32LE();
	  return input;
	};

	Input.prototype.toBufferWriter = function(writer) {
	  if (!writer) {
	    writer = new BufferWriter();
	  }
	  writer.writeReverse(this.prevTxId);
	  writer.writeUInt32LE(this.outputIndex);
	  var script = this._scriptBuffer;
	  writer.writeVarintNum(script.length);
	  writer.write(script);
	  writer.writeUInt32LE(this.sequenceNumber);
	  return writer;
	};

	Input.prototype.setScript = function(script) {
	  if (script instanceof Script) {
	    this._script = script;
	    this._scriptBuffer = script.toBuffer();
	  } else if (_.isString(script)) {
	    this._script = new Script(script);
	    this._scriptBuffer = this._script.toBuffer();
	  } else if (BufferUtil.isBuffer(script)) {
	    this._script = null;
	    this._scriptBuffer = new buffer.Buffer(script);
	  } else {
	    throw new TypeError('Invalid Argument');
	  }
	  return this;
	};

	/**
	 * Retrieve signatures for the provided PrivateKey.
	 *
	 * @param {Transaction} transaction - the transaction to be signed
	 * @param {PrivateKey} privateKey - the private key to use when signing
	 * @param {number} inputIndex - the index of this input in the provided transaction
	 * @param {number} sigType - defaults to Signature.SIGHASH_ALL
	 * @param {Buffer} addressHash - if provided, don't calculate the hash of the
	 *     public key associated with the private key provided
	 * @abstract
	 */
	Input.prototype.getSignatures = function() {
	  throw new errors.AbstractMethodInvoked('Input#getSignatures');
	};

	Input.prototype.isFullySigned = function() {
	  throw new errors.AbstractMethodInvoked('Input#isFullySigned');
	};

	Input.prototype.addSignature = function() {
	  throw new errors.AbstractMethodInvoked('Input#addSignature');
	};

	Input.prototype.clearSignatures = function() {
	  throw new errors.AbstractMethodInvoked('Input#clearSignatures');
	};

	Input.prototype.isValidSignature = function(transaction, signature) {
	  // FIXME: Refactor signature so this is not necessary
	  signature.signature.nhashtype = signature.sigtype;
	  return Sighash.verify(
	    transaction,
	    signature.signature,
	    signature.publicKey,
	    signature.inputIndex,
	    this.output.script
	  );
	};

	/**
	 * @returns true if this is a coinbase input (represents no input)
	 */
	Input.prototype.isNull = function() {
	  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' &&
	    this.outputIndex === 0xffffffff;
	};

	Input.prototype._estimateSize = function() {
	  var bufferWriter = new BufferWriter();
	  this.toBufferWriter(bufferWriter);
	  return bufferWriter.toBuffer().length;
	};

	module.exports = Input;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);

	var errors = __webpack_require__(15);
	var JSUtil = __webpack_require__(4);

	var UNITS = {
	  'BTC'      : [1e8, 8],
	  'mBTC'     : [1e5, 5],
	  'uBTC'     : [1e2, 2],
	  'bits'     : [1e2, 2],
	  'satoshis' : [1, 0]
	};

	/**
	 * Utility for handling and converting bitcoins units. The supported units are
	 * BTC, mBTC, bits (also named uBTC) and satoshis. A unit instance can be created with an
	 * amount and a unit code, or alternatively using static methods like {fromBTC}.
	 * It also allows to be created from a fiat amount and the exchange rate, or
	 * alternatively using the {fromFiat} static method.
	 * You can consult for different representation of a unit instance using it's
	 * {to} method, the fixed unit methods like {toSatoshis} or alternatively using
	 * the unit accessors. It also can be converted to a fiat amount by providing the
	 * corresponding BTC/fiat exchange rate.
	 *
	 * @example
	 * ```javascript
	 * var sats = Unit.fromBTC(1.3).toSatoshis();
	 * var mili = Unit.fromBits(1.3).to(Unit.mBTC);
	 * var bits = Unit.fromFiat(1.3, 350).bits;
	 * var btc = new Unit(1.3, Unit.bits).BTC;
	 * ```
	 *
	 * @param {Number} amount - The amount to be represented
	 * @param {String|Number} code - The unit of the amount or the exchange rate
	 * @returns {Unit} A new instance of an Unit
	 * @constructor
	 */
	function Unit(amount, code) {
	  if (!(this instanceof Unit)) {
	    return new Unit(amount, code);
	  }

	  // convert fiat to BTC
	  if (_.isNumber(code)) {
	    if (code <= 0) {
	      throw new errors.Unit.InvalidRate(code);
	    }
	    amount = amount / code;
	    code = Unit.BTC;
	  }

	  this._value = this._from(amount, code);

	  var self = this;
	  var defineAccesor = function(key) {
	    Object.defineProperty(self, key, {
	      get: function() { return self.to(key); },
	      enumerable: true,
	    });
	  };

	  Object.keys(UNITS).forEach(defineAccesor);
	}

	Object.keys(UNITS).forEach(function(key) {
	  Unit[key] = key;
	});

	/**
	 * Returns a Unit instance created from JSON string or object
	 *
	 * @param {String|Object} json - JSON with keys: amount and code
	 * @returns {Unit} A Unit instance
	 */
	Unit.fromJSON = function fromJSON(json){
	  if (JSUtil.isValidJSON(json)) {
	    json = JSON.parse(json);
	  }
	  return new Unit(json.amount, json.code);
	};

	/**
	 * Returns a Unit instance created from an amount in BTC
	 *
	 * @param {Number} amount - The amount in BTC
	 * @returns {Unit} A Unit instance
	 */
	Unit.fromBTC = function(amount) {
	  return new Unit(amount, Unit.BTC);
	};

	/**
	 * Returns a Unit instance created from an amount in mBTC
	 *
	 * @param {Number} amount - The amount in mBTC
	 * @returns {Unit} A Unit instance
	 */
	Unit.fromMilis = function(amount) {
	  return new Unit(amount, Unit.mBTC);
	};

	/**
	 * Returns a Unit instance created from an amount in bits
	 *
	 * @param {Number} amount - The amount in bits
	 * @returns {Unit} A Unit instance
	 */
	Unit.fromMicros = Unit.fromBits = function(amount) {
	  return new Unit(amount, Unit.bits);
	};

	/**
	 * Returns a Unit instance created from an amount in satoshis
	 *
	 * @param {Number} amount - The amount in satoshis
	 * @returns {Unit} A Unit instance
	 */
	Unit.fromSatoshis = function(amount) {
	  return new Unit(amount, Unit.satoshis);
	};

	/**
	 * Returns a Unit instance created from a fiat amount and exchange rate.
	 *
	 * @param {Number} amount - The amount in fiat
	 * @param {Number} rate - The exchange rate BTC/fiat
	 * @returns {Unit} A Unit instance
	 */
	Unit.fromFiat = function(amount, rate) {
	  return new Unit(amount, rate);
	};

	Unit.prototype._from = function(amount, code) {
	  if (!UNITS[code]) {
	    throw new errors.Unit.UnknownCode(code);
	  }
	  return parseInt((amount * UNITS[code][0]).toFixed());
	};

	/**
	 * Returns the value represented in the specified unit
	 *
	 * @param {String|Number} code - The unit code or exchange rate
	 * @returns {Number} The converted value
	 */
	Unit.prototype.to = function(code) {
	  if (_.isNumber(code)) {
	    if (code <= 0) {
	      throw new errors.Unit.InvalidRate(code);
	    }
	    return parseFloat((this.BTC * code).toFixed(2));
	  }

	  if (!UNITS[code]) {
	    throw new errors.Unit.UnknownCode(code);
	  }

	  var value = this._value / UNITS[code][0];
	  return parseFloat(value.toFixed(UNITS[code][1]));
	};

	/**
	 * Returns the value represented in BTC
	 *
	 * @returns {Number} The value converted to BTC
	 */
	Unit.prototype.toBTC = function() {
	  return this.to(Unit.BTC);
	};

	/**
	 * Returns the value represented in mBTC
	 *
	 * @returns {Number} The value converted to mBTC
	 */
	Unit.prototype.toMilis = function() {
	  return this.to(Unit.mBTC);
	};

	/**
	 * Returns the value represented in bits
	 *
	 * @returns {Number} The value converted to bits
	 */
	Unit.prototype.toMicros = Unit.prototype.toBits = function() {
	  return this.to(Unit.bits);
	};

	/**
	 * Returns the value represented in satoshis
	 *
	 * @returns {Number} The value converted to satoshis
	 */
	Unit.prototype.toSatoshis = function() {
	  return this.to(Unit.satoshis);
	};

	/**
	 * Returns the value represented in fiat
	 *
	 * @param {string} rate - The exchange rate between BTC/currency
	 * @returns {Number} The value converted to satoshis
	 */
	Unit.prototype.atRate = function(rate) {
	  return this.to(rate);
	};

	/**
	 * Returns a the string representation of the value in satoshis
	 *
	 * @returns {String} the value in satoshis
	 */
	Unit.prototype.toString = function() {
	  return this.satoshis + ' satoshis';
	};

	/**
	 * Returns a plain object representation of the Unit
	 *
	 * @returns {Object} An object with the keys: amount and code
	 */
	Unit.prototype.toObject = function toObject() {
	  return {
	    amount: this.BTC,
	    code: Unit.BTC
	  };
	};

	Unit.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	/**
	 * Returns a string formatted for the console
	 *
	 * @returns {String} the value in satoshis
	 */
	Unit.prototype.inspect = function() {
	  return '<Unit: ' + this.toString() + '>';
	};

	module.exports = Unit;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {module.exports = WordArray

	/** An array of 32-bit words. */
	function WordArray(words, sigBytes) {
	  this.words = words || [];

	  if (sigBytes != undefined) {
	      this.sigBytes = sigBytes;
	  } else {
	      this.sigBytes = this.words.length * 4;
	  }
	}

	/**
	 * Concatenates a word array to this word array.
	 *
	 * @param {WordArray} wordArray The word array to append.
	 *
	 * @return {WordArray} This word array.
	 *
	 * @example
	 *
	 *     wordArray1.concat(wordArray2);
	 */
	WordArray.prototype.concat = function (wordArray) {
	  if (Buffer.isBuffer(wordArray))
	    wordArray = WordArray.fromBuffer(wordArray)

	        // Shortcuts
	        var thisWords = this.words;
	        var thatWords = wordArray.words;
	        var thisSigBytes = this.sigBytes;
	        var thatSigBytes = wordArray.sigBytes;

	        // Clamp excess bits
	        this.clamp();

	        // Concat
	        if (thisSigBytes % 4) {
	            // Copy one byte at a time
	            for (var i = 0; i < thatSigBytes; i++) {
	                var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	            }
	        } else if (thatWords.length > 0xffff) {
	            // Copy one word at a time
	            for (var i = 0; i < thatSigBytes; i += 4) {
	                thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	            }
	        } else {
	            // Copy all words at once
	            thisWords.push.apply(thisWords, thatWords);
	        }
	        this.sigBytes += thatSigBytes;

	        // Chainable
	        return this;
	}

	/**
	 * Removes insignificant bits.
	 *
	 */
	WordArray.prototype.clamp = function () {
	  // Shortcuts
	  var words = this.words;
	  var sigBytes = this.sigBytes;

	  // Clamp
	  words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	  words.length = Math.ceil(sigBytes / 4);
	}

	WordArray.prototype.clone = function() {
	  var wa = new WordArray(this.words.slice(0))
	  return wa
	}

	WordArray.prototype.toBuffer = function() {
	  var buf = new Buffer(this.words.length * 4)
	  for (var i = 0; i < this.words.length; ++i) {
	    var w = this.words[i]
	    buf.writeUInt32BE(w, i*4, true)
	  }
	  return buf 
	}

	WordArray.fromBuffer = function(buf) {
	  var len = buf.length
	  var dif = len % 4
	  var w = []

	  if (!process.browser) {
	    for (var i = 0; i < len; i += 4) {
	      var n = buf.readUInt32BE(i, true) 
	      w.push(n)
	    }
	    return new WordArray(w, buf.length)
	  } else { //bug in browserify / buffer
	    for (var i = 0; i < len - dif; i += 4) {
	      var n = buf.readUInt32BE(i)
	      w.push(n)
	    }
	    var lw = 0x0
	    var off = len - dif
	    for (var j = 0; j < dif; j += 1) {
	      lw |=  (buf.readUInt8(off + j) << ((3-j)*8))
	    }
	    if (dif > 0)
	      w.push(lw)
	    return new WordArray(w, buf.length)
	  } 
	}


	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer, __webpack_require__(21)))

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(138)

	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}

	exports.createHash = __webpack_require__(67)

	exports.createHmac = __webpack_require__(124)

	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}

	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}

	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}

	var p = __webpack_require__(137)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync
	__webpack_require__(129)(exports, module.exports);

	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var uint_max = Math.pow(2, 32);
	function fixup_uint32(x) {
	    var ret, x_pos;
	    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
	    return ret;
	}
	function scrub_vec(v) {
	  var i, _i, _ref;
	  for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	    v[i] = 0;
	  }
	  return false;
	}

	function Global() {
	  var i;
	  this.SBOX = [];
	  this.INV_SBOX = [];
	  this.SUB_MIX = (function() {
	    var _i, _results;
	    _results = [];
	    for (i = _i = 0; _i < 4; i = ++_i) {
	      _results.push([]);
	    }
	    return _results;
	  })();
	  this.INV_SUB_MIX = (function() {
	    var _i, _results;
	    _results = [];
	    for (i = _i = 0; _i < 4; i = ++_i) {
	      _results.push([]);
	    }
	    return _results;
	  })();
	  this.init();
	  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
	}

	Global.prototype.init = function() {
	  var d, i, sx, t, x, x2, x4, x8, xi, _i;
	  d = (function() {
	    var _i, _results;
	    _results = [];
	    for (i = _i = 0; _i < 256; i = ++_i) {
	      if (i < 128) {
	        _results.push(i << 1);
	      } else {
	        _results.push((i << 1) ^ 0x11b);
	      }
	    }
	    return _results;
	  })();
	  x = 0;
	  xi = 0;
	  for (i = _i = 0; _i < 256; i = ++_i) {
	    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	    this.SBOX[x] = sx;
	    this.INV_SBOX[sx] = x;
	    x2 = d[x];
	    x4 = d[x2];
	    x8 = d[x4];
	    t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
	    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
	    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
	    this.SUB_MIX[3][x] = t;
	    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
	    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
	    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
	    this.INV_SUB_MIX[3][sx] = t;
	    if (x === 0) {
	      x = xi = 1;
	    } else {
	      x = x2 ^ d[d[d[x8 ^ x2]]];
	      xi ^= d[d[xi]];
	    }
	  }
	  return true;
	};

	var G = new Global();


	AES.blockSize = 4 * 4;

	AES.prototype.blockSize = AES.blockSize;

	AES.keySize = 256 / 8;

	AES.prototype.keySize = AES.keySize;

	AES.ivSize = AES.blockSize;

	AES.prototype.ivSize = AES.ivSize;

	 function bufferToArray(buf) {
	  var len = buf.length/4;
	  var out = new Array(len);
	  var i = -1;
	  while (++i < len) {
	    out[i] = buf.readUInt32BE(i * 4);
	  }
	  return out;
	 }
	function AES(key) {
	  this._key = bufferToArray(key);
	  this._doReset();
	}

	AES.prototype._doReset = function() {
	  var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;
	  keyWords = this._key;
	  keySize = keyWords.length;
	  this._nRounds = keySize + 6;
	  ksRows = (this._nRounds + 1) * 4;
	  this._keySchedule = [];
	  for (ksRow = _i = 0; 0 <= ksRows ? _i < ksRows : _i > ksRows; ksRow = 0 <= ksRows ? ++_i : --_i) {
	    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
	  }
	  this._invKeySchedule = [];
	  for (invKsRow = _j = 0; 0 <= ksRows ? _j < ksRows : _j > ksRows; invKsRow = 0 <= ksRows ? ++_j : --_j) {
	    ksRow = ksRows - invKsRow;
	    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
	    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];
	  }
	  return true;
	};

	AES.prototype.encryptBlock = function(M) {
	  M = bufferToArray(new Buffer(M));
	  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX);
	  var buf = new Buffer(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[1], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[3], 12);
	  return buf;
	};

	AES.prototype.decryptBlock = function(M) {
	  M = bufferToArray(new Buffer(M));
	  var temp = [M[3], M[1]];
	  M[1] = temp[0];
	  M[3] = temp[1];
	  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
	  var buf = new Buffer(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[3], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[1], 12);
	  return buf;
	};

	AES.prototype.scrub = function() {
	  scrub_vec(this._keySchedule);
	  scrub_vec(this._invKeySchedule);
	  scrub_vec(this._key);
	};

	AES.prototype._doCryptBlock = function(M, keySchedule, SUB_MIX, SBOX) {
	  var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;

	  s0 = M[0] ^ keySchedule[0];
	  s1 = M[1] ^ keySchedule[1];
	  s2 = M[2] ^ keySchedule[2];
	  s3 = M[3] ^ keySchedule[3];
	  ksRow = 4;
	  for (round = _i = 1, _ref = this._nRounds; 1 <= _ref ? _i < _ref : _i > _ref; round = 1 <= _ref ? ++_i : --_i) {
	    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
	    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
	    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
	    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
	    s0 = t0;
	    s1 = t1;
	    s2 = t2;
	    s3 = t3;
	  }
	  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
	  return [
	    fixup_uint32(t0),
	    fixup_uint32(t1),
	    fixup_uint32(t2),
	    fixup_uint32(t3)
	  ];

	};




	  exports.AES = AES;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Transform = __webpack_require__(31).Transform;
	var inherits = __webpack_require__(37);

	module.exports = CipherBase;
	inherits(CipherBase, Transform);
	function CipherBase() {
	  Transform.call(this);
	}
	CipherBase.prototype.update = function (data, inputEnd, outputEnc) {
	  this.write(data, inputEnd);
	  var outData = new Buffer('');
	  var chunk;
	  while ((chunk = this.read())) {
	    outData = Buffer.concat([outData, chunk]);
	  }
	  if (outputEnc) {
	    outData = outData.toString(outputEnc);
	  }
	  return outData;
	};
	CipherBase.prototype.final = function (outputEnc) {
	  this.end();
	  var outData = new Buffer('');
	  var chunk;
	  while ((chunk = this.read())) {
	    outData = Buffer.concat([outData, chunk]);
	  }
	  if (outputEnc) {
	    outData = outData.toString(outputEnc);
	  }
	  return outData;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	exports['aes-128-ecb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	};
	exports['aes-192-ecb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	};
	exports['aes-256-ecb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	};
	exports['aes-128-cbc'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	};
	exports['aes-192-cbc'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	};
	exports['aes-256-cbc'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	};
	exports['aes128'] = exports['aes-128-cbc'];
	exports['aes192'] = exports['aes-192-cbc'];
	exports['aes256'] = exports['aes-256-cbc'];
	exports['aes-128-cfb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	};
	exports['aes-192-cfb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	};
	exports['aes-256-cfb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	};
	exports['aes-128-ofb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	};
	exports['aes-192-ofb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	};
	exports['aes-256-ofb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	};
	exports['aes-128-ctr'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	};
	exports['aes-192-ctr'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	};
	exports['aes-256-ctr'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(22);

	/*<replacement>*/
	var util = __webpack_require__(29);
	util.inherits = __webpack_require__(30);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(1).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(29);
	util.inherits = __webpack_require__(30);
	/*</replacement>*/

	var Stream = __webpack_require__(31);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(22);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(22);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	/**
	 * @namespace P2P.Message
	 */
	/* jshint curly: false */

	var Buffers = __webpack_require__(65);
	var Put = __webpack_require__(108);
	var util = __webpack_require__(16);

	var bitcore = __webpack_require__(32);

	var BlockHeaderModel = bitcore.BlockHeader;
	var BlockModel = bitcore.Block;
	var BufferReader = bitcore.encoding.BufferReader;
	var BufferUtil = bitcore.util.buffer;
	var Hash = bitcore.crypto.Hash;
	var Random = bitcore.crypto.Random;
	var TransactionModel = bitcore.Transaction;

	var CONNECTION_NONCE = Random.getPseudoRandomBuffer(8);
	var PROTOCOL_VERSION = 70000;

	/**
	 * Static helper for consuming a data buffer until the next message.
	 *
	 * @name P2P.Message#parseMessage
	 * @param{Network} network - the network object
	 * @param{Buffer} dataBuffer - the buffer to read from
	 * @returns{Message|undefined} A message or undefined if there is nothing to read.
	 */
	var parseMessage = function(network, dataBuffer) {
	  if (dataBuffer.length < 20) return;

	  // Search the next magic number
	  if (!discardUntilNextMessage(network, dataBuffer)) return;

	  var PAYLOAD_START = 16;
	  var payloadLen = (dataBuffer.get(PAYLOAD_START)) +
	    (dataBuffer.get(PAYLOAD_START + 1) << 8) +
	    (dataBuffer.get(PAYLOAD_START + 2) << 16) +
	    (dataBuffer.get(PAYLOAD_START + 3) << 24);

	  var messageLength = 24 + payloadLen;
	  if (dataBuffer.length < messageLength) return;

	  var command = dataBuffer.slice(4, 16).toString('ascii').replace(/\0+$/, '');
	  var payload = dataBuffer.slice(24, messageLength);
	  var checksum = dataBuffer.slice(20, 24);

	  var checksumConfirm = Hash.sha256sha256(payload).slice(0, 4);
	  if (!BufferUtil.equals(checksumConfirm, checksum)) {
	    dataBuffer.skip(messageLength);
	    return;
	  }

	  dataBuffer.skip(messageLength);
	  return Message.buildMessage(command, payload);
	};

	module.exports.parseMessage = parseMessage;

	/**
	 * @desc Internal function that discards data until another message is found.
	 * @name P2P.Message#discardUntilNextMessage
	 */
	function discardUntilNextMessage(network, dataBuffer) {
	  var magicNumber = network.networkMagic;

	  var i = 0;
	  for (;;) {
	    // check if it's the beginning of a new message
	    var packageNumber = dataBuffer.slice(0, 4);
	    if (BufferUtil.equals(packageNumber, magicNumber)) {
	      dataBuffer.skip(i);
	      return true;
	    }

	    // did we reach the end of the buffer?
	    if (i > (dataBuffer.length - 4)) {
	      dataBuffer.skip(i);
	      return false;
	    }

	    i++; // continue scanning
	  }
	}

	/**
	 * Abstract Message that knows how to parse and serialize itself.
	 * Concret subclases should implement {fromBuffer} and {getPayload} methods.
	 * @name P2P.Message
	 */
	function Message() {}

	/**
	 * @value
	 * @name P2P.Message.COMMANDS
	 */
	Message.COMMANDS = {};

	/**
	 * Look up a message type by command name and instantiate the correct Message
	 * @name P2P.Message#buildMessage
	 */
	Message.buildMessage = function(command, payload) {
	  try {
	    var CommandClass = Message.COMMANDS[command];
	    return new CommandClass().fromBuffer(payload);
	  } catch (err) {
	    console.log('Error while parsing message', err);
	  }
	};

	/**
	 * Parse instance state from buffer.
	 *
	 * @param{Buffer} payload - the buffer to read from
	 * @returns{Message} The same message instance
	 */
	Message.prototype.fromBuffer = function(payload) {
	  /* jshint unused: false */
	  return this;
	};

	/**
	 * Serialize the payload into a buffer.
	 *
	 * @returns{Buffer} the serialized payload
	 */
	Message.prototype.getPayload = function() {
	  return BufferUtil.EMPTY_BUFFER;
	};

	/**
	 * Serialize the message into a buffer.
	 *
	 * @returns{Buffer} the serialized message
	 */
	Message.prototype.serialize = function(network) {
	  var magic = network.networkMagic;
	  var commandBuf = new Buffer(this.command, 'ascii');
	  if (commandBuf.length > 12) throw 'Command name too long';

	  var payload = this.getPayload();
	  var checksum = Hash.sha256sha256(payload).slice(0, 4);

	  // -- HEADER --
	  var message = new Put();
	  message.put(magic);
	  message.put(commandBuf);
	  message.pad(12 - commandBuf.length); // zero-padded
	  message.word32le(payload.length);
	  message.put(checksum);

	  // -- BODY --
	  message.put(payload);

	  return message.buffer();
	};

	module.exports.Message = Message;

	/**
	 * The version message(`ver`) is used on connection creation, to advertise
	 * the type of node.The remote node will respond with its version, and no
	 * communication is possible until both peers have exchanged their versions.
	 * By default, bitcore advertises itself as named `bitcore:0.8`.
	 *
	 * @name P2P.Message.Version
	 * @param{string} subversion - version of the client
	 * @param{Buffer} nonce - a random 8 bytes buffer
	 */
	function Version(subversion, nonce) {
	  var packageInfo = __webpack_require__(120);
	  this.command = 'version';
	  this.version = PROTOCOL_VERSION;
	  this.subversion = subversion || '/bitcore:' + packageInfo.version + '/';
	  this.nonce = nonce || CONNECTION_NONCE;
	}
	util.inherits(Version, Message);

	Version.prototype.fromBuffer = function(payload) {
	  var parser = new BufferReader(payload);

	  /**
	   * @type {number}
	   * @desc The version of the bitcoin protocol
	   */
	  this.version = parser.readUInt32LE();
	  /**
	   * @type {BN}
	   * @desc A mapbit with service bits: what features are supported by the peer
	   */
	  this.services = parser.readUInt64LEBN();
	  /**
	   * @type {BN}
	   * @desc The time this message was sent
	   */
	  this.timestamp = parser.readUInt64LEBN();
	  /**
	   * @type {Buffer}
	   * @desc IPv4/6 address of the interface used to connect to this peer
	   */
	  this.addr_me = parser.read(26);
	  /**
	   * @type {Buffer}
	   * @desc IPv4/6 address of the peer
	   */
	  this.addr_you = parser.read(26);
	  /**
	   * @type {Buffer}
	   * @desc A random number
	   */
	  this.nonce = parser.read(8);
	  /**
	   * @desc A random number
	   * @type {string}
	   */
	  this.subversion = parser.readVarintBuf().toString();
	  /**
	   * @desc The height of the last block accepted in the blockchain by this peer
	   * @type {number}
	   */
	  this.start_height = parser.readUInt32LE();

	  return this;
	};

	Version.prototype.getPayload = function() {
	  var put = new Put();
	  put.word32le(this.version); // version
	  put.word64le(1); // services
	  put.word64le(Math.round(new Date().getTime() / 1000)); // timestamp
	  put.pad(26); // addr_me
	  put.pad(26); // addr_you
	  put.put(this.nonce);
	  put.varint(this.subversion.length);
	  put.put(new Buffer(this.subversion, 'ascii'));
	  put.word32le(0);

	  return put.buffer();
	};

	module.exports.Version = Message.COMMANDS.version = Version;

	/**
	 * From the bitcoin protocol spec: "Allows a node to advertise its knowledge of
	 * one or more objects. It can be received unsolicited, or in reply to
	 * getblocks.".
	 *
	 * @name P2P.Message.Inventory
	 * @param{Array} inventory - reported elements
	 */
	function Inventory(inventory) {
	  this.command = 'inv';
	  /**
	   * @name P2P.Message.Inventory.inventory
	   * @desc An array of objects with `{type: int, hash: buffer}` signature
	   * @type {Array.Buffer}
	   */
	  this.inventory = inventory || [];
	}
	util.inherits(Inventory, Message);

	Inventory.prototype.fromBuffer = function(payload) {
	  var parser = new BufferReader(payload);
	  var count = parser.readVarintNum();
	  for (var i = 0; i < count; i++) {
	    this.inventory.push({
	      type: parser.readUInt32LE(),
	      hash: parser.read(32)
	    });
	  }

	  return this;
	};

	Inventory.prototype.getPayload = function() {
	  var put = new Put();
	  
	  put.varint(this.inventory.length);
	  this.inventory.forEach(function(value) {
	    put.word32le(value.type);
	    put.put(value.hash);
	  });
	  
	  return put.buffer();
	};

	module.exports.Inventory = Message.COMMANDS.inv = Inventory;

	/**
	 * getdata is used in response to inv, to retrieve the content of a specific
	 * object, and is usually sent after receiving an inv packet, after filtering
	 * known elements. It can be used to retrieve transactions, but only if they
	 * are in the memory pool or relay set - arbitrary access to transactions in the
	 * chain is not allowed to avoid having clients start to depend on nodes having
	 * full transaction indexes (which modern nodes do not).
	 *
	 * (taken from bitcoin's protocol spec)
	 *
	 * @name P2P.Message.GetData
	 * @param{Array} inventory - requested elements
	 */
	function GetData(inventory) {
	  this.command = 'getdata';
	  this.inventory = inventory || [];
	}

	util.inherits(GetData, Inventory);
	module.exports.GetData = GetData;

	/**
	 * Sent to another peer mainly to check the connection is still alive.
	 *
	 * @name P2P.Message.Ping
	 * @param{Buffer} nonce - a random 8 bytes buffer
	 */
	function Ping(nonce) {
	  this.command = 'ping';
	  /**
	   * @desc A random number that should be returned by the peer in a pong message 
	   * @type {number}
	   */
	  this.nonce = nonce || CONNECTION_NONCE;
	}
	util.inherits(Ping, Message);

	Ping.prototype.fromBuffer = function(payload) {
	  this.nonce = new BufferReader(payload).read(8);
	  return this;
	};

	Ping.prototype.getPayload = function() {
	  return this.nonce;
	};

	module.exports.Ping = Message.COMMANDS.ping = Ping;

	/**
	 * Sent in response to a Ping message
	 *
	 * @name P2P.Message.Pong
	 * @param{Buffer} nonce - a random 8 bytes buffer
	 */
	function Pong(nonce) {
	  this.command = 'pong';
	  /**
	   * @desc A random number that must match the one sent in the corresponding `ping` message 
	   * @type {number}
	   */
	  this.nonce = nonce || CONNECTION_NONCE;
	}

	util.inherits(Pong, Ping);
	module.exports.Pong = Message.COMMANDS.pong = Pong;

	/**
	 * Message used to notify about known addresses.
	 *
	 * @name P2P.Message.Addressess
	 * @param{Array} addresses - array of know addresses
	 */
	function Addresses(addresses) {
	  this.command = 'addr';
	  /**
	   * @type {Array.Buffer}
	   * @desc An array of ipv4/6 addresses
	   */
	  this.addresses = addresses || [];
	}
	util.inherits(Addresses, Message);

	Addresses.prototype.fromBuffer = function(payload) {
	  var parser = new BufferReader(payload);
	  var addrCount = Math.min(parser.readVarintNum(), 1000);

	  this.addresses = [];
	  for (var i = 0; i < addrCount; i++) {
	    // TODO: Time actually depends on the version of the other peer (>=31402)

	    var time = parser.readUInt32LE();
	    var services = parser.readUInt64LEBN();

	    // parse the ipv6 to a string
	    var ipv6 = [];
	    for (var a = 0; a < 6; a++) {
	      ipv6.push(parser.read(2).toString('hex'));
	    }
	    ipv6 = ipv6.join(':');

	    // parse the ipv4 to a string
	    var ipv4 = [];
	    for (var b = 0; b < 4; b++) {
	      ipv4.push(parser.read(1)[0]);
	    }
	    ipv4 = ipv4.join('.');

	    var port = parser.readUInt16BE();

	    this.addresses.push({
	      time: time,
	      services: services,
	      ip: { v6: ipv6, v4: ipv4 },
	      port: port
	    });
	  }

	  return this;
	};

	Addresses.prototype.getPayload = function() {
	  var put = new Put();
	  put.varint(this.addresses.length);

	  for (var i = 0; i < this.addresses.length; i++) {
	    put.word32le(this.addresses[i].time);
	    put.word64le(this.addresses[i].services);
	    put.put(this.addresses[i].ip);
	    put.word16be(this.addresses[i].port);
	  }

	  return put.buffer();
	};

	module.exports.Addresses = Message.COMMANDS.addr = Addresses;

	/**
	 * Query another node for known IPV4/6 addresses.
	 *
	 * @name P2P.Message.GetAddresses
	 */
	function GetAddresses() {
	  this.command = 'getaddr';
	}

	util.inherits(GetAddresses, Message);
	module.exports.GetAddresses = Message.COMMANDS.getaddr = GetAddresses;

	/**
	 * Finishes the connection handshake started by the `ver` message.
	 *
	 * @name P2P.Message.VerAck
	 */
	function VerAck() {
	  this.command = 'verack';
	}

	util.inherits(VerAck, Message);
	module.exports.VerAck = Message.COMMANDS.verack = VerAck;

	/**
	 * A reject message should be sent when a message is not supported or
	 * interpreted as invalid.
	 *
	 * @name P2P.Message.Reject
	 */
	function Reject() {
	  this.command = 'reject';
	}
	util.inherits(Reject, Message);

	// TODO: Parse REJECT message

	module.exports.Reject = Message.COMMANDS.reject = Reject;

	/**
	 * Used to send a message signed by a developer of the bitcoin project.
	 *
	 * @name P2P.Message.Alert
	 */
	function Alert(payload, signature) {
	  this.command = 'alert';
	  this.payload = payload || new Buffer(32);
	  this.signature = signature || new Buffer(32);
	}
	util.inherits(Alert, Message);

	Alert.prototype.fromBuffer = function(payload) {
	  var parser = new BufferReader(payload);
	  this.payload = parser.readVarintBuf(); // TODO: Use current format
	  this.signature = parser.readVarintBuf();
	  return this;
	};

	Alert.prototype.getPayload = function() {
	  var put = new Put();
	  put.varint(this.payload.length);
	  put.put(this.payload);

	  put.varint(this.signature.length);
	  put.put(this.signature);

	  return put.buffer();
	};

	module.exports.Alert = Message.COMMANDS.alert = Alert;

	/**
	 * Sent in response to a `getheaders` message. It contains information about
	 * block headers.
	 *
	 * @name P2P.Message.Headers
	 * @param{Array} blockheaders - array of block headers
	 */
	function Headers(blockheaders) {
	  this.command = 'headers';
	  /**
	   * @type {Array.BlockHeader}
	   * @desc An array of `BlockHeader`
	   */
	  this.headers = blockheaders || [];
	}
	util.inherits(Headers, Message);

	Headers.prototype.fromBuffer = function(payload) {
	  var parser = new BufferReader(payload);
	  var count = parser.readVarintNum();

	  this.headers = [];
	  for (var i = 0; i < count; i++) {
	    var header = BlockHeaderModel._fromBufferReader(parser);
	    this.headers.push(header);
	  }

	  return this;
	};

	Headers.prototype.getPayload = function() {
	  var put = new Put();
	  put.varint(this.headers.length);

	  for (var i = 0; i < this.headers.length; i++) {
	    var buffer = this.headers[i].toBuffer();
	    put.put(buffer);
	  }

	  return put.buffer();
	};

	module.exports.Headers = Message.COMMANDS.headers = Headers;

	/**
	 * Contains information about a Block
	 *
	 * @name P2P.Message.Block
	 * @param {Block} block
	 */
	function Block(block) {
	  this.command = 'block';

	  /**
	   * @type {Block}
	   * @desc The block received
	   */
	  this.block = block;
	}
	util.inherits(Block, Message);

	Block.prototype.fromBuffer = function(payload) {
	  this.block = BlockModel(payload);
	  return this;
	};

	Block.prototype.getPayload = function() {
	  return this.block.toBuffer();
	};

	module.exports.Block = Message.COMMANDS.block = Block;

	/**
	 * Contains information about a transaction
	 *
	 * @name P2P.Message.Transaction
	 * @param{Transaction} transaction
	 */
	function Transaction(transaction) {
	  this.command = 'tx';
	  /**
	   * @type {Transaction}
	   */
	  this.transaction = transaction;
	}
	util.inherits(Transaction, Message);

	Transaction.prototype.fromBuffer = function(payload) {
	  this.transaction = TransactionModel(payload);
	  return this;
	};

	Transaction.prototype.getPayload = function() {
	  return this.transaction.toBuffer();
	};

	module.exports.Transaction = Message.COMMANDS.tx = Transaction;

	/**
	 * Query another peer about blocks. It can query for multiple block hashes,
	 * and the response will contain all the chains of blocks starting from those
	 * hashes.
	 *
	 * @name P2P.Message.GetBlocks
	 * @param{Array} starts - array of buffers with the starting block hashes
	 * @param{Buffer} [stop] - hash of the last block
	 */
	function GetBlocks(starts, stop) {
	  this.command = 'getblocks';
	  /**
	   * @type {number}
	   */
	  this.version = PROTOCOL_VERSION;
	  /**
	   * @type {Array.Buffer}
	   */
	  this.starts = starts || [];
	  /**
	   * @type {Array.Buffer}
	   * @desc Hashes to limit the amount of blocks to be sent
	   */
	  this.stop = stop || BufferUtil.NULL_HASH;
	}
	util.inherits(GetBlocks, Message);

	GetBlocks.prototype.fromBuffer = function(payload) {
	  var parser = new BufferReader(payload);
	  this.version = parser.readUInt32LE();

	  var startCount = Math.min(parser.readVarintNum(), 500);
	  this.starts = [];
	  for (var i = 0; i < startCount; i++) {
	    this.starts.push(parser.read(32));
	  }
	  this.stop = parser.read(32);

	  return this;
	};

	GetBlocks.prototype.getPayload = function() {
	  var put = new Put();
	  put.word32le(this.version);
	  put.varint(this.starts.length);

	  for (var i = 0; i < this.starts.length; i++) {
	    if (this.starts[i].length !== 32) {
	      throw new Error('Invalid hash length');
	    }
	    put.put(this.starts[i]);
	  }

	  if (this.stop.length !== 32) {
	    throw new Error('Invalid hash length');
	  }
	  put.put(this.stop);

	  return put.buffer();
	};

	module.exports.GetBlocks = Message.COMMANDS.getblocks = GetBlocks;

	/**
	 * Request block headers starting from a hash
	 *
	 * @name P2P.Message.GetHeaders
	 * @param{Array} starts - array of buffers with the starting block hashes
	 * @param{Buffer} [stop] - hash of the last block
	 */
	function GetHeaders(starts, stop) {
	  this.command = 'getheaders';
	  /**
	   * @type {number}
	   */
	  this.version = PROTOCOL_VERSION;
	  /**
	   * @type {Array.Buffer}
	   */
	  this.starts = starts || [];
	  /**
	   * @type {Array.Buffer}
	   */
	  this.stop = stop || BufferUtil.NULL_HASH;
	}

	util.inherits(GetHeaders, GetBlocks);
	module.exports.GetHeaders = Message.COMMANDS.getheaders = GetHeaders;

	/**
	 * Request for transactions on the mempool
	 *
	 * @name P2P.Message.GetMempool
	 */
	function GetMempool() {
	  this.command = 'mempool';
	}

	util.inherits(GetMempool, Message);
	module.exports.GetMempool = Message.COMMANDS.mempool = GetMempool;

	// TODO: Remove this PATCH (yemel)
	Buffers.prototype.skip = function (i) {
	  if (i === 0) return;

	  if (i === this.length) {
	    this.buffers = [];
	    this.length = 0;
	    return;
	  }

	  var pos = this.pos(i);
	  this.buffers = this.buffers.slice(pos.buf);
	  this.buffers[0] = new Buffer(this.buffers[0].slice(pos.offset));
	  this.length -= i;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Buffers = __webpack_require__(65);
	var EventEmitter = __webpack_require__(26).EventEmitter;
	var Net = __webpack_require__(66);
	var Socks5Client = __webpack_require__(109);
	var util = __webpack_require__(16);

	var bitcore = __webpack_require__(32);
	var Networks = bitcore.Networks;
	var Messages = __webpack_require__(53);

	var MAX_RECEIVE_BUFFER = 10000000;

	/**
	 * A Peer instance represents a remote bitcoin node and allows to communicate
	 * with it using the standar messages of the bitcoin p2p protocol.
	 *
	 * @example
	 * ```javascript
	 * 
	 * var peer = new Peer('127.0.0.1').setProxy('127.0.0.1', 9050);
	 * peer.on('tx', function(tx) {
	 *  console.log('New transaction: ', tx.id);
	 * });
	 * peer.connect();
	 * ```
	 *
	 * @param {String} host - IP address of the remote host
	 * @param {Number} [port] - Port number of the remote host
	 * @param {Network} [network] - The context for this communication
	 * @returns {Peer} A new instance of Peer.
	 * @constructor
	 */
	function Peer(host, port, network) {
	  if (!(this instanceof Peer)) {
	    return new Peer(host, port, network);
	  }

	  // overloading stuff
	  if (port instanceof Object && !network) {
	    network = port;
	    port = undefined;
	  }
	  
	  this.host = host;
	  this.status = Peer.STATUS.DISCONNECTED;
	  this.network = network || Networks.livenet;
	  this.port = port || this.network.port;

	  this.dataBuffer = new Buffers();

	  this.version = 0;
	  this.bestHeight = 0;
	  this.subversion = null;

	  // set message handlers
	  var self = this;
	  this.on('verack', function() {
	    self.status = Peer.STATUS.READY;
	    self.emit('ready');
	  });

	  this.on('version', function(message) {
	    self.version = message.version;
	    self.subversion = message.subversion;
	    self.bestHeight = message.start_height
	  });

	  this.on('ping', function(message) {
	    self._sendPong(message.nonce);
	  });

	}
	util.inherits(Peer, EventEmitter);

	Peer.STATUS = {
	  DISCONNECTED: 'disconnected',
	  CONNECTING: 'connecting',
	  CONNECTED: 'connected',
	  READY: 'ready'
	};

	/**
	 * Set a socks5 proxy for the connection. Enables the use of the TOR network.
	 *
	 * @param {String} host - IP address of the proxy
	 * @param {Number} port - Port number of the proxy
	 * @returns {Peer} The same Peer instance.
	 */
	Peer.prototype.setProxy = function(host, port) {
	  if (this.status != Peer.STATUS.DISCONNECTED) {
	    throw Error('Invalid State');
	  }

	  this.proxy = {
	    host: host,
	    port: port
	  };
	  return this;
	};

	/**
	 * Init the connection with the remote peer.
	 *
	 * @returns {Socket} The same peer instance.
	 */
	Peer.prototype.connect = function() {
	  this.status = Peer.STATUS.CONNECTING;

	  this.socket = Net.connect({
	      host: this.host,
	      port: this.port
	  });
	  // Want a short timeout
	  this.socket.setTimeout(2000);

	  var self = this;
	  this.socket.on('connect', function(ev) {
	    self.status = Peer.STATUS.CONNECTED;
	    self.emit('connect');
	    self._sendVersion();
	  });

	  this.socket.on('error', self.disconnect.bind(this));
	  this.socket.on('end', self.disconnect.bind(this));

	  this.socket.on('data', function(data) {
	    self.dataBuffer.push(data);
	    
	    if (self.dataBuffer.length > MAX_RECEIVE_BUFFER) return self.disconnect();
	    self._readMessage();
	  });

	  return this;
	};

	/**
	 * Disconnects the remote connection.
	 *
	 * @returns {Socket} The same peer instance.
	 */
	Peer.prototype.disconnect = function() {
	  this.status = Peer.STATUS.DISCONNECTED;
	  this.socket.destroy();
	  this.emit('disconnect');
	  return this;
	};

	/**
	 * Send a Message to the remote peer.
	 *
	 * @param {Message} message - A message instance
	 */
	Peer.prototype.sendMessage = function(message) {
	  this.socket.write(message.serialize(this.network));
	};

	/**
	 * Internal function that sends VERSION message to the remote peer.
	 */
	Peer.prototype._sendVersion = function() {
	  var message = new Messages.Version();
	  this.sendMessage(message);
	};

	/**
	 * Send a PONG message to the remote peer.
	 */
	Peer.prototype._sendPong = function(nonce) {
	  var message = new Messages.Pong(nonce);
	  this.sendMessage(message);
	};

	/**
	 * Internal function that tries to read a message from the data buffer
	 */
	Peer.prototype._readMessage = function() {
	  var message = Messages.parseMessage(this.network, this.dataBuffer);

	  if (message) {
	    this.emit(message.command, message);
	    this._readMessage();
	  }
	};

	/**
	 * Internal function that creates a socket using a proxy if neccesary.
	 *
	 * @returns {Socket} A Socket instance not yet connected.
	 */
	Peer.prototype._getSocket = function() {
	  if (this.proxy) {
	    return new Socks5Client(this.proxy.host, this.proxy.port);
	  }

	  return new Net.Socket();
	};

	module.exports = Peer;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _ = __webpack_require__(2);
	var BlockHeader = __webpack_require__(56);
	var BN = __webpack_require__(6);
	var BufferUtil = __webpack_require__(3);
	var BufferReader = __webpack_require__(18);
	var BufferWriter = __webpack_require__(12);
	var Hash = __webpack_require__(7);
	var JSUtil = __webpack_require__(4);
	var Transaction = __webpack_require__(41);
	var $ = __webpack_require__(5);

	/**
	 * Instantiate a Block from a Buffer, JSON object, or Object with
	 * the properties of the Block
	 *
	 * @param {*} - A Buffer, JSON string, or Object
	 * @returns {Block}
	 * @constructor
	 */
	function Block(arg) {
	  if (!(this instanceof Block)) {
	    return new Block(arg);
	  }
	  _.extend(this, Block._from(arg));
	  return this;
	}

	// https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14
	Block.MAX_BLOCK_SIZE = 1000000;

	/**
	 * @param {*} - A Buffer, JSON string or Object
	 * @returns {Object} - An object representing block data
	 * @throws {TypeError} - If the argument was not recognized
	 * @private
	 */
	Block._from = function _from(arg) {
	  var info = {};
	  if (BufferUtil.isBuffer(arg)) {
	    info = Block._fromBufferReader(BufferReader(arg));
	  } else if (JSUtil.isValidJSON(arg)) {
	    info = Block._fromJSON(arg);
	  } else if (_.isObject(arg)) {
	    info = {
	      /**
	       * @name Block#header
	       * @type {BlockHeader}
	       */
	      header: arg.header,
	      /**
	       * @name Block#transactions
	       * @type {Transaction[]}
	       */
	      transactions: arg.transactions
	    };
	  } else {
	    throw new TypeError('Unrecognized argument for Block');
	  }
	  return info;
	};

	/**
	 * @param {String|Object} - A JSON string or object
	 * @returns {Object} - An object representing block data
	 * @private
	 */
	Block._fromJSON = function _fromJSON(data) {
	  if (JSUtil.isValidJSON(data)) {
	    data = JSON.parse(data);
	  }
	  var transactions = [];
	  data.transactions.forEach(function(data) {
	    transactions.push(Transaction().fromJSON(data));
	  });
	  var info = {
	    header: BlockHeader.fromJSON(data.header),
	    transactions: transactions
	  };
	  return info;
	};

	/**
	 * @param {String|Object} - A JSON string or object
	 * @returns {Block} - An instance of block
	 */
	Block.fromJSON = function fromJSON(json) {
	  var info = Block._fromJSON(json);
	  return new Block(info);
	};

	/**
	 * @param {BufferReader} - Block data
	 * @returns {Object} - An object representing the block data
	 * @private
	 */
	Block._fromBufferReader = function _fromBufferReader(br) {
	  var info = {};
	  $.checkState(!br.finished(), 'No block data received');
	  info.header = BlockHeader.fromBufferReader(br);
	  var transactions = br.readVarintNum();
	  info.transactions = [];
	  for (var i = 0; i < transactions; i++) {
	    info.transactions.push(Transaction().fromBufferReader(br));
	  }
	  return info;
	};

	/**
	 * @param {BufferReader} - A buffer reader of the block
	 * @returns {Block} - An instance of block
	 */
	Block.fromBufferReader = function fromBufferReader(br) {
	  var info = Block._fromBufferReader(br);
	  return new Block(info);
	};

	/**
	 * @param {Buffer} - A buffer of the block
	 * @returns {Block} - An instance of block
	 */
	Block.fromBuffer = function fromBuffer(buf) {
	  return Block.fromBufferReader(BufferReader(buf));
	};

	/**
	 * @param {String} - str - A hex encoded string of the block
	 * @returns {Block} - A hex encoded string of the block
	 */
	Block.fromString = function fromString(str) {
	  var buf = new Buffer(str, 'hex');
	  return Block.fromBuffer(buf);
	};

	/**
	 * @param {Binary} - Raw block binary data or buffer
	 * @returns {Block} - An instance of block
	 */
	Block.fromRawBlock = function fromRawBlock(data) {
	  if (!BufferUtil.isBuffer(data)) {
	    data = new Buffer(data, 'binary');
	  }
	  var br = BufferReader(data);
	  br.pos = Block.Values.START_OF_BLOCK;
	  var info = Block._fromBufferReader(br);
	  return new Block(info);
	};

	/**
	 * @returns {Object} - A plain object with the block properties
	 */
	Block.prototype.toObject = function toObject() {
	  var transactions = [];
	  this.transactions.forEach(function(tx) {
	    transactions.push(tx.toObject());
	  });
	  return {
	    header: this.header.toObject(),
	    transactions: transactions
	  };
	};

	/**
	 * @returns {String} - A JSON string
	 */
	Block.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	/**
	 * @returns {Buffer} - A buffer of the block
	 */
	Block.prototype.toBuffer = function toBuffer() {
	  return this.toBufferWriter().concat();
	};

	/**
	 * @returns {String} - A hex encoded string of the block
	 */
	Block.prototype.toString = function toString() {
	  return this.toBuffer().toString('hex');
	};

	/**
	 * @param {BufferWriter} - An existing instance of BufferWriter
	 * @returns {BufferWriter} - An instance of BufferWriter representation of the Block
	 */
	Block.prototype.toBufferWriter = function toBufferWriter(bw) {
	  if (!bw) {
	    bw = new BufferWriter();
	  }
	  bw.write(this.header.toBuffer());
	  bw.writeVarintNum(this.transactions.length);
	  for (var i = 0; i < this.transactions.length; i++) {
	    this.transactions[i].toBufferWriter(bw);
	  }
	  return bw;
	};

	/**
	 * Will iterate through each transaction and return an array of hashes
	 * @returns {Array} - An array with transaction hashes
	 */
	Block.prototype.getTransactionHashes = function getTransactionHashes() {
	  var hashes = [];
	  if (this.transactions.length === 0) {
	    return [Block.Values.NULL_HASH];
	  }
	  for (var t = 0; t < this.transactions.length; t++) {
	    hashes.push(this.transactions[t]._getHash());
	  }
	  return hashes;
	};

	/**
	 * Will build a merkle tree of all the transactions, ultimately arriving at
	 * a single point, the merkle root.
	 * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees
	 * @returns {Array} - An array with each level of the tree after the other.
	 */
	Block.prototype.getMerkleTree = function getMerkleTree() {

	  var tree = this.getTransactionHashes();

	  var j = 0;
	  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {
	    for (var i = 0; i < size; i += 2) {
	      var i2 = Math.min(i + 1, size - 1);
	      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);
	      tree.push(Hash.sha256sha256(buf));
	    }
	    j += size;
	  }

	  return tree;
	};

	/**
	 * Calculates the merkleRoot from the transactions.
	 * @returns {Buffer} - A buffer of the merkle root hash
	 */
	Block.prototype.getMerkleRoot = function getMerkleRoot() {
	  var tree = this.getMerkleTree();
	  return tree[tree.length - 1];
	};

	/**
	 * Verifies that the transactions in the block match the header merkle root
	 * @returns {Boolean} - If the merkle roots match
	 */
	Block.prototype.validMerkleRoot = function validMerkleRoot() {

	  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');
	  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');

	  if (h.cmp(c) !== 0) {
	    return false;
	  }

	  return true;
	};

	/**
	 * @returns {Buffer} - The little endian hash buffer of the header
	 */
	Block.prototype._getHash = function() {
	  return this.header._getHash();
	};

	var idProperty = {
	  configurable: false,
	  writeable: false,
	  /**
	   * @returns {string} - The big endian hash buffer of the header
	   */
	  get: function() {
	    if (!this._id) {
	      this._id = this.header.id;
	    }
	    return this._id;
	  },
	  set: _.noop
	};
	Object.defineProperty(Block.prototype, 'id', idProperty);
	Object.defineProperty(Block.prototype, 'hash', idProperty);

	/**
	 * @returns {String} - A string formated for the console
	 */
	Block.prototype.inspect = function inspect() {
	  return '<Block ' + this.id + '>';
	};

	Block.Values = {
	  START_OF_BLOCK: 8, // Start of block in raw block data
	  NULL_HASH: new Buffer('0000000000000000000000000000000000000000000000000000000000000000', 'hex')
	};

	module.exports = Block;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _ = __webpack_require__(2);
	var BN = __webpack_require__(6);
	var BufferUtil = __webpack_require__(3);
	var BufferReader = __webpack_require__(18);
	var BufferWriter = __webpack_require__(12);
	var Hash = __webpack_require__(7);
	var JSUtil = __webpack_require__(4);

	/**
	 * Instantiate a BlockHeader from a Buffer, JSON object, or Object with
	 * the properties of the BlockHeader
	 *
	 * @param {*} - A Buffer, JSON string, or Object
	 * @returns {BlockHeader} - An instance of block header
	 * @constructor
	 */
	var BlockHeader = function BlockHeader(arg) {
	  if (!(this instanceof BlockHeader)) {
	    return new BlockHeader(arg);
	  }
	  _.extend(this, BlockHeader._from(arg));
	  return this;
	};

	/**
	 * @param {*} - A Buffer, JSON string or Object
	 * @returns {Object} - An object representing block header data
	 * @throws {TypeError} - If the argument was not recognized
	 * @private
	 */
	BlockHeader._from = function _from(arg) {
	  var info = {};
	  if (BufferUtil.isBuffer(arg)) {
	    info = BlockHeader._fromBufferReader(BufferReader(arg));
	  } else if (JSUtil.isValidJSON(arg)) {
	    info = BlockHeader._fromJSON(arg);
	  } else if (_.isObject(arg)) {
	    info = {
	      version: arg.version,
	      prevHash: arg.prevHash,
	      merkleRoot: arg.merkleRoot,
	      time: arg.time,
	      bits: arg.bits,
	      nonce: arg.nonce
	    };
	  } else {
	    throw new TypeError('Unrecognized argument for BlockHeader');
	  }
	  return info;
	};

	/**
	 * @param {String|Object} - A JSON string or object
	 * @returns {Object} - An object representing block header data
	 * @private
	 */
	BlockHeader._fromJSON = function _fromJSON(data) {
	  if (JSUtil.isValidJSON(data)) {
	    data = JSON.parse(data);
	  }
	  var info = {
	    version: data.version,
	    prevHash: new Buffer(data.prevHash, 'hex'),
	    merkleRoot: new Buffer(data.merkleRoot, 'hex'),
	    time: data.time,
	    timestamp: data.time,
	    bits: data.bits,
	    nonce: data.nonce
	  };
	  return info;
	};

	/**
	 * @param {String|Object} - A JSON string or object
	 * @returns {BlockHeader} - An instance of block header
	 */
	BlockHeader.fromJSON = function fromJSON(json) {
	  var info = BlockHeader._fromJSON(json);
	  return new BlockHeader(info);
	};

	/**
	 * @param {Binary} - Raw block binary data or buffer
	 * @returns {BlockHeader} - An instance of block header
	 */
	BlockHeader.fromRawBlock = function fromRawBlock(data) {
	  if (!BufferUtil.isBuffer(data)) {
	    data = new Buffer(data, 'binary');
	  }
	  var br = BufferReader(data);
	  br.pos = BlockHeader.Constants.START_OF_HEADER;
	  var info = BlockHeader._fromBufferReader(br);
	  return new BlockHeader(info);
	};

	/**
	 * @param {Buffer} - A buffer of the block header
	 * @returns {BlockHeader} - An instance of block header
	 */
	BlockHeader.fromBuffer = function fromBuffer(buf) {
	  var info = BlockHeader._fromBufferReader(BufferReader(buf));
	  return new BlockHeader(info);
	};

	/**
	 * @param {String} - A hex encoded buffer of the block header
	 * @returns {BlockHeader} - An instance of block header
	 */
	BlockHeader.fromString = function fromString(str) {
	  var buf = new Buffer(str, 'hex');
	  return BlockHeader.fromBuffer(buf);
	};

	/**
	 * @param {BufferReader} - A BufferReader of the block header
	 * @returns {Object} - An object representing block header data
	 * @private
	 */
	BlockHeader._fromBufferReader = function _fromBufferReader(br) {
	  var info = {};
	  info.version = br.readUInt32LE();
	  info.prevHash = br.read(32);
	  info.merkleRoot = br.read(32);
	  info.time = br.readUInt32LE();
	  info.bits = br.readUInt32LE();
	  info.nonce = br.readUInt32LE();
	  return info;
	};

	/**
	 * @param {BufferReader} - A BufferReader of the block header
	 * @returns {BlockHeader} - An instance of block header
	 */
	BlockHeader.fromBufferReader = function fromBufferReader(br) {
	  var info = BlockHeader._fromBufferReader(br);
	  return new BlockHeader(info);
	};

	/**
	 * @returns {Object} - A plain object of the BlockHeader
	 */
	BlockHeader.prototype.toObject = function toObject() {
	  return {
	    version: this.version,
	    prevHash: this.prevHash.toString('hex'),
	    merkleRoot: this.merkleRoot.toString('hex'),
	    time: this.time,
	    bits: this.bits,
	    nonce: this.nonce
	  };
	};

	/**
	 * @returns {String} - A JSON string
	 */
	BlockHeader.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	/**
	 * @returns {Buffer} - A Buffer of the BlockHeader
	 */
	BlockHeader.prototype.toBuffer = function toBuffer() {
	  return this.toBufferWriter().concat();
	};

	/**
	 * @returns {String} - A hex encoded string of the BlockHeader
	 */
	BlockHeader.prototype.toString = function toString() {
	  return this.toBuffer().toString('hex');
	};

	/**
	 * @param {BufferWriter} - An existing instance BufferWriter
	 * @returns {BufferWriter} - An instance of BufferWriter representation of the BlockHeader
	 */
	BlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) {
	  if (!bw) {
	    bw = new BufferWriter();
	  }
	  bw.writeUInt32LE(this.version);
	  bw.write(this.prevHash);
	  bw.write(this.merkleRoot);
	  bw.writeUInt32LE(this.time);
	  bw.writeUInt32LE(this.bits);
	  bw.writeUInt32LE(this.nonce);
	  return bw;
	};

	/**
	 * @link https://en.bitcoin.it/wiki/Difficulty
	 * @returns {BN} - An instance of BN with the decoded difficulty bits
	 */
	BlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(info) {
	  var target = BN(this.bits & 0xffffff);
	  var mov = 8 * ((this.bits >>> 24) - 3);
	  while (mov-- > 0) {
	    target = target.mul(2);
	  }
	  return target;
	};

	/**
	 * @returns {Buffer} - The little endian hash buffer of the header
	 */
	BlockHeader.prototype._getHash = function hash() {
	  var buf = this.toBuffer();
	  return Hash.sha256sha256(buf);
	};

	var idProperty = {
	  configurable: false,
	  writeable: false,
	  enumerable: true,
	  /**
	  * @returns {string} - The big endian hash buffer of the header
	  */
	  get: function() {
	    if (!this._id) {
	      this._id = BufferReader(this._getHash()).readReverse().toString('hex');
	    }
	    return this._id;
	  },
	  set: _.noop
	};
	Object.defineProperty(BlockHeader.prototype, 'id', idProperty);
	Object.defineProperty(BlockHeader.prototype, 'hash', idProperty);

	/**
	 * @returns {Boolean} - If timestamp is not too far in the future
	 */
	BlockHeader.prototype.validTimestamp = function validTimestamp() {
	  var currentTime = Math.round(new Date().getTime() / 1000);
	  if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {
	    return false;
	  }
	  return true;
	};

	/**
	 * @returns {Boolean} - If the proof-of-work hash satisfies the target difficulty
	 */
	BlockHeader.prototype.validProofOfWork = function validProofOfWork() {
	  var pow = new BN(this.id, 'hex');
	  var target = this.getTargetDifficulty();

	  if (pow.cmp(target) > 0) {
	    return false;
	  }
	  return true;
	};

	/**
	 * @returns {String} - A string formated for the console
	 */
	BlockHeader.prototype.inspect = function inspect() {
	  return '<BlockHeader ' + this.id + '>';
	};

	BlockHeader.Constants = {
	  START_OF_HEADER: 8, // Start buffer position in raw block data
	  MAX_TIME_OFFSET: 2 * 60 * 60, // The max a timestamp can be in the future
	  LARGEST_HASH: new BN('10000000000000000000000000000000000000000000000000000000000000000', 'hex')
	};

	module.exports = BlockHeader;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var BN = __webpack_require__(6);
	var Point = __webpack_require__(23);
	var Signature = __webpack_require__(14);
	var PublicKey = __webpack_require__(13);
	var Random = __webpack_require__(33);
	var Hash = __webpack_require__(7);
	var BufferUtil = __webpack_require__(3);
	var _ = __webpack_require__(2);
	var $ = __webpack_require__(5);

	var ECDSA = function ECDSA(obj) {
	  if (!(this instanceof ECDSA)) {
	    return new ECDSA(obj);
	  }
	  if (obj) {
	    this.set(obj);
	  }
	};

	/* jshint maxcomplexity: 9 */
	ECDSA.prototype.set = function(obj) {
	  this.hashbuf = obj.hashbuf || this.hashbuf;
	  this.endian = obj.endian || this.endian; //the endianness of hashbuf
	  this.privkey = obj.privkey || this.privkey;
	  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);
	  this.sig = obj.sig || this.sig;
	  this.k = obj.k || this.k;
	  this.verified = obj.verified || this.verified;
	  return this;
	};

	ECDSA.prototype.privkey2pubkey = function() {
	  this.pubkey = this.privkey.toPublicKey();
	};

	ECDSA.prototype.calci = function() {
	  for (var i = 0; i < 4; i++) {
	    this.sig.i = i;
	    var Qprime;
	    try {
	      Qprime = this.toPublicKey();
	    } catch (e) {
	      console.error(e);
	      continue;
	    }

	    if (Qprime.point.eq(this.pubkey.point)) {
	      this.sig.compressed = this.pubkey.compressed;
	      return this;
	    }
	  }

	  this.sig.i = undefined;
	  throw new Error('Unable to find valid recovery factor');
	};

	ECDSA.fromString = function(str) {
	  var obj = JSON.parse(str);
	  return new ECDSA(obj);
	};

	ECDSA.prototype.randomK = function() {
	  var N = Point.getN();
	  var k;
	  do {
	    k = BN.fromBuffer(Random.getRandomBuffer(32));
	  } while (!(k.lt(N) && k.gt(0)));
	  this.k = k;
	  return this;
	};


	// https://tools.ietf.org/html/rfc6979#section-3.2
	ECDSA.prototype.deterministicK = function(badrs) {
	  /* jshint maxstatements: 25 */
	  // if r or s were invalid when this function was used in signing,
	  // we do not want to actually compute r, s here for efficiency, so,
	  // we can increment badrs. explained at end of RFC 6979 section 3.2
	  if (_.isUndefined(badrs)) {
	    badrs = 0;
	  }
	  var v = new Buffer(32);
	  v.fill(0x01);
	  var k = new Buffer(32);
	  k.fill(0x00);
	  var x = this.privkey.bn.toBuffer({
	    size: 32
	  });
	  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00]), x, this.hashbuf]), k);
	  v = Hash.sha256hmac(v, k);
	  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x01]), x, this.hashbuf]), k);
	  v = Hash.sha256hmac(v, k);
	  v = Hash.sha256hmac(v, k);
	  var T = BN.fromBuffer(v);
	  var N = Point.getN();

	  // also explained in 3.2, we must ensure T is in the proper range (0, N)
	  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(0)); i++) {
	    k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00])]), k);
	    v = Hash.sha256hmac(v, k);
	    v = Hash.sha256hmac(v, k);
	    T = BN.fromBuffer(v);
	  }

	  this.k = T;
	  return this;
	};

	// Information about public key recovery:
	// https://bitcointalk.org/index.php?topic=6430.0
	// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k
	ECDSA.prototype.toPublicKey = function() {
	  /* jshint maxstatements: 25 */
	  var i = this.sig.i;
	  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));

	  var e = BN.fromBuffer(this.hashbuf);
	  var r = this.sig.r;
	  var s = this.sig.s;

	  // A set LSB signifies that the y-coordinate is odd
	  var isYOdd = i & 1;

	  // The more significant bit specifies whether we should use the
	  // first or second candidate key.
	  var isSecondKey = i >> 1;

	  var n = Point.getN();
	  var G = Point.getG();

	  // 1.1 Let x = r + jn
	  var x = isSecondKey ? r.add(n) : r;
	  var R = Point.fromX(isYOdd, x);

	  // 1.4 Check that nR is at infinity
	  var nR = R.mul(n);

	  if (!nR.isInfinity()) {
	    throw new Error('nR is not a valid curve point');
	  }

	  // Compute -e from e
	  var eNeg = e.neg().mod(n);

	  // 1.6.1 Compute Q = r^-1 (sR - eG)
	  // Q = r^-1 (sR + -eG)
	  var rInv = r.invm(n);

	  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);
	  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);

	  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);

	  return pubkey;
	};

	ECDSA.prototype.sigError = function() {
	  /* jshint maxstatements: 25 */
	  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {
	    return 'hashbuf must be a 32 byte buffer';
	  }

	  var r = this.sig.r;
	  var s = this.sig.s;
	  if (!(r.gt(0) && r.lt(Point.getN())) || !(s.gt(0) && s.lt(Point.getN()))) {
	    return 'r and s not in range';
	  }

	  var e = BN.fromBuffer(this.hashbuf, this.endian ? {
	    endian: this.endian
	  } : undefined);
	  var n = Point.getN();
	  var sinv = s.invm(n);
	  var u1 = sinv.mul(e).mod(n);
	  var u2 = sinv.mul(r).mod(n);

	  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);
	  if (p.isInfinity()) {
	    return 'p is infinity';
	  }

	  if (p.getX().mod(n).cmp(r) !== 0) {
	    return 'Invalid signature';
	  } else {
	    return false;
	  }
	};

	ECDSA.toLowS = function(s) {
	  //enforce low s
	  //see BIP 62, "low S values in signatures"
	  if (s.gt(BN.fromBuffer(new Buffer('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {
	    s = Point.getN().sub(s);
	  }
	  return s;
	};

	ECDSA.prototype._findSignature = function(d, e) {
	  var N = Point.getN();
	  var G = Point.getG();
	  // try different values of k until r, s are valid
	  var badrs = 0;
	  var k, Q, r, s;
	  do {
	    if (!this.k || badrs > 0) {
	      this.deterministicK(badrs);
	    }
	    badrs++;
	    k = this.k;
	    Q = G.mul(k);
	    r = Q.x.mod(N);
	    s = k.invm(N).mul(e.add(d.mul(r))).mod(N);
	  } while (r.cmp(0) <= 0 || s.cmp(0) <= 0);

	  s = ECDSA.toLowS(s);
	  return {
	    s: s,
	    r: r
	  };

	};

	ECDSA.prototype.sign = function() {
	  var hashbuf = this.hashbuf;
	  var privkey = this.privkey;
	  var d = privkey.bn;

	  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));
	  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));

	  var e = BN.fromBuffer(hashbuf, this.endian ? {
	    endian: this.endian
	  } : undefined);

	  var obj = this._findSignature(d, e);
	  obj.compressed = this.pubkey.compressed;

	  this.sig = new Signature(obj);
	  return this;
	};

	ECDSA.prototype.signRandomK = function() {
	  this.randomK();
	  return this.sign();
	};

	ECDSA.prototype.toString = function() {
	  var obj = {};
	  if (this.hashbuf) {
	    obj.hashbuf = this.hashbuf.toString('hex');
	  }
	  if (this.privkey) {
	    obj.privkey = this.privkey.toString();
	  }
	  if (this.pubkey) {
	    obj.pubkey = this.pubkey.toString();
	  }
	  if (this.sig) {
	    obj.sig = this.sig.toString();
	  }
	  if (this.k) {
	    obj.k = this.k.toString();
	  }
	  return JSON.stringify(obj);
	};

	ECDSA.prototype.verify = function() {
	  if (!this.sigError()) {
	    this.verified = true;
	  } else {
	    this.verified = false;
	  }
	  return this;
	};

	ECDSA.sign = function(hashbuf, privkey, endian) {
	  return ECDSA().set({
	    hashbuf: hashbuf,
	    endian: endian,
	    privkey: privkey
	  }).sign().sig;
	};

	ECDSA.verify = function(hashbuf, sig, pubkey, endian) {
	  return ECDSA().set({
	    hashbuf: hashbuf,
	    endian: endian,
	    sig: sig,
	    pubkey: pubkey
	  }).verify().verified;
	};

	module.exports = ECDSA;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';


	var assert = __webpack_require__(8);
	var buffer = __webpack_require__(1);
	var _ = __webpack_require__(2);

	var BN = __webpack_require__(6);
	var Base58 = __webpack_require__(34);
	var Base58Check = __webpack_require__(27);
	var Hash = __webpack_require__(7);
	var Network = __webpack_require__(19);
	var HDKeyCache = __webpack_require__(39);
	var Point = __webpack_require__(23);
	var PrivateKey = __webpack_require__(35);
	var Random = __webpack_require__(33);

	var errors = __webpack_require__(15);
	var hdErrors = errors.HDPrivateKey;
	var BufferUtil = __webpack_require__(3);
	var JSUtil = __webpack_require__(4);

	var MINIMUM_ENTROPY_BITS = 128;
	var BITS_TO_BYTES = 1/8;
	var MAXIMUM_ENTROPY_BITS = 512;


	/**
	 * Represents an instance of an hierarchically derived private key.
	 *
	 * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
	 *
	 * @constructor
	 * @param {string|Buffer|Object} arg
	 */
	function HDPrivateKey(arg) {
	  /* jshint maxcomplexity: 10 */
	  if (arg instanceof HDPrivateKey) {
	    return arg;
	  }
	  if (!(this instanceof HDPrivateKey)) {
	    return new HDPrivateKey(arg);
	  }
	  if (!arg) {
	    return this._generateRandomly();
	  }

	  if (Network.get(arg)) {
	    return this._generateRandomly(arg);
	  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
	    if (HDPrivateKey.isValidSerialized(arg)) {
	      this._buildFromSerialized(arg);
	    } else if (JSUtil.isValidJSON(arg)) {
	      this._buildFromJSON(arg);
	    } else {
	      throw HDPrivateKey.getSerializedError(arg);
	    }
	  } else if (_.isObject(arg)) {
	    this._buildFromObject(arg);
	  } else {
	    throw new hdErrors.UnrecognizedArgument(arg);
	  }
	}

	/**
	 * Verifies that a given path is valid.
	 *
	 * @param {string|number} arg
	 * @param {boolean?} hardened
	 * @return {boolean}
	 */
	HDPrivateKey.isValidPath = function(arg, hardened) {
	  if (_.isString(arg)) {
	    var indexes = HDPrivateKey._getDerivationIndexes(arg);
	    return indexes !== null && _.all(indexes, HDPrivateKey.isValidPath);
	  }

	  if (_.isNumber(arg)) {
	    if (arg < HDPrivateKey.Hardened && hardened === true) {
	      arg += HDPrivateKey.Hardened;
	    }
	    return arg >= 0 && arg < HDPrivateKey.MaxIndex;
	  }

	  return false;
	};

	/**
	 * Internal function that splits a string path into a derivation index array.
	 * It will return null if the string path is malformed.
	 * It does not validate if indexes are in bounds.
	 *
	 * @param {string} path
	 * @return {Array}
	 */
	HDPrivateKey._getDerivationIndexes = function(path) {
	  var steps = path.split('/');

	  // Special cases:
	  if (_.contains(HDPrivateKey.RootElementAlias, path)) {
	    return [];
	  }

	  if (!_.contains(HDPrivateKey.RootElementAlias, steps[0])) {
	    return null;
	  }

	  var indexes = steps.slice(1).map(function(step) {
	    var index = parseInt(step);
	    index += step != index.toString() ? HDPrivateKey.Hardened : 0;
	    return index;
	  });

	  return _.any(indexes, isNaN) ? null : indexes;
	}

	/**
	 * Get a derivated child based on a string or number.
	 *
	 * If the first argument is a string, it's parsed as the full path of
	 * derivation. Valid values for this argument include "m" (which returns the
	 * same private key), "m/0/1/40/2'/1000", where the ' quote means a hardened
	 * derivation.
	 *
	 * If the first argument is a number, the child with that index will be
	 * derived. If the second argument is truthy, the hardened version will be
	 * derived. See the example usage for clarification.
	 *
	 * @example
	 * ```javascript
	 * var parent = new HDPrivateKey('xprv...');
	 * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);
	 * var copy_of_child_0_1_2h = parent.derive("m/0/1/2'");
	 * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);
	 * ```
	 *
	 * @param {string|number} arg
	 * @param {boolean?} hardened
	 */
	HDPrivateKey.prototype.derive = function(arg, hardened) {
	  if (_.isNumber(arg)) {
	    return this._deriveWithNumber(arg, hardened);
	  } else if (_.isString(arg)) {
	    return this._deriveFromString(arg);
	  } else {
	    throw new hdErrors.InvalidDerivationArgument(arg);
	  }
	};

	HDPrivateKey.prototype._deriveWithNumber = function(index, hardened) {
	  /* jshint maxstatements: 20 */
	  /* jshint maxcomplexity: 10 */
	  if (!HDPrivateKey.isValidPath(index, hardened)) {
	    throw new hdErrors.InvalidPath(index);
	  }

	  hardened = index >= HDPrivateKey.Hardened ? true : hardened;
	  if (index < HDPrivateKey.Hardened && hardened === true) {
	    index += HDPrivateKey.Hardened;
	  }

	  var cached = HDKeyCache.get(this.xprivkey, index, hardened);
	  if (cached) {
	    return cached;
	  }

	  var indexBuffer = BufferUtil.integerAsBuffer(index);
	  var data;
	  if (hardened) {
	    data = BufferUtil.concat([new buffer.Buffer([0]), this.privateKey.toBuffer(), indexBuffer]);
	  } else {
	    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
	  }
	  var hash = Hash.sha512hmac(data, this._buffers.chainCode);
	  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});
	  var chainCode = hash.slice(32, 64);

	  var privateKey = leftPart.add(this.privateKey.toBigNumber()).mod(Point.getN()).toBuffer({size: 32});

	  var derived = new HDPrivateKey({
	    network: this.network,
	    depth: this.depth + 1,
	    parentFingerPrint: this.fingerPrint,
	    childIndex: index,
	    chainCode: chainCode,
	    privateKey: privateKey
	  });
	  HDKeyCache.set(this.xprivkey, index, hardened, derived);
	  return derived;
	};

	HDPrivateKey.prototype._deriveFromString = function(path) {
	  if (!HDPrivateKey.isValidPath(path)) {
	    throw new hdErrors.InvalidPath(path);
	  }

	  var indexes = HDPrivateKey._getDerivationIndexes(path);
	  var derived = indexes.reduce(function(prev, index) {
	    return prev._deriveWithNumber(index);
	  }, this);

	  return derived;
	};

	/**
	 * Verifies that a given serialized private key in base58 with checksum format
	 * is valid.
	 *
	 * @param {string|Buffer} data - the serialized private key
	 * @param {string|Network=} network - optional, if present, checks that the
	 *     network provided matches the network serialized.
	 * @return {boolean}
	 */
	HDPrivateKey.isValidSerialized = function(data, network) {
	  return !HDPrivateKey.getSerializedError(data, network);
	};

	/**
	 * Checks what's the error that causes the validation of a serialized private key
	 * in base58 with checksum to fail.
	 *
	 * @param {string|Buffer} data - the serialized private key
	 * @param {string|Network=} network - optional, if present, checks that the
	 *     network provided matches the network serialized.
	 * @return {errors.InvalidArgument|null}
	 */
	HDPrivateKey.getSerializedError = function(data, network) {
	  /* jshint maxcomplexity: 10 */
	  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
	    return new hdErrors.UnrecognizedArgument('Expected string or buffer');
	  }
	  if (!Base58.validCharacters(data)) {
	    return new errors.InvalidB58Char('(unknown)', data);
	  }
	  try {
	    data = Base58Check.decode(data);
	  } catch (e) {
	    return new errors.InvalidB58Checksum(data);
	  }
	  if (data.length !== HDPrivateKey.DataLength) {
	    return new hdErrors.InvalidLength(data);
	  }
	  if (!_.isUndefined(network)) {
	    var error = HDPrivateKey._validateNetwork(data, network);
	    if (error) {
	      return error;
	    }
	  }
	  return null;
	};

	HDPrivateKey._validateNetwork = function(data, networkArg) {
	  var network = Network.get(networkArg);
	  if (!network) {
	    return new errors.InvalidNetworkArgument(networkArg);
	  }
	  var version = data.slice(0, 4);
	  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {
	    return new errors.InvalidNetwork(version);
	  }
	  return null;
	};

	HDPrivateKey.fromJSON = HDPrivateKey.fromObject = HDPrivateKey.fromString = function(arg) {
	  return new HDPrivateKey(arg);
	};

	HDPrivateKey.prototype._buildFromJSON = function(arg) {
	  return this._buildFromObject(JSON.parse(arg));
	};

	HDPrivateKey.prototype._buildFromObject = function(arg) {
	  /* jshint maxcomplexity: 12 */
	  // TODO: Type validation
	  var buffers = {
	    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,
	    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
	    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
	    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
	    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,
	    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? BufferUtil.hexToBuffer(arg.privateKey) : arg.privateKey,
	    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined
	  };
	  return this._buildFromBuffers(buffers);
	};

	HDPrivateKey.prototype._buildFromSerialized = function(arg) {
	  var decoded = Base58Check.decode(arg);
	  var buffers = {
	    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),
	    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),
	    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,
	                                     HDPrivateKey.ParentFingerPrintEnd),
	    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),
	    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),
	    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),
	    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),
	    xprivkey: arg
	  };
	  return this._buildFromBuffers(buffers);
	};

	HDPrivateKey.prototype._generateRandomly = function(network) {
	  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);
	};

	/**
	 * Generate a private key from a seed, as described in BIP32
	 *
	 * @param {string|Buffer} hexa
	 * @param {*} network
	 * @return HDPrivateKey
	 */
	HDPrivateKey.fromSeed = function(hexa, network) {
	  /* jshint maxcomplexity: 8 */
	  if (JSUtil.isHexaString(hexa)) {
	    hexa = BufferUtil.hexToBuffer(hexa);
	  }
	  if (!Buffer.isBuffer(hexa)) {
	    throw new hdErrors.InvalidEntropyArgument(hexa);
	  }
	  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
	    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);
	  }
	  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
	    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);
	  }
	  var hash = Hash.sha512hmac(hexa, new buffer.Buffer('Bitcoin seed'));

	  return new HDPrivateKey({
	    network: Network.get(network) || Network.defaultNetwork,
	    depth: 0,
	    parentFingerPrint: 0,
	    childIndex: 0,
	    privateKey: hash.slice(0, 32),
	    chainCode: hash.slice(32, 64)
	  });
	};

	/**
	 * Receives a object with buffers in all the properties and populates the
	 * internal structure
	 *
	 * @param {Object} arg
	 * @param {buffer.Buffer} arg.version
	 * @param {buffer.Buffer} arg.depth
	 * @param {buffer.Buffer} arg.parentFingerPrint
	 * @param {buffer.Buffer} arg.childIndex
	 * @param {buffer.Buffer} arg.chainCode
	 * @param {buffer.Buffer} arg.privateKey
	 * @param {buffer.Buffer} arg.checksum
	 * @param {string=} arg.xprivkey - if set, don't recalculate the base58
	 *      representation
	 * @return {HDPrivateKey} this
	 */
	HDPrivateKey.prototype._buildFromBuffers = function(arg) {
	  /* jshint maxcomplexity: 8 */
	  /* jshint maxstatements: 20 */

	  HDPrivateKey._validateBufferArguments(arg);

	  JSUtil.defineImmutable(this, {
	    _buffers: arg
	  });

	  var sequence = [
	    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,
	    BufferUtil.emptyBuffer(1), arg.privateKey
	  ];
	  var concat = buffer.Buffer.concat(sequence);
	  if (!arg.checksum || !arg.checksum.length) {
	    arg.checksum = Base58Check.checksum(concat);
	  } else {
	    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {
	      throw new errors.InvalidB58Checksum(concat);
	    }
	  }

	  var xprivkey;

	  if (!arg.xprivkey) {
	    xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));
	  } else {
	    xprivkey = arg.xprivkey;
	  }

	  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey));
	  var publicKey = privateKey.toPublicKey();
	  var size = HDPrivateKey.ParentFingerPrintSize;
	  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);

	  JSUtil.defineImmutable(this, {
	    xprivkey: xprivkey,
	    network: Network.get(BufferUtil.integerFromBuffer(arg.version)),
	    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
	    privateKey: privateKey,
	    publicKey: publicKey,
	    fingerPrint: fingerPrint
	  });

	  var HDPublicKey = __webpack_require__(59);
	  var hdPublicKey = new HDPublicKey(this);

	  JSUtil.defineImmutable(this, {
	    hdPublicKey: hdPublicKey,
	    xpubkey: hdPublicKey.xpubkey
	  });

	  return this;
	};

	HDPrivateKey._validateBufferArguments = function(arg) {
	  var checkBuffer = function(name, size) {
	    var buff = arg[name];
	    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');
	    assert(
	      buff.length === size,
	      name + ' has not the expected size: found ' + buff.length + ', expected ' + size
	    );
	  };
	  checkBuffer('version', HDPrivateKey.VersionSize);
	  checkBuffer('depth', HDPrivateKey.DepthSize);
	  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);
	  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);
	  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);
	  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);
	  if (arg.checksum && arg.checksum.length) {
	    checkBuffer('checksum', HDPrivateKey.CheckSumSize);
	  }
	};

	/**
	 * Returns the string representation of this private key (a string starting
	 * with "xprv..."
	 *
	 * @return string
	 */
	HDPrivateKey.prototype.toString = function() {
	  return this.xprivkey;
	};

	/**
	 * Returns the console representation of this extended private key.
	 * @return string
	 */
	HDPrivateKey.prototype.inspect = function() {
	  return '<HDPrivateKey: ' + this.xprivkey + '>';
	};

	/**
	 * Returns a plain object with a representation of this private key.
	 *
	 * Fields include:<ul>
	 * <li> network: either 'livenet' or 'testnet'
	 * <li> depth: a number ranging from 0 to 255
	 * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the
	 * <li>     associated public key
	 * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash
	 * <li>     of this parent's associated public key or zero.
	 * <li> childIndex: the index from which this child was derived (or zero)
	 * <li> chainCode: an hexa string representing a number used in the derivation
	 * <li> privateKey: the private key associated, in hexa representation
	 * <li> xprivkey: the representation of this extended private key in checksum
	 * <li>     base58 format
	 * <li> checksum: the base58 checksum of xprivkey
	 * </ul>
	 *  @return {Object}
	 */
	HDPrivateKey.prototype.toObject = function toObject() {
	  return {
	    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,
	    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
	    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
	    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
	    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
	    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),
	    privateKey: this.privateKey.toBuffer().toString('hex'),
	    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
	    xprivkey: this.xprivkey
	  };
	};

	HDPrivateKey.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	HDPrivateKey.DefaultDepth = 0;
	HDPrivateKey.DefaultFingerprint = 0;
	HDPrivateKey.DefaultChildIndex = 0;
	HDPrivateKey.Hardened = 0x80000000;
	HDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;

	HDPrivateKey.RootElementAlias = ['m', 'M', 'm\'', 'M\''];

	HDPrivateKey.VersionSize = 4;
	HDPrivateKey.DepthSize = 1;
	HDPrivateKey.ParentFingerPrintSize = 4;
	HDPrivateKey.ChildIndexSize = 4;
	HDPrivateKey.ChainCodeSize = 32;
	HDPrivateKey.PrivateKeySize = 32;
	HDPrivateKey.CheckSumSize = 4;

	HDPrivateKey.DataLength = 78;
	HDPrivateKey.SerializedByteSize = 82;

	HDPrivateKey.VersionStart           = 0;
	HDPrivateKey.VersionEnd             = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;
	HDPrivateKey.DepthStart             = HDPrivateKey.VersionEnd;
	HDPrivateKey.DepthEnd               = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;
	HDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;
	HDPrivateKey.ParentFingerPrintEnd   = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;
	HDPrivateKey.ChildIndexStart        = HDPrivateKey.ParentFingerPrintEnd;
	HDPrivateKey.ChildIndexEnd          = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;
	HDPrivateKey.ChainCodeStart         = HDPrivateKey.ChildIndexEnd;
	HDPrivateKey.ChainCodeEnd           = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;
	HDPrivateKey.PrivateKeyStart        = HDPrivateKey.ChainCodeEnd + 1;
	HDPrivateKey.PrivateKeyEnd          = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;
	HDPrivateKey.ChecksumStart          = HDPrivateKey.PrivateKeyEnd;
	HDPrivateKey.ChecksumEnd            = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;

	assert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);

	module.exports = HDPrivateKey;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);
	var BN = __webpack_require__(6);
	var Base58 = __webpack_require__(34);
	var Base58Check = __webpack_require__(27);
	var Hash = __webpack_require__(7);
	var HDPrivateKey = __webpack_require__(58);
	var HDKeyCache = __webpack_require__(39);
	var Network = __webpack_require__(19);
	var Point = __webpack_require__(23);
	var PublicKey = __webpack_require__(13);

	var bitcoreErrors = __webpack_require__(15);
	var errors = bitcoreErrors;
	var hdErrors = bitcoreErrors.HDPublicKey;
	var assert = __webpack_require__(8);

	var JSUtil = __webpack_require__(4);
	var BufferUtil = __webpack_require__(3);

	/**
	 * The representation of an hierarchically derived public key.
	 *
	 * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
	 *
	 * @constructor
	 * @param {Object|string|Buffer} arg
	 */
	function HDPublicKey(arg) {
	  /* jshint maxcomplexity: 12 */
	  /* jshint maxstatements: 20 */
	  if (arg instanceof HDPublicKey) {
	    return arg;
	  }
	  if (!(this instanceof HDPublicKey)) {
	    return new HDPublicKey(arg);
	  }
	  if (arg) {
	    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
	      var error = HDPublicKey.getSerializedError(arg);
	      if (!error) {
	        return this._buildFromSerialized(arg);
	      } else if (JSUtil.isValidJSON(arg)) {
	        return this._buildFromJSON(arg);
	      } else {
	        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {
	          return new HDPrivateKey(arg).hdPublicKey;
	        }
	        throw error;
	      }
	    } else {
	      if (_.isObject(arg)) {
	        if (arg instanceof HDPrivateKey) {
	          return this._buildFromPrivate(arg);
	        } else {
	          return this._buildFromObject(arg);
	        }
	      } else {
	        throw new hdErrors.UnrecognizedArgument(arg);
	      }
	    }
	  } else {
	    throw new hdErrors.MustSupplyArgument();
	  }
	}

	/**
	 * Verifies that a given path is valid.
	 *
	 * @param {string|number} arg
	 * @return {boolean}
	 */
	HDPublicKey.isValidPath = function(arg) {
	  if (_.isString(arg)) {
	    var indexes = HDPrivateKey._getDerivationIndexes(arg);
	    return indexes !== null && _.all(indexes, HDPublicKey.isValidPath);
	  }

	  if (_.isNumber(arg)) {
	    return arg >= 0 && arg < HDPublicKey.Hardened;
	  }

	  return false;
	};

	/**
	 * Get a derivated child based on a string or number.
	 *
	 * If the first argument is a string, it's parsed as the full path of
	 * derivation. Valid values for this argument include "m" (which returns the
	 * same private key), "m/0/1/40/2/1000".
	 *
	 * Note that hardened keys can't be derived from a public extended key.
	 *
	 * If the first argument is a number, the child with that index will be
	 * derived. See the example usage for clarification.
	 *
	 * @example
	 * ```javascript
	 * var parent = new HDPublicKey('xpub...');
	 * var child_0_1_2 = parent.derive(0).derive(1).derive(2);
	 * var copy_of_child_0_1_2 = parent.derive("m/0/1/2");
	 * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);
	 * ```
	 *
	 * @param {string|number} arg
	 */
	HDPublicKey.prototype.derive = function (arg) {
	  if (_.isNumber(arg)) {
	    return this._deriveWithNumber(arg);
	  } else if (_.isString(arg)) {
	    return this._deriveFromString(arg);
	  } else {
	    throw new hdErrors.InvalidDerivationArgument(arg);
	  }
	};

	HDPublicKey.prototype._deriveWithNumber = function (index) {
	  if (index >= HDPublicKey.Hardened) {
	    throw new hdErrors.InvalidIndexCantDeriveHardened();
	  }
	  if (index < 0) {
	    throw new hdErrors.InvalidPath(index);
	  }
	  var cached = HDKeyCache.get(this.xpubkey, index, false);
	  if (cached) {
	    return cached;
	  }

	  var indexBuffer = BufferUtil.integerAsBuffer(index);
	  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
	  var hash = Hash.sha512hmac(data, this._buffers.chainCode);
	  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});
	  var chainCode = hash.slice(32, 64);

	  var publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));

	  var derived = new HDPublicKey({
	    network: this.network,
	    depth: this.depth + 1,
	    parentFingerPrint: this.fingerPrint,
	    childIndex: index,
	    chainCode: chainCode,
	    publicKey: publicKey
	  });
	  HDKeyCache.set(this.xpubkey, index, false, derived);
	  return derived;
	};

	HDPublicKey.prototype._deriveFromString = function (path) {
	  /* jshint maxcomplexity: 8 */
	  if (_.contains(path, "'")) {
	    throw new hdErrors.InvalidIndexCantDeriveHardened();
	  } else if (!HDPublicKey.isValidPath(path)) {
	    throw new hdErrors.InvalidPath(path);
	  }

	  var indexes = HDPrivateKey._getDerivationIndexes(path);
	  var derived = indexes.reduce(function(prev, index) {
	    return prev._deriveWithNumber(index);
	  }, this);

	  return derived;
	};

	/**
	 * Verifies that a given serialized private key in base58 with checksum format
	 * is valid.
	 *
	 * @param {string|Buffer} data - the serialized private key
	 * @param {string|Network=} network - optional, if present, checks that the
	 *     network provided matches the network serialized.
	 * @return {boolean}
	 */
	HDPublicKey.isValidSerialized = function (data, network) {
	  return _.isNull(HDPublicKey.getSerializedError(data, network));
	};

	/**
	 * Checks what's the error that causes the validation of a serialized private key
	 * in base58 with checksum to fail.
	 *
	 * @param {string|Buffer} data - the serialized private key
	 * @param {string|Network=} network - optional, if present, checks that the
	 *     network provided matches the network serialized.
	 * @return {errors|null}
	 */
	HDPublicKey.getSerializedError = function (data, network) {
	  /* jshint maxcomplexity: 10 */
	  /* jshint maxstatements: 20 */
	  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
	    return new hdErrors.UnrecognizedArgument('expected buffer or string');
	  }
	  if (!Base58.validCharacters(data)) {
	    return new errors.InvalidB58Char('(unknown)', data);
	  }
	  try {
	    data = Base58Check.decode(data);
	  } catch (e) {
	    return new errors.InvalidB58Checksum(data);
	  }
	  if (data.length !== HDPublicKey.DataSize) {
	    return new errors.InvalidLength(data);
	  }
	  if (!_.isUndefined(network)) {
	    var error = HDPublicKey._validateNetwork(data, network);
	    if (error) {
	      return error;
	    }
	  }
	  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));
	  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {
	    return new hdErrors.ArgumentIsPrivateExtended();
	  }
	  return null;
	};

	HDPublicKey._validateNetwork = function (data, networkArg) {
	  var network = Network.get(networkArg);
	  if (!network) {
	    return new errors.InvalidNetworkArgument(networkArg);
	  }
	  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);
	  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {
	    return new errors.InvalidNetwork(version);
	  }
	  return null;
	};

	HDPublicKey.prototype._buildFromJSON = function (arg) {
	  return this._buildFromObject(JSON.parse(arg));
	};

	HDPublicKey.prototype._buildFromPrivate = function (arg) {
	  var args = _.clone(arg._buffers);
	  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));
	  args.publicKey = Point.pointToCompressed(point);
	  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);
	  args.privateKey = undefined;
	  args.checksum = undefined;
	  args.xprivkey = undefined;
	  return this._buildFromBuffers(args);
	};

	HDPublicKey.prototype._buildFromObject = function (arg) {
	  /* jshint maxcomplexity: 10 */
	  // TODO: Type validation
	  var buffers = {
	    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,
	    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
	    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
	    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
	    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,
	    publicKey: _.isString(arg.publicKey) ? BufferUtil.hexToBuffer(arg.publicKey) :
	      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),
	    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum
	  };
	  return this._buildFromBuffers(buffers);
	};

	HDPublicKey.prototype._buildFromSerialized = function (arg) {
	  var decoded = Base58Check.decode(arg);
	  var buffers = {
	    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),
	    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),
	    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,
	                                     HDPublicKey.ParentFingerPrintEnd),
	    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),
	    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),
	    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),
	    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),
	    xpubkey: arg
	  };
	  return this._buildFromBuffers(buffers);
	};

	/**
	 * Receives a object with buffers in all the properties and populates the
	 * internal structure
	 *
	 * @param {Object} arg
	 * @param {buffer.Buffer} arg.version
	 * @param {buffer.Buffer} arg.depth
	 * @param {buffer.Buffer} arg.parentFingerPrint
	 * @param {buffer.Buffer} arg.childIndex
	 * @param {buffer.Buffer} arg.chainCode
	 * @param {buffer.Buffer} arg.publicKey
	 * @param {buffer.Buffer} arg.checksum
	 * @param {string=} arg.xpubkey - if set, don't recalculate the base58
	 *      representation
	 * @return {HDPublicKey} this
	 */
	HDPublicKey.prototype._buildFromBuffers = function (arg) {
	  /* jshint maxcomplexity: 8 */
	  /* jshint maxstatements: 20 */

	  HDPublicKey._validateBufferArguments(arg);

	  JSUtil.defineImmutable(this, {
	    _buffers: arg
	  });

	  var sequence = [
	    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,
	    arg.publicKey
	  ];
	  var concat = BufferUtil.concat(sequence);
	  var checksum = Base58Check.checksum(concat);
	  if (!arg.checksum || !arg.checksum.length) {
	    arg.checksum = checksum;
	  } else {
	    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {
	      throw new errors.InvalidB58Checksum(concat, checksum);
	    }
	  }

	  var xpubkey;

	  if (!arg.xpubkey) {
	    xpubkey = Base58Check.encode(BufferUtil.concat(sequence));
	  } else {
	    xpubkey = arg.xpubkey;
	  }

	  var publicKey = PublicKey.fromString(arg.publicKey);
	  var size = HDPublicKey.ParentFingerPrintSize;
	  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);

	  JSUtil.defineImmutable(this, {
	    xpubkey: xpubkey,
	    network: Network.get(BufferUtil.integerFromBuffer(arg.version)),
	    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
	    publicKey: publicKey,
	    fingerPrint: fingerPrint
	  });

	  return this;
	};

	HDPublicKey._validateBufferArguments = function (arg) {
	  var checkBuffer = function(name, size) {
	    var buff = arg[name];
	    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\'s ' + typeof buff);
	    assert(
	      buff.length === size,
	      name + ' has not the expected size: found ' + buff.length + ', expected ' + size
	    );
	  };
	  checkBuffer('version', HDPublicKey.VersionSize);
	  checkBuffer('depth', HDPublicKey.DepthSize);
	  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);
	  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);
	  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);
	  checkBuffer('publicKey', HDPublicKey.PublicKeySize);
	  if (arg.checksum && arg.checksum.length) {
	    checkBuffer('checksum', HDPublicKey.CheckSumSize);
	  }
	};

	HDPublicKey.fromString = HDPublicKey.fromObject = HDPublicKey.fromJSON = function(arg) {
	  return new HDPublicKey(arg);
	};

	/**
	 * Returns the base58 checked representation of the public key
	 * @return {string} a string starting with "xpub..." in livenet
	 */
	HDPublicKey.prototype.toString = function () {
	  return this.xpubkey;
	};

	/**
	 * Returns the console representation of this extended public key.
	 * @return string
	 */
	HDPublicKey.prototype.inspect = function() {
	  return '<HDPublicKey: ' + this.xpubkey + '>';
	};

	/**
	 * Returns a plain javascript object with information to reconstruct a key.
	 *
	 * Fields are: <ul>
	 *  <li> network: 'livenet' or 'testnet'
	 *  <li> depth: a number from 0 to 255, the depth to the master extended key
	 *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key
	 *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's
	 *  <li>     parent's public key
	 *  <li> childIndex: index with which this key was derived
	 *  <li> chainCode: string in hexa encoding used for derivation
	 *  <li> publicKey: string, hexa encoded, in compressed key format
	 *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
	 *  <li> xpubkey: the string with the base58 representation of this extended key
	 *  <li> checksum: the base58 checksum of xpubkey
	 * </ul>
	 */
	HDPublicKey.prototype.toObject = function toObject() {
	  return {
	    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,
	    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
	    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
	    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
	    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
	    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),
	    publicKey: this.publicKey.toString(),
	    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
	    xpubkey: this.xpubkey
	  };
	};

	/**
	 * Serializes this object into a JSON string
	 * @return {string}
	 */
	HDPublicKey.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	HDPublicKey.Hardened = 0x80000000;
	HDPublicKey.RootElementAlias = ['m', 'M'];

	HDPublicKey.VersionSize = 4;
	HDPublicKey.DepthSize = 1;
	HDPublicKey.ParentFingerPrintSize = 4;
	HDPublicKey.ChildIndexSize = 4;
	HDPublicKey.ChainCodeSize = 32;
	HDPublicKey.PublicKeySize = 33;
	HDPublicKey.CheckSumSize = 4;

	HDPublicKey.DataSize = 78;
	HDPublicKey.SerializedByteSize = 82;

	HDPublicKey.VersionStart           = 0;
	HDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;
	HDPublicKey.DepthStart             = HDPublicKey.VersionEnd;
	HDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;
	HDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;
	HDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;
	HDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;
	HDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;
	HDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;
	HDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;
	HDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;
	HDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;
	HDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;
	HDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;

	assert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);
	assert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);

	module.exports = HDPublicKey;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';


	var Address = __webpack_require__(17);
	var BufferReader = __webpack_require__(18);
	var BufferWriter = __webpack_require__(12);
	var Hash = __webpack_require__(7);
	var Opcode = __webpack_require__(40);
	var PublicKey = __webpack_require__(13);
	var Signature = __webpack_require__(14);
	var Networks = __webpack_require__(19);

	var $ = __webpack_require__(5);
	var _ = __webpack_require__(2);
	var errors = __webpack_require__(15);
	var buffer = __webpack_require__(1);
	var BufferUtil = __webpack_require__(3);
	var JSUtil = __webpack_require__(4);

	/**
	 * A bitcoin transaction script. Each transaction's inputs and outputs
	 * has a script that is evaluated to validate it's spending.
	 *
	 * See https://en.bitcoin.it/wiki/Script
	 *
	 * @constructor
	 * @param {Object|string|Buffer} [from] optional data to populate script
	 */
	var Script = function Script(from) {
	  if (!(this instanceof Script)) {
	    return new Script(from);
	  }

	  this.chunks = [];

	  if (BufferUtil.isBuffer(from)) {
	    return Script.fromBuffer(from);
	  } else if (from instanceof Address) {
	    return Script.fromAddress(from);
	  } else if (from instanceof Script) {
	    return Script.fromBuffer(from.toBuffer());
	  } else if (typeof from === 'string') {
	    return Script.fromString(from);
	  } else if (typeof from !== 'undefined') {
	    this.set(from);
	  }
	};

	Script.prototype.set = function(obj) {
	  this.chunks = obj.chunks || this.chunks;
	  return this;
	};

	Script.fromBuffer = function(buffer) {
	  var script = new Script();
	  script.chunks = [];

	  var br = new BufferReader(buffer);
	  while (!br.finished()) {
	    var opcodenum = br.readUInt8();

	    var len, buf;
	    if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
	      len = opcodenum;
	      script.chunks.push({
	        buf: br.read(len),
	        len: len,
	        opcodenum: opcodenum
	      });
	    } else if (opcodenum === Opcode.OP_PUSHDATA1) {
	      len = br.readUInt8();
	      buf = br.read(len);
	      script.chunks.push({
	        buf: buf,
	        len: len,
	        opcodenum: opcodenum
	      });
	    } else if (opcodenum === Opcode.OP_PUSHDATA2) {
	      len = br.readUInt16LE();
	      buf = br.read(len);
	      script.chunks.push({
	        buf: buf,
	        len: len,
	        opcodenum: opcodenum
	      });
	    } else if (opcodenum === Opcode.OP_PUSHDATA4) {
	      len = br.readUInt32LE();
	      buf = br.read(len);
	      script.chunks.push({
	        buf: buf,
	        len: len,
	        opcodenum: opcodenum
	      });
	    } else {
	      script.chunks.push({
	        opcodenum: opcodenum
	      });
	    }
	  }

	  return script;
	};

	Script.prototype.toBuffer = function() {
	  var bw = new BufferWriter();

	  for (var i = 0; i < this.chunks.length; i++) {
	    var chunk = this.chunks[i];
	    var opcodenum = chunk.opcodenum;
	    bw.writeUInt8(chunk.opcodenum);
	    if (chunk.buf) {
	      if (opcodenum < Opcode.OP_PUSHDATA1) {
	        bw.write(chunk.buf);
	      } else if (opcodenum === Opcode.OP_PUSHDATA1) {
	        bw.writeUInt8(chunk.len);
	        bw.write(chunk.buf);
	      } else if (opcodenum === Opcode.OP_PUSHDATA2) {
	        bw.writeUInt16LE(chunk.len);
	        bw.write(chunk.buf);
	      } else if (opcodenum === Opcode.OP_PUSHDATA4) {
	        bw.writeUInt32LE(chunk.len);
	        bw.write(chunk.buf);
	      }
	    }
	  }

	  return bw.concat();
	};

	Script.fromString = function(str) {
	  if (JSUtil.isHexa(str) || str.length === 0) {
	    return new Script(new buffer.Buffer(str, 'hex'));
	  }
	  var script = new Script();
	  script.chunks = [];

	  var tokens = str.split(' ');
	  var i = 0;
	  while (i < tokens.length) {
	    var token = tokens[i];
	    var opcode = Opcode(token);
	    var opcodenum = opcode.toNumber();

	    if (_.isUndefined(opcodenum)) {
	      opcodenum = parseInt(token);
	      if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
	        script.chunks.push({
	          buf: new Buffer(tokens[i + 1].slice(2), 'hex'),
	          len: opcodenum,
	          opcodenum: opcodenum
	        });
	        i = i + 2;
	      } else {
	        throw new Error('Invalid script: ' + JSON.stringify(str));
	      }
	    } else if (opcodenum === Opcode.OP_PUSHDATA1 ||
	      opcodenum === Opcode.OP_PUSHDATA2 ||
	      opcodenum === Opcode.OP_PUSHDATA4) {
	      if (tokens[i + 2].slice(0, 2) !== '0x') {
	        throw new Error('Pushdata data must start with 0x');
	      }
	      script.chunks.push({
	        buf: new Buffer(tokens[i + 2].slice(2), 'hex'),
	        len: parseInt(tokens[i + 1]),
	        opcodenum: opcodenum
	      });
	      i = i + 3;
	    } else {
	      script.chunks.push({
	        opcodenum: opcodenum
	      });
	      i = i + 1;
	    }
	  }
	  return script;
	};

	Script.prototype.toString = function() {
	  var str = '';
	  for (var i = 0; i < this.chunks.length; i++) {
	    var chunk = this.chunks[i];
	    var opcodenum = chunk.opcodenum;
	    if (!chunk.buf) {
	      if (typeof Opcode.reverseMap[opcodenum] !== 'undefined') {
	        str = str + ' ' + Opcode(opcodenum).toString();
	      } else {
	        var numstr = opcodenum.toString(16);
	        if (numstr.length % 2 !== 0) {
	          numstr = '0' + numstr;
	        }
	        str = str + ' ' + '0x' + numstr;
	      }
	    } else {
	      if (opcodenum === Opcode.OP_PUSHDATA1 ||
	        opcodenum === Opcode.OP_PUSHDATA2 ||
	        opcodenum === Opcode.OP_PUSHDATA4) {
	        str = str + ' ' + Opcode(opcodenum).toString();
	      }
	      str = str + ' ' + chunk.len;
	      if (chunk.len > 0) {
	        str = str + ' ' + '0x' + chunk.buf.toString('hex');
	      }
	    }
	  }

	  return str.substr(1);
	};

	Script.prototype.toHex = function() {
	  return this.toBuffer().toString('hex');
	};

	Script.prototype.inspect = function() {
	  return '<Script: ' + this.toString() + '>';
	};

	// script classification methods

	/**
	 * @returns {boolean} if this is a pay to pubkey hash output script
	 */
	Script.prototype.isPublicKeyHashOut = function() {
	  return !!(this.chunks.length === 5 &&
	    this.chunks[0].opcodenum === Opcode.OP_DUP &&
	    this.chunks[1].opcodenum === Opcode.OP_HASH160 &&
	    this.chunks[2].buf &&
	    this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY &&
	    this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);
	};

	/**
	 * @returns {boolean} if this is a pay to public key hash input script
	 */
	Script.prototype.isPublicKeyHashIn = function() {
	  return this.chunks.length === 2 &&
	    this.chunks[0].buf &&
	    this.chunks[0].buf.length >= 0x47 &&
	    this.chunks[0].buf.length <= 0x49 &&
	    PublicKey.isValid(this.chunks[1].buf);
	};

	Script.prototype.getPublicKeyHash = function() {
	  $.checkState(this.isPublicKeyHashOut(), 'Can\'t retrieve PublicKeyHash from a non-PKH output');
	  return this.chunks[2].buf;
	};

	/**
	 * @returns {boolean} if this is a public key output script
	 */
	Script.prototype.isPublicKeyOut = function() {
	  return this.chunks.length === 2 &&
	    BufferUtil.isBuffer(this.chunks[0].buf) &&
	    PublicKey.isValid(this.chunks[0].buf) &&
	    this.chunks[1].opcodenum === Opcode.OP_CHECKSIG;
	};

	/**
	 * @returns {boolean} if this is a pay to public key input script
	 */
	Script.prototype.isPublicKeyIn = function() {
	  return this.chunks.length === 1 &&
	    BufferUtil.isBuffer(this.chunks[0].buf) &&
	    this.chunks[0].buf.length === 0x47;
	};


	/**
	 * @returns {boolean} if this is a p2sh output script
	 */
	Script.prototype.isScriptHashOut = function() {
	  var buf = this.toBuffer();
	  return (buf.length === 23 &&
	    buf[0] === Opcode.OP_HASH160 &&
	    buf[1] === 0x14 &&
	    buf[buf.length - 1] === Opcode.OP_EQUAL);
	};

	/** 
	 * @returns {boolean} if this is a p2sh input script
	 * Note that these are frequently indistinguishable from pubkeyhashin
	 */
	Script.prototype.isScriptHashIn = function() {
	  if (this.chunks.length === 0) {
	    return false;
	  }
	  var chunk = this.chunks[this.chunks.length - 1];
	  if (!chunk) {
	    return false;
	  }
	  var scriptBuf = chunk.buf;
	  if (!scriptBuf) {
	    return false;
	  }
	  var redeemScript = new Script(scriptBuf);
	  var type = redeemScript.classify();
	  return type !== Script.types.UNKNOWN;
	};

	/**
	 * @returns {boolean} if this is a mutlsig output script
	 */
	Script.prototype.isMultisigOut = function() {
	  return (this.chunks.length > 3 &&
	    Opcode.isSmallIntOp(this.chunks[0].opcodenum) &&
	    this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {
	      return obj.buf && BufferUtil.isBuffer(obj.buf);
	    }) &&
	    Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) &&
	    this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG);
	};


	/**
	 * @returns {boolean} if this is a multisig input script
	 */
	Script.prototype.isMultisigIn = function() {
	  return this.chunks.length >= 2 &&
	    this.chunks[0].opcodenum === 0 &&
	    this.chunks.slice(1, this.chunks.length).every(function(obj) {
	      return obj.buf &&
	        BufferUtil.isBuffer(obj.buf) &&
	        obj.buf.length === 0x47;
	    });
	};

	/**
	 * @returns {boolean} if this is an OP_RETURN data script
	 */
	Script.prototype.isDataOut = function() {
	  return this.chunks.length >= 1 &&
	    this.chunks[0].opcodenum === Opcode.OP_RETURN &&
	    (this.chunks.length === 1 ||
	      (this.chunks.length === 2 &&
	        this.chunks[1].buf &&
	        this.chunks[1].buf.length <= 40 &&
	        this.chunks[1].length === this.chunks.len));
	};

	/**
	 * Retrieve the associated data for this script.
	 * In the case of a pay to public key hash or P2SH, return the hash.
	 * In the case of a standard OP_RETURN, return the data
	 * @returns {Buffer}
	 */
	Script.prototype.getData = function() {
	  if (this.isDataOut() || this.isScriptHashOut()) {
	    return new Buffer(this.chunks[1].buf);
	  }
	  if (this.isPublicKeyHashOut()) {
	    return new Buffer(this.chunks[2].buf);
	  }
	  throw new Error('Unrecognized script type to get data from');
	};

	/**
	 * @returns {boolean} if the script is only composed of data pushing
	 * opcodes or small int opcodes (OP_0, OP_1, ..., OP_16)
	 */
	Script.prototype.isPushOnly = function() {
	  return _.every(this.chunks, function(chunk) {
	    return chunk.opcodenum <= Opcode.OP_16;
	  });
	};


	Script.types = {};
	Script.types.UNKNOWN = 'Unknown';
	Script.types.PUBKEY_OUT = 'Pay to public key';
	Script.types.PUBKEY_IN = 'Spend from public key';
	Script.types.PUBKEYHASH_OUT = 'Pay to public key hash';
	Script.types.PUBKEYHASH_IN = 'Spend from public key hash';
	Script.types.SCRIPTHASH_OUT = 'Pay to script hash';
	Script.types.SCRIPTHASH_IN = 'Spend from script hash';
	Script.types.MULTISIG_OUT = 'Pay to multisig';
	Script.types.MULTISIG_IN = 'Spend from multisig';
	Script.types.DATA_OUT = 'Data push';

	Script.identifiers = {};
	Script.identifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;
	Script.identifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;
	Script.identifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;
	Script.identifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;
	Script.identifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;
	Script.identifiers.MULTISIG_IN = Script.prototype.isMultisigIn;
	Script.identifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;
	Script.identifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;
	Script.identifiers.DATA_OUT = Script.prototype.isDataOut;

	/**
	 * @returns {object} The Script type if it is a known form,
	 * or Script.UNKNOWN if it isn't
	 */
	Script.prototype.classify = function() {
	  for (var type in Script.identifiers) {
	    if (Script.identifiers[type].bind(this)()) {
	      return Script.types[type];
	    }
	  }
	  return Script.types.UNKNOWN;
	};


	/**
	 * @returns {boolean} if script is one of the known types
	 */
	Script.prototype.isStandard = function() {
	  // TODO: Add BIP62 compliance
	  return this.classify() !== Script.types.UNKNOWN;
	};


	// Script construction methods

	/**
	 * Adds a script element at the start of the script.
	 * @param {*} obj a string, number, Opcode, Bufer, or object to add
	 * @returns {Script} this script instance
	 */
	Script.prototype.prepend = function(obj) {
	  this._addByType(obj, true);
	  return this;
	};

	/**
	 * Compares a script with another script
	 */
	Script.prototype.equals = function(script) {
	  $.checkState(script instanceof Script, 'Must provide another script');
	  if (this.chunks.length !== script.chunks.length) {
	    return false;
	  }
	  var i;
	  for (i = 0; i < this.chunks.length; i++) {
	    if (BufferUtil.isBuffer(this.chunks[i]) && !BufferUtil.isBuffer(script.chunks[i])) {
	      return false;
	    } else if (this.chunks[i] instanceof Opcode && !(script.chunks[i] instanceof Opcode)) {
	      return false;
	    }
	    if (BufferUtil.isBuffer(this.chunks[i]) && !BufferUtil.equals(this.chunks[i], script.chunks[i])) {
	      return false;
	    } else if (this.chunks[i].num !== script.chunks[i].num) {
	      return false;
	    }
	  }
	  return true;
	};

	/**
	 * Adds a script element to the end of the script.
	 *
	 * @param {*} obj a string, number, Opcode, Bufer, or object to add
	 * @returns {Script} this script instance
	 *
	 */
	Script.prototype.add = function(obj) {
	  this._addByType(obj, false);
	  return this;
	};

	Script.prototype._addByType = function(obj, prepend) {
	  if (typeof obj === 'string') {
	    this._addOpcode(obj, prepend);
	  } else if (typeof obj === 'number') {
	    this._addOpcode(obj, prepend);
	  } else if (obj instanceof Opcode) {
	    this._addOpcode(obj, prepend);
	  } else if (BufferUtil.isBuffer(obj)) {
	    this._addBuffer(obj, prepend);
	  } else if (typeof obj === 'object') {
	    this._insertAtPosition(obj, prepend);
	  } else if (obj instanceof Script) {
	    this.chunks = this.chunks.concat(obj.chunks);
	  } else {
	    throw new Error('Invalid script chunk');
	  }
	};

	Script.prototype._insertAtPosition = function(op, prepend) {
	  if (prepend) {
	    this.chunks.unshift(op);
	  } else {
	    this.chunks.push(op);
	  }
	};

	Script.prototype._addOpcode = function(opcode, prepend) {
	  var op;
	  if (typeof opcode === 'number') {
	    op = opcode;
	  } else if (opcode instanceof Opcode) {
	    op = opcode.toNumber();
	  } else {
	    op = Opcode(opcode).toNumber();
	  }
	  this._insertAtPosition({
	    opcodenum: op
	  }, prepend);
	  return this;
	};

	Script.prototype._addBuffer = function(buf, prepend) {
	  var opcodenum;
	  var len = buf.length;
	  if (len >= 0 && len < Opcode.OP_PUSHDATA1) {
	    opcodenum = len;
	  } else if (len < Math.pow(2, 8)) {
	    opcodenum = Opcode.OP_PUSHDATA1;
	  } else if (len < Math.pow(2, 16)) {
	    opcodenum = Opcode.OP_PUSHDATA2;
	  } else if (len < Math.pow(2, 32)) {
	    opcodenum = Opcode.OP_PUSHDATA4;
	  } else {
	    throw new Error('You can\'t push that much data');
	  }
	  this._insertAtPosition({
	    buf: buf,
	    len: len,
	    opcodenum: opcodenum
	  }, prepend);
	  return this;
	};

	Script.prototype.removeCodeseparators = function() {
	  var chunks = [];
	  for (var i = 0; i < this.chunks.length; i++) {
	    if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {
	      chunks.push(this.chunks[i]);
	    }
	  }
	  this.chunks = chunks;
	  return this;
	};

	// high level script builder methods

	/**
	 * @returns {Script} a new Multisig output script for given public keys,
	 * requiring m of those public keys to spend
	 * @param {PublicKey[]} publicKeys - list of all public keys controlling the output
	 * @param {number} threshold - amount of required signatures to spend the output
	 * @param {Object} [opts] - Several options:
	 *        - noSorting: defaults to false, if true, don't sort the given
	 *                      public keys before creating the script
	 */
	Script.buildMultisigOut = function(publicKeys, threshold, opts) {
	  opts = opts || {};
	  var script = new Script();
	  script.add(Opcode.smallInt(threshold));
	  publicKeys = _.map(publicKeys, PublicKey);
	  var sorted = publicKeys;
	  if (!opts.noSorting) {
	    sorted = _.sortBy(publicKeys, function(publicKey) {
	      return publicKey.toString('hex');
	    });
	  }
	  for (var i = 0; i < sorted.length; i++) {
	    var publicKey = sorted[i];
	    script.add(publicKey.toBuffer());
	  }
	  script.add(Opcode.smallInt(publicKeys.length));
	  script.add(Opcode.OP_CHECKMULTISIG);
	  return script;
	};

	/**
	 * A new P2SH Multisig input script for the given public keys, requiring m of those public keys to spend
	 *
	 * @param {PublicKey[]} pubkeys list of all public keys controlling the output
	 * @param {number} threshold amount of required signatures to spend the output
	 * @param {Array} signatures signatures to append to the script
	 * @param {Object=} opts
	 * @param {boolean=} opts.noSorting don't sort the given public keys before creating the script (false by default)
	 * @param {Script=} opts.cachedMultisig don't recalculate the redeemScript
	 *
	 * @returns {Script}
	 */
	Script.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {
	  $.checkArgument(_.isArray(pubkeys));
	  $.checkArgument(_.isNumber(threshold));
	  $.checkArgument(_.isArray(signatures));
	  opts = opts || {};
	  var s = new Script();
	  s.add(Opcode.OP_0);
	  _.each(signatures, function(signature) {
	    s.add(signature);
	  });
	  s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());
	  return s;
	};

	/**
	 * @returns {Script} a new pay to public key hash output for the given
	 * address or public key
	 * @param {(Address|PublicKey)} to - destination address or public key
	 */
	Script.buildPublicKeyHashOut = function(to) {
	  $.checkArgument(!_.isUndefined(to));
	  $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));
	  if (to instanceof PublicKey) {
	    to = to.toAddress();
	  } else if (_.isString(to)) {
	    to = new Address(to);
	  }
	  var s = new Script();
	  s.add(Opcode.OP_DUP)
	    .add(Opcode.OP_HASH160)
	    .add(to.hashBuffer)
	    .add(Opcode.OP_EQUALVERIFY)
	    .add(Opcode.OP_CHECKSIG);
	  s._network = to.network;
	  return s;
	};

	/**
	 * @returns {Script} a new pay to public key output for the given
	 *  public key
	 */
	Script.buildPublicKeyOut = function(pubkey) {
	  $.checkArgument(pubkey instanceof PublicKey);
	  var s = new Script();
	  s.add(pubkey.toBuffer())
	    .add(Opcode.OP_CHECKSIG);
	  return s;
	};

	/**
	 * @returns {Script} a new OP_RETURN script with data
	 * @param {(string|Buffer)} to - the data to embed in the output
	 */
	Script.buildDataOut = function(data) {
	  $.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));
	  if (typeof data === 'string') {
	    data = new Buffer(data);
	  }
	  var s = new Script();
	  s.add(Opcode.OP_RETURN);
	  if (!_.isUndefined(data)) {
	    s.add(data);
	  }
	  return s;
	};

	/**
	 * @param {Script|Address} script - the redeemScript for the new p2sh output.
	 *    It can also be a p2sh address
	 * @returns {Script} new pay to script hash script for given script
	 */
	Script.buildScriptHashOut = function(script) {
	  $.checkArgument(script instanceof Script ||
	    (script instanceof Address && script.isPayToScriptHash()));
	  var s = new Script();
	  s.add(Opcode.OP_HASH160)
	    .add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer()))
	    .add(Opcode.OP_EQUAL);

	  s._network =  script._network || script.network;
	  return s;
	};

	/**
	 * Builds a scriptSig (a script for an input) that signs a public key hash
	 * output script.
	 *
	 * @param {Buffer|string|PublicKey} publicKey
	 * @param {Signature|Buffer} signature - a Signature object, or the signature in DER cannonical encoding
	 * @param {number=} sigtype - the type of the signature (defaults to SIGHASH_ALL)
	 */
	Script.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {
	  $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));
	  $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));
	  if (signature instanceof Signature) {
	    signature = signature.toBuffer();
	  }
	  var script = new Script()
	    .add(BufferUtil.concat([
	      signature,
	      BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)
	    ]))
	    .add(new PublicKey(publicKey).toBuffer());
	  return script;
	};

	/**
	 * @returns {Script} an empty script
	 */
	Script.empty = function() {
	  return new Script();
	};

	/**
	 * @returns {Script} a new pay to script hash script that pays to this script
	 */
	Script.prototype.toScriptHashOut = function() {
	  return Script.buildScriptHashOut(this);
	};

	/**
	 * @return {Script} a script built from the address
	 */
	Script.fromAddress = function(address) {
	  address = Address(address);
	  if (address.isPayToScriptHash()) {
	    return Script.buildScriptHashOut(address);
	  } else if (address.isPayToPublicKeyHash()) {
	    return Script.buildPublicKeyHashOut(address);
	  }
	  throw new errors.Script.UnrecognizedAddress(address);
	};

	/**
	 * @param {Network} [network]
	 * @return {Address} the associated address for this script
	 */
	Script.prototype.toAddress = function(network) {
	  network = Networks.get(network) || this._network || Networks.defaultNetwork;
	  if (this.isPublicKeyHashOut() || this.isScriptHashOut()) {
	    return new Address(this, network);
	  }
	  throw new Error('The script type needs to be PayToPublicKeyHash or PayToScriptHash');
	};

	/**
	 * @return {Script}
	 */
	Script.prototype.toScriptHashOut = function() {
	  return Script.buildScriptHashOut(this);
	};

	/**
	 * Analagous to bitcoind's FindAndDelete. Find and delete equivalent chunks,
	 * typically used with push data chunks.  Note that this will find and delete
	 * not just the same data, but the same data with the same push data op as
	 * produced by default. i.e., if a pushdata in a tx does not use the minimal
	 * pushdata op, then when you try to remove the data it is pushing, it will not
	 * be removed, because they do not use the same pushdata op.
	 */
	Script.prototype.findAndDelete = function(script) {
	  var buf = script.toBuffer();
	  var hex = buf.toString('hex');
	  for (var i = 0; i < this.chunks.length; i++) {
	    var script2 = Script({
	      chunks: [this.chunks[i]]
	    });
	    var buf2 = script2.toBuffer();
	    var hex2 = buf2.toString('hex');
	    if (hex === hex2) {
	      this.chunks.splice(i, 1);
	    }
	  }
	  return this;
	};

	/**
	 * Comes from bitcoind's script interpreter CheckMinimalPush function
	 * @returns {boolean} if the chunk {i} is the smallest way to push that particular data.
	 */
	Script.prototype.checkMinimalPush = function(i) {
	  var chunk = this.chunks[i];
	  var buf = chunk.buf;
	  var opcodenum = chunk.opcodenum;
	  if (!buf) {
	    return true;
	  }
	  if (buf.length === 0) {
	    // Could have used OP_0.
	    return opcodenum === Opcode.OP_0;
	  } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {
	    // Could have used OP_1 .. OP_16.
	    return opcodenum === Opcode.OP_1 + (buf[0] - 1);
	  } else if (buf.length === 1 && buf[0] === 0x81) {
	    // Could have used OP_1NEGATE
	    return opcodenum === Opcode.OP_1NEGATE;
	  } else if (buf.length <= 75) {
	    // Could have used a direct push (opcode indicating number of bytes pushed + those bytes).
	    return opcodenum === buf.length;
	  } else if (buf.length <= 255) {
	    // Could have used OP_PUSHDATA.
	    return opcodenum === Opcode.OP_PUSHDATA1;
	  } else if (buf.length <= 65535) {
	    // Could have used OP_PUSHDATA2.
	    return opcodenum === Opcode.OP_PUSHDATA2;
	  }
	  return true;
	};

	module.exports = Script;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);
	var $ = __webpack_require__(5);
	var buffer = __webpack_require__(1);

	var errors = __webpack_require__(15);
	var util = __webpack_require__(4);
	var bufferUtil = __webpack_require__(3);
	var JSUtil = __webpack_require__(4);
	var BufferReader = __webpack_require__(18);
	var BufferWriter = __webpack_require__(12);
	var Hash = __webpack_require__(7);
	var Signature = __webpack_require__(14);
	var Sighash = __webpack_require__(28);

	var Address = __webpack_require__(17);
	var UnspentOutput = __webpack_require__(62);
	var Input = __webpack_require__(42);
	var PublicKeyHashInput = Input.PublicKeyHash;
	var MultiSigScriptHashInput = Input.MultiSigScriptHash;
	var Output = __webpack_require__(24);
	var Script = __webpack_require__(9);
	var PrivateKey = __webpack_require__(35);
	var Block = __webpack_require__(55);
	var BN = __webpack_require__(6);

	var CURRENT_VERSION = 1;
	var DEFAULT_NLOCKTIME = 0;
	var DEFAULT_SEQNUMBER = 0xFFFFFFFF;

	/**
	 * Represents a transaction, a set of inputs and outputs to change ownership of tokens
	 *
	 * @param {*} serialized
	 * @constructor
	 */
	function Transaction(serialized) {
	  if (!(this instanceof Transaction)) {
	    return new Transaction(serialized);
	  }
	  this.inputs = [];
	  this.outputs = [];
	  this._inputAmount = 0;
	  this._outputAmount = 0;

	  if (serialized) {
	    if (serialized instanceof Transaction) {
	      return Transaction.shallowCopy(serialized);
	    } else if (util.isHexa(serialized)) {
	      this.fromString(serialized);
	    } else if (util.isValidJSON(serialized)) {
	      this.fromJSON(serialized);
	    } else if (bufferUtil.isBuffer(serialized)) {
	      this.fromBuffer(serialized);
	    } else if (_.isObject(serialized)) {
	      this.fromObject(serialized);
	    } else {
	      throw new errors.InvalidArgument('Must provide an object or string to deserialize a transaction');
	    }
	  } else {
	    this._newTransaction();
	  }
	}

	// max amount of satoshis in circulation
	Transaction.MAX_MONEY = 21000000 * 1e8;

	/* Constructors and Serialization */

	/**
	 * Create a 'shallow' copy of the transaction, by serializing and deserializing
	 * it dropping any additional information that inputs and outputs may have hold
	 *
	 * @param {Transaction} transaction
	 * @return {Transaction}
	 */
	Transaction.shallowCopy = function(transaction) {
	  var copy = new Transaction(transaction.toBuffer());
	  return copy;
	};

	var hashProperty = {
	  configurable: false,
	  writeable: false,
	  enumerable: true,
	  get: function() {
	    return new BufferReader(this._getHash()).readReverse().toString('hex');
	  }
	};
	Object.defineProperty(Transaction.prototype, 'hash', hashProperty);
	Object.defineProperty(Transaction.prototype, 'id', hashProperty);

	/**
	 * Retrieve the little endian hash of the transaction (used for serialization)
	 * @return {Buffer}
	 */
	Transaction.prototype._getHash = function() {
	  return Hash.sha256sha256(this.toBuffer());
	};

	/**
	 * Retrieve a hexa string that can be used with bitcoind's CLI interface
	 * (decoderawtransaction, sendrawtransaction)
	 *
	 * @param {boolean=} unsafe if true, skip testing for fees that are too high
	 * @return {string}
	 */
	Transaction.prototype.serialize = function(unsafe) {
	  if (unsafe) {
	    return this.uncheckedSerialize();
	  } else {
	    return this.checkedSerialize();
	  }
	};

	Transaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() {
	  return this.toBuffer().toString('hex');
	};

	Transaction.prototype.checkedSerialize = Transaction.prototype.toString = function() {
	  var feeError = this._validateFees();
	  if (feeError) {
	    var changeError = this._validateChange();
	    if (changeError) {
	      throw new errors.Transaction.ChangeAddressMissing();
	    } else {
	      throw new errors.Transaction.FeeError(feeError);
	    }
	  }
	  if (this._hasDustOutputs()) {
	    throw new errors.Transaction.DustOutputs();
	  }
	  return this.uncheckedSerialize();
	};

	Transaction.FEE_SECURITY_MARGIN = 15;

	Transaction.prototype._validateFees = function() {
	  if (this._getUnspentValue() > Transaction.FEE_SECURITY_MARGIN * this._estimateFee()) {
	    return 'Fee is more than ' + Transaction.FEE_SECURITY_MARGIN + ' times the suggested amount';
	  }
	};

	Transaction.prototype._validateChange = function() {
	  if (!this._change) {
	    return 'Missing change address';
	  }
	};

	Transaction.DUST_AMOUNT = 5460;

	Transaction.prototype._hasDustOutputs = function() {
	  var output;
	  for (output in this.outputs) {
	    if (this.outputs[output].satoshis < Transaction.DUST_AMOUNT) {
	      return true;
	    }
	  }
	  return false;
	};

	Transaction.prototype.inspect = function() {
	  return '<Transaction: ' + this.toString() + '>';
	};

	Transaction.prototype.toBuffer = function() {
	  var writer = new BufferWriter();
	  return this.toBufferWriter(writer).toBuffer();
	};

	Transaction.prototype.toBufferWriter = function(writer) {
	  writer.writeUInt32LE(this.version);
	  writer.writeVarintNum(this.inputs.length);
	  _.each(this.inputs, function(input) {
	    input.toBufferWriter(writer);
	  });
	  writer.writeVarintNum(this.outputs.length);
	  _.each(this.outputs, function(output) {
	    output.toBufferWriter(writer);
	  });
	  writer.writeUInt32LE(this.nLockTime);
	  return writer;
	};

	Transaction.prototype.fromBuffer = function(buffer) {
	  var reader = new BufferReader(buffer);
	  return this.fromBufferReader(reader);
	};

	Transaction.prototype.fromBufferReader = function(reader) {
	  $.checkArgument(!reader.finished(), 'No transaction data received');
	  var i, sizeTxIns, sizeTxOuts;

	  this.version = reader.readUInt32LE();
	  sizeTxIns = reader.readVarintNum();
	  for (i = 0; i < sizeTxIns; i++) {
	    var input = Input.fromBufferReader(reader);
	    this.inputs.push(input);
	  }
	  sizeTxOuts = reader.readVarintNum();
	  for (i = 0; i < sizeTxOuts; i++) {
	    this.outputs.push(Output.fromBufferReader(reader));
	  }
	  this.nLockTime = reader.readUInt32LE();
	  return this;
	};

	Transaction.prototype.fromJSON = function(json) {
	  if (JSUtil.isValidJSON(json)) {
	    json = JSON.parse(json);
	  }
	  var self = this;
	  this.inputs = [];
	  var inputs = json.inputs || json.txins;
	  inputs.forEach(function(input) {
	    self.inputs.push(Input.fromJSON(input));
	  });
	  this.outputs = [];
	  var outputs = json.outputs || json.txouts;
	  outputs.forEach(function(output) {
	    self.outputs.push(Output.fromJSON(output));
	  });
	  if (json.change) {
	    this.change(json.change);
	  }
	  this.version = json.version;
	  this.nLockTime = json.nLockTime;
	  return this;
	};

	Transaction.prototype.toObject = function toObject() {
	  var inputs = [];
	  this.inputs.forEach(function(input) {
	    inputs.push(input.toObject());
	  });
	  var outputs = [];
	  this.outputs.forEach(function(output) {
	    outputs.push(output.toObject());
	  });
	  return {
	    change: this._change ? this._change.toString() : undefined,
	    version: this.version,
	    inputs: inputs,
	    outputs: outputs,
	    nLockTime: this.nLockTime
	  };
	};

	Transaction.prototype.fromObject = function(transaction) {
	  var self = this;
	  _.each(transaction.inputs, function(input) {
	    if (input.output && input.output.script) {
	      input.output.script = new Script(input.output.script);
	      if (input.output.script.isPublicKeyHashOut()) {
	        self.addInput(new Input.PublicKeyHash(input));
	        return;
	      } else if (input.output.script.isScriptHashOut() && input.publicKeys && input.threshold) {
	        self.addInput(new Input.MultiSigScriptHash(
	          input, input.publicKeys, input.threshold, input.signatures
	        ));
	        return;
	      }
	    }
	    self.uncheckedAddInput(new Input(input));
	  });
	  _.each(transaction.outputs, function(output) {
	    self.addOutput(new Output(output));
	  });
	  if (transaction.change) {
	    this.change(transaction.change);
	  }
	  this.nLockTime = transaction.nLockTime;
	  this.version = transaction.version;
	};

	Transaction.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	Transaction.prototype.fromString = function(string) {
	  this.fromBuffer(new buffer.Buffer(string, 'hex'));
	};

	Transaction.prototype._newTransaction = function() {
	  this.version = CURRENT_VERSION;
	  this.nLockTime = DEFAULT_NLOCKTIME;
	};

	/* Transaction creation interface */

	/**
	 * Add an input to this transaction. This is a high level interface
	 * to add an input, for more control, use @{link Transaction#addInput}.
	 *
	 * Can receive, as output information, the output of bitcoind's `listunspent` command,
	 * and a slightly fancier format recognized by bitcore:
	 *
	 * ```
	 * {
	 *  address: 'mszYqVnqKoQx4jcTdJXxwKAissE3Jbrrc1',
	 *  txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',
	 *  outputIndex: 0,
	 *  script: Script.empty(),
	 *  satoshis: 1020000
	 * }
	 * ```
	 * Where `address` can be either a string or a bitcore Address object. The
	 * same is true for `script`, which can be a string or a bitcore Script.
	 *
	 * Beware that this resets all the signatures for inputs (in further versions,
	 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
	 *
	 * @example
	 * ```javascript
	 * var transaction = new Transaction();
	 *
	 * // From a pay to public key hash output from bitcoind's listunspent
	 * transaction.from({'txid': '0000...', vout: 0, amount: 0.1, scriptPubKey: 'OP_DUP ...'});
	 *
	 * // From a pay to public key hash output
	 * transaction.from({'txId': '0000...', outputIndex: 0, satoshis: 1000, script: 'OP_DUP ...'});
	 *
	 * // From a multisig P2SH output
	 * transaction.from({'txId': '0000...', inputIndex: 0, satoshis: 1000, script: '... OP_HASH'},
	 *                  ['03000...', '02000...'], 2);
	 * ```
	 *
	 * @param {Object} utxo
	 * @param {Array=} pubkeys
	 * @param {number=} threshold
	 */
	Transaction.prototype.from = function(utxo, pubkeys, threshold) {
	  if (_.isArray(utxo)) {
	    var self = this;
	    _.each(utxo, function(utxo) {
	      self.from(utxo, pubkeys, threshold);
	    });
	    return this;
	  }
	  var exists = _.any(this.inputs, function(input) {
	    // TODO: Maybe prevTxId should be a string? Or defined as read only property?
	    return input.prevTxId.toString('hex') === utxo.txId && input.outputIndex === utxo.outputIndex;
	  });
	  if (exists) {
	    return;
	  }
	  if (pubkeys && threshold) {
	    this._fromMultisigUtxo(utxo, pubkeys, threshold);
	  } else {
	    this._fromNonP2SH(utxo);
	  }
	  return this;
	};

	Transaction.prototype._fromNonP2SH = function(utxo) {
	  utxo = new UnspentOutput(utxo);
	  this.inputs.push(new PublicKeyHashInput({
	    output: new Output({
	      script: utxo.script,
	      satoshis: utxo.satoshis
	    }),
	    prevTxId: utxo.txId,
	    outputIndex: utxo.outputIndex,
	    sequenceNumber: DEFAULT_SEQNUMBER,
	    script: Script.empty()
	  }));
	  this._inputAmount += utxo.satoshis;
	};

	Transaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold) {
	  utxo = new UnspentOutput(utxo);
	  this.addInput(new MultiSigScriptHashInput({
	    output: new Output({
	      script: utxo.script,
	      satoshis: utxo.satoshis
	    }),
	    prevTxId: utxo.txId,
	    outputIndex: utxo.outputIndex,
	    sequenceNumber: DEFAULT_SEQNUMBER,
	    script: Script.empty()
	  }, pubkeys, threshold));
	};

	/**
	 * Add an input to this transaction. The input must be an instance of the `Input` class.
	 * It should have information about the Output that it's spending, but if it's not already
	 * set, two additional parameters, `outputScript` and `satoshis` can be provided.
	 *
	 * @param {Input} input
	 * @param {String|Script} outputScript
	 * @param {number} satoshis
	 * @return Transaction this, for chaining
	 */
	Transaction.prototype.addInput = function(input, outputScript, satoshis) {
	  $.checkArgumentType(input, Input, 'input');
	  if (!input.output || !(input.output instanceof Output) && !outputScript && !satoshis) {
	    throw new errors.Transaction.NeedMoreInfo('Need information about the UTXO script and satoshis');
	  }
	  if (!input.output && outputScript && satoshis) {
	    outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);
	    $.checkArgumentType(satoshis, 'number', 'satoshis');
	    input.output = new Output({
	      script: outputScript,
	      satoshis: satoshis
	    });
	  }
	  return this.uncheckedAddInput(input);
	};

	/**
	 * Add an input to this transaction, without checking that the input has information about
	 * the output that it's spending.
	 *
	 * @param {Input} input
	 * @return Transaction this, for chaining
	 */
	Transaction.prototype.uncheckedAddInput = function(input) {
	  $.checkArgumentType(input, Input, 'input');
	  this._changeSetup = false;
	  this.inputs.push(input);
	  if (input.output) {
	    this._inputAmount += input.output.satoshis;
	  }
	  return this;
	};

	/**
	 * Returns true if the transaction has enough info on all inputs to be correctly validated
	 *
	 * @return {boolean}
	 */
	Transaction.prototype.hasAllUtxoInfo = function() {
	  return _.all(this.inputs.map(function(input) {
	    return !!input.output;
	  }));
	};

	/**
	 * Manually set the fee for this transaction. Beware that this resets all the signatures
	 * for inputs (in further versions, SIGHASH_SINGLE or SIGHASH_NONE signatures will not
	 * be reset).
	 *
	 * @param {number} amount satoshis to be sent
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.fee = function(amount) {
	  this._fee = amount;
	  this._changeSetup = false;
	  return this;
	};

	/* Output management */

	/**
	 * Set the change address for this transaction
	 *
	 * Beware that this resets all the signatures for inputs (in further versions,
	 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
	 *
	 * @param {number} amount satoshis to be sent
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.change = function(address) {
	  this._change = new Address(address);
	  this._changeSetup = false;
	  return this;
	};

	/**
	 * Add an output to the transaction.
	 *
	 * Beware that this resets all the signatures for inputs (in further versions,
	 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
	 *
	 * @param {string|Address} address
	 * @param {number} amount in satoshis
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.to = function(address, amount) {
	  this.addOutput(new Output({
	    script: Script(new Address(address)),
	    satoshis: amount
	  }));
	  return this;
	};

	/**
	 * Add an OP_RETURN output to the transaction.
	 *
	 * Beware that this resets all the signatures for inputs (in further versions,
	 * SIGHASH_SINGLE or SIGHASH_NONE signatures will not be reset).
	 *
	 * @param {Buffer|string} value the data to be stored in the OP_RETURN output.
	 *    In case of a string, the UTF-8 representation will be stored
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.addData = function(value) {
	  this.addOutput(new Output({
	    script: Script.buildDataOut(value),
	    satoshis: 0
	  }));
	  return this;
	};

	Transaction.prototype.addOutput = function(output) {
	  $.checkArgumentType(output, Output, 'output');
	  this.outputs.push(output);
	  this._changeSetup = false;
	  this._outputAmount += output.satoshis;
	};

	Transaction.prototype._updateChangeOutput = function() {
	  if (!this._change) {
	    return;
	  }
	  if (this._changeSetup) {
	    return;
	  }
	  if (!_.isUndefined(this._changeSetup)) {
	    this._clearSignatures();
	  }
	  if (!_.isUndefined(this._changeOutput)) {
	    this.removeOutput(this._changeOutput);
	  }
	  var available = this._getUnspentValue();
	  var fee = this.getFee();
	  if (available - fee > 0) {
	    this._changeOutput = this.outputs.length;
	    this.addOutput(new Output({
	      script: Script.fromAddress(this._change),
	      satoshis: available - fee
	    }));
	  } else {
	    this._changeOutput = undefined;
	  }
	  this._changeSetup = true;
	};

	Transaction.prototype.getFee = function() {
	  return this._fee || this._estimateFee();
	};

	Transaction.prototype._estimateFee = function() {
	  var estimatedSize = this._estimateSize();
	  var available = this._getUnspentValue();
	  return Transaction._estimateFee(estimatedSize, available);
	};

	Transaction.prototype._getUnspentValue = function() {
	  return this._inputAmount - this._outputAmount;
	};

	Transaction.prototype._clearSignatures = function() {
	  _.each(this.inputs, function(input) {
	    input.clearSignatures();
	  });
	};

	Transaction.FEE_PER_KB = 10000;
	Transaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;

	Transaction._estimateFee = function(size, amountAvailable) {
	  var fee = Math.ceil(size / Transaction.FEE_PER_KB);
	  if (amountAvailable > fee) {
	    // Safe upper bound for change address script
	    size += Transaction.CHANGE_OUTPUT_MAX_SIZE;
	  }
	  return Math.ceil(size / 1000) * Transaction.FEE_PER_KB;
	};

	Transaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;

	Transaction.prototype._estimateSize = function() {
	  var result = Transaction.MAXIMUM_EXTRA_SIZE;
	  _.each(this.inputs, function(input) {
	    result += input._estimateSize();
	  });
	  _.each(this.outputs, function(output) {
	    result += output.script.toBuffer().length + 9;
	  });
	  return result;
	};

	Transaction.prototype.removeOutput = function(index) {
	  var output = this.outputs[index];
	  this._outputAmount -= output.satoshis;
	  this.outputs = _.without(this.outputs, this.outputs[this._changeOutput]);
	};

	/* Signature handling */

	/**
	 * Sign the transaction using one or more private keys.
	 *
	 * It tries to sign each input, verifying that the signature will be valid
	 * (matches a public key).
	 *
	 * @param {Array|String|PrivateKey} privateKey
	 * @param {number} sigtype
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.sign = function(privateKey, sigtype) {
	  $.checkState(this.hasAllUtxoInfo());
	  this._updateChangeOutput();
	  var self = this;
	  if (_.isArray(privateKey)) {
	    _.each(privateKey, function(privateKey) {
	      self.sign(privateKey, sigtype);
	    });
	    return this;
	  }
	  _.each(this.getSignatures(privateKey, sigtype), function(signature) {
	    self.applySignature(signature);
	  });
	  return this;
	};

	Transaction.prototype.getSignatures = function(privKey, sigtype) {
	  privKey = new PrivateKey(privKey);
	  sigtype = sigtype || Signature.SIGHASH_ALL;
	  var transaction = this;
	  var results = [];
	  var hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());
	  _.each(this.inputs, function forEachInput(input, index) {
	    _.each(input.getSignatures(transaction, privKey, index, sigtype, hashData), function(signature) {
	      results.push(signature);
	    });
	  });
	  return results;
	};

	/**
	 * Add a signature to the transaction
	 *
	 * @param {Object} signature
	 * @param {number} signature.inputIndex
	 * @param {number} signature.sighash
	 * @param {PublicKey} signature.publicKey
	 * @param {Signature} signature.signature
	 * @return {Transaction} this, for chaining
	 */
	Transaction.prototype.applySignature = function(signature) {
	  this.inputs[signature.inputIndex].addSignature(this, signature);
	  return this;
	};

	Transaction.prototype.isFullySigned = function() {
	  _.each(this.inputs, function(input) {
	    if (input.isFullySigned === Input.prototype.isFullySigned) {
	      throw new errors.Transaction.UnableToVerifySignature(
	        'Unrecognized script kind, or not enough information to execute script.' +
	        'This usually happens when creating a transaction from a serialized transaction'
	      );
	    }
	  });
	  return _.all(_.map(this.inputs, function(input) {
	    return input.isFullySigned();
	  }));
	};

	Transaction.prototype.isValidSignature = function(signature) {
	  var self = this;
	  if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {
	    throw new errors.Transaction.UnableToVerifySignature(
	      'Unrecognized script kind, or not enough information to execute script.' +
	      'This usually happens when creating a transaction from a serialized transaction'
	    );
	  }
	  return this.inputs[signature.inputIndex].isValidSignature(self, signature);
	};

	/**
	 * @returns {bool} whether the signature is valid for this transaction input
	 */
	Transaction.prototype.verifySignature = function(sig, pubkey, nin, subscript) {
	  return Sighash.verify(this, sig, pubkey, nin, subscript);
	};

	/**
	 * Check that a transaction passes basic sanity tests. If not, return a string
	 * describing the error. This function contains the same logic as
	 * CheckTransaction in bitcoin core.
	 */
	Transaction.prototype.verify = function() {
	  // Basic checks that don't depend on any context
	  if (this.inputs.length === 0) {
	    return 'transaction txins empty';
	  }

	  if (this.outputs.length === 0) {
	    return 'transaction txouts empty';
	  }

	  // Size limits
	  if (this.toBuffer().length > Block.MAX_BLOCK_SIZE) {
	    return 'transaction over the maximum block size';
	  }

	  // Check for negative or overflow output values
	  var valueoutbn = BN(0);
	  for (var i = 0; i < this.outputs.length; i++) {
	    var txout = this.outputs[i];
	    var valuebn = txout._satoshisBN;
	    if (valuebn.lt(0)) {
	      return 'transaction txout ' + i + ' negative';
	    }
	    if (valuebn.gt(BN(Transaction.MAX_MONEY, 10))) {
	      return 'transaction txout ' + i + ' greater than MAX_MONEY';
	    }
	    valueoutbn = valueoutbn.add(valuebn);
	    if (valueoutbn.gt(Transaction.MAX_MONEY)) {
	      return 'transaction txout ' + i + ' total output greater than MAX_MONEY';
	    }
	  }

	  // Check for duplicate inputs
	  var txinmap = {};
	  for (i = 0; i < this.inputs.length; i++) {
	    var txin = this.inputs[i];

	    var inputid = txin.prevTxId + ':' + txin.outputIndex;
	    if (!_.isUndefined(txinmap[inputid])) {
	      return 'transaction input ' + i + ' duplicate input';
	    }
	    txinmap[inputid] = true;
	  }

	  var isCoinbase = this.isCoinbase();
	  if (isCoinbase) {
	    var buf = this.inputs[0]._script.toBuffer();
	    if (buf.length < 2 || buf.length > 100) {
	      return 'coinbase trasaction script size invalid';
	    }
	  } else {
	    for (i = 0; i < this.inputs.length; i++) {
	      if (this.inputs[i].isNull()) {
	        return 'tranasction input ' + i + ' has null input';
	      }
	    }
	  }
	  return true;
	};

	/**
	 * Analagous to bitcoind's IsCoinBase function in transaction.h
	 */
	Transaction.prototype.isCoinbase = function() {
	  return (this.inputs.length === 1 && this.inputs[0].isNull());
	};


	module.exports = Transaction;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);
	var $ = __webpack_require__(5);
	var JSUtil = __webpack_require__(4);

	var Script = __webpack_require__(9);
	var Address = __webpack_require__(17);
	var Unit = __webpack_require__(44);

	/**
	 * Represents an unspent output information: its script, associated amount and address,
	 * transaction id and output index.
	 *
	 * @constructor
	 * @param {object} data
	 * @param {string} data.txid the previous transaction id
	 * @param {string=} data.txId alias for `txid`
	 * @param {number} data.vout the index in the transaction
	 * @param {number=} data.outputIndex alias for `vout`
	 * @param {string|Script} data.scriptPubKey the script that must be resolved to release the funds
	 * @param {string|Script=} data.script alias for `scriptPubKey`
	 * @param {number} data.amount amount of bitcoins associated
	 * @param {number=} data.satoshis alias for `amount`, but expressed in satoshis (1 BTC = 1e8 satoshis)
	 * @param {string|Address=} data.address the associated address to the script, if provided
	 */
	function UnspentOutput(data) {
	  /* jshint maxcomplexity: 20 */
	  /* jshint maxstatements: 20 */
	  if (!(this instanceof UnspentOutput)) {
	    return new UnspentOutput(data);
	  }
	  $.checkArgument(_.isObject(data), 'Must provide an object from where to extract data');
	  var address = data.address ? new Address(data.address) : undefined;
	  var txId = data.txid ? data.txid : data.txId;
	  if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {
	    // TODO: Use the errors library
	    throw new Error('Invalid TXID in object', data);
	  }
	  var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;
	  if (!_.isNumber(outputIndex)) {
	    throw new Error('Invalid outputIndex, received ' + outputIndex);
	  }
	  $.checkArgument(data.scriptPubKey || data.script, 'Must provide the scriptPubKey for that output!');
	  var script = new Script(data.scriptPubKey || data.script);
	  $.checkArgument(data.amount || data.satoshis, 'Must provide the scriptPubKey for that output!');
	  var amount = data.amount ? new Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;
	  $.checkArgument(_.isNumber(amount), 'Amount must be a number');
	  JSUtil.defineImmutable(this, {
	    address: address,
	    txId: txId,
	    outputIndex: outputIndex,
	    script: script,
	    satoshis: amount
	  });
	}

	/**
	 * Provide an informative output when displaying this object in the console
	 * @returns string
	 */
	UnspentOutput.prototype.inspect = function() {
	  return '<UnspentOutput: ' + this.txId + ':' + this.outputIndex +
	         ', satoshis: ' + this.satoshis + ', address: ' + this.address + '>';
	};

	/**
	 * String representation: just "txid:index"
	 * @returns string
	 */
	UnspentOutput.prototype.toString = function() {
	  return this.txId + ':' + this.outputIndex;
	};

	/**
	 * Deserialize an UnspentOutput from an object or JSON string
	 * @param {object|string} data
	 * @return UnspentOutput
	 */
	UnspentOutput.fromJSON = UnspentOutput.fromObject = function(data) {
	  if (JSUtil.isValidJSON(data)) {
	    data = JSON.parse(data);
	  }
	  return new UnspentOutput(data);
	};

	/**
	 * Retrieve a string representation of this object
	 * @return {string}
	 */
	UnspentOutput.prototype.toJSON = function() {
	  return JSON.stringify(this.toObject());
	};

	/**
	 * Returns a plain object (no prototype or methods) with the associated infor for this output
	 * @return {object}
	 */
	UnspentOutput.prototype.toObject = function() {
	  return {
	    address: this.address ? this.address.toString() : undefined,
	    txid: this.txId,
	    vout: this.outputIndex,
	    scriptPubKey: this.script.toBuffer().toString('hex'),
	    amount: Unit.fromSatoshis(this.satoshis).toBTC()
	  };
	};

	module.exports = UnspentOutput;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// Base58 encoding/decoding
	// Originally written by Mike Hearn for BitcoinJ
	// Copyright (c) 2011 Google Inc
	// Ported to JavaScript by Stefan Thomas
	// Merged Buffer refactorings from base58-native by Stephen Pair
	// Copyright (c) 2013 BitPay Inc

	var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
	var ALPHABET_MAP = {}
	for(var i = 0; i < ALPHABET.length; i++) {
	  ALPHABET_MAP[ALPHABET.charAt(i)] = i
	}
	var BASE = 58

	function encode(buffer) {
	  if (buffer.length === 0) return ''

	  var i, j, digits = [0]
	  for (i = 0; i < buffer.length; i++) {
	    for (j = 0; j < digits.length; j++) digits[j] <<= 8

	    digits[0] += buffer[i]

	    var carry = 0
	    for (j = 0; j < digits.length; ++j) {
	      digits[j] += carry

	      carry = (digits[j] / BASE) | 0
	      digits[j] %= BASE
	    }

	    while (carry) {
	      digits.push(carry % BASE)

	      carry = (carry / BASE) | 0
	    }
	  }

	  // deal with leading zeros
	  for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) digits.push(0)

	  return digits.reverse().map(function(digit) { return ALPHABET[digit] }).join('')
	}

	function decode(string) {
	  if (string.length === 0) return []

	  var i, j, bytes = [0]
	  for (i = 0; i < string.length; i++) {
	    var c = string[i]
	    if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character')

	    for (j = 0; j < bytes.length; j++) bytes[j] *= BASE
	    bytes[0] += ALPHABET_MAP[c]

	    var carry = 0
	    for (j = 0; j < bytes.length; ++j) {
	      bytes[j] += carry

	      carry = bytes[j] >> 8
	      bytes[j] &= 0xff
	    }

	    while (carry) {
	      bytes.push(carry & 0xff)

	      carry >>= 8
	    }
	  }

	  // deal with leading zeros
	  for (i = 0; string[i] === '1' && i < string.length - 1; i++) bytes.push(0)

	  return bytes.reverse()
	}

	module.exports = {
	  encode: encode,
	  decode: decode
	}


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	
	var Hasher = __webpack_require__(104).Hasher 

	var C_x64 = __webpack_require__(107)
	var X64Word = C_x64.Word;
	var X64WordArray = C_x64.WordArray;

	// Constants
	var K = [
	  X64Word(0x428a2f98, 0xd728ae22), X64Word(0x71374491, 0x23ef65cd),
	  X64Word(0xb5c0fbcf, 0xec4d3b2f), X64Word(0xe9b5dba5, 0x8189dbbc),
	  X64Word(0x3956c25b, 0xf348b538), X64Word(0x59f111f1, 0xb605d019),
	  X64Word(0x923f82a4, 0xaf194f9b), X64Word(0xab1c5ed5, 0xda6d8118),
	  X64Word(0xd807aa98, 0xa3030242), X64Word(0x12835b01, 0x45706fbe),
	  X64Word(0x243185be, 0x4ee4b28c), X64Word(0x550c7dc3, 0xd5ffb4e2),
	  X64Word(0x72be5d74, 0xf27b896f), X64Word(0x80deb1fe, 0x3b1696b1),
	  X64Word(0x9bdc06a7, 0x25c71235), X64Word(0xc19bf174, 0xcf692694),
	  X64Word(0xe49b69c1, 0x9ef14ad2), X64Word(0xefbe4786, 0x384f25e3),
	  X64Word(0x0fc19dc6, 0x8b8cd5b5), X64Word(0x240ca1cc, 0x77ac9c65),
	  X64Word(0x2de92c6f, 0x592b0275), X64Word(0x4a7484aa, 0x6ea6e483),
	  X64Word(0x5cb0a9dc, 0xbd41fbd4), X64Word(0x76f988da, 0x831153b5),
	  X64Word(0x983e5152, 0xee66dfab), X64Word(0xa831c66d, 0x2db43210),
	  X64Word(0xb00327c8, 0x98fb213f), X64Word(0xbf597fc7, 0xbeef0ee4),
	  X64Word(0xc6e00bf3, 0x3da88fc2), X64Word(0xd5a79147, 0x930aa725),
	  X64Word(0x06ca6351, 0xe003826f), X64Word(0x14292967, 0x0a0e6e70),
	  X64Word(0x27b70a85, 0x46d22ffc), X64Word(0x2e1b2138, 0x5c26c926),
	  X64Word(0x4d2c6dfc, 0x5ac42aed), X64Word(0x53380d13, 0x9d95b3df),
	  X64Word(0x650a7354, 0x8baf63de), X64Word(0x766a0abb, 0x3c77b2a8),
	  X64Word(0x81c2c92e, 0x47edaee6), X64Word(0x92722c85, 0x1482353b),
	  X64Word(0xa2bfe8a1, 0x4cf10364), X64Word(0xa81a664b, 0xbc423001),
	  X64Word(0xc24b8b70, 0xd0f89791), X64Word(0xc76c51a3, 0x0654be30),
	  X64Word(0xd192e819, 0xd6ef5218), X64Word(0xd6990624, 0x5565a910),
	  X64Word(0xf40e3585, 0x5771202a), X64Word(0x106aa070, 0x32bbd1b8),
	  X64Word(0x19a4c116, 0xb8d2d0c8), X64Word(0x1e376c08, 0x5141ab53),
	  X64Word(0x2748774c, 0xdf8eeb99), X64Word(0x34b0bcb5, 0xe19b48a8),
	  X64Word(0x391c0cb3, 0xc5c95a63), X64Word(0x4ed8aa4a, 0xe3418acb),
	  X64Word(0x5b9cca4f, 0x7763e373), X64Word(0x682e6ff3, 0xd6b2b8a3),
	  X64Word(0x748f82ee, 0x5defb2fc), X64Word(0x78a5636f, 0x43172f60),
	  X64Word(0x84c87814, 0xa1f0ab72), X64Word(0x8cc70208, 0x1a6439ec),
	  X64Word(0x90befffa, 0x23631e28), X64Word(0xa4506ceb, 0xde82bde9),
	  X64Word(0xbef9a3f7, 0xb2c67915), X64Word(0xc67178f2, 0xe372532b),
	  X64Word(0xca273ece, 0xea26619c), X64Word(0xd186b8c7, 0x21c0c207),
	  X64Word(0xeada7dd6, 0xcde0eb1e), X64Word(0xf57d4f7f, 0xee6ed178),
	  X64Word(0x06f067aa, 0x72176fba), X64Word(0x0a637dc5, 0xa2c898a6),
	  X64Word(0x113f9804, 0xbef90dae), X64Word(0x1b710b35, 0x131c471b),
	  X64Word(0x28db77f5, 0x23047d84), X64Word(0x32caab7b, 0x40c72493),
	  X64Word(0x3c9ebe0a, 0x15c9bebc), X64Word(0x431d67c4, 0x9c100d4c),
	  X64Word(0x4cc5d4be, 0xcb3e42b6), X64Word(0x597f299c, 0xfc657e2a),
	  X64Word(0x5fcb6fab, 0x3ad6faec), X64Word(0x6c44198c, 0x4a475817)
	];

	// Reusable objects
	var W = [];
	(function () {
	  for (var i = 0; i < 80; i++) {
	    W[i] = X64Word();
	  }
	}());

	/**
	 * SHA-512 hash algorithm.
	 */
	var SHA512 = Hasher.extend({
	  _doReset: function () {
	    this._hash = new X64WordArray([
	      X64Word(0x6a09e667, 0xf3bcc908), X64Word(0xbb67ae85, 0x84caa73b),
	      X64Word(0x3c6ef372, 0xfe94f82b), X64Word(0xa54ff53a, 0x5f1d36f1),
	      X64Word(0x510e527f, 0xade682d1), X64Word(0x9b05688c, 0x2b3e6c1f),
	      X64Word(0x1f83d9ab, 0xfb41bd6b), X64Word(0x5be0cd19, 0x137e2179)
	    ]);
	  },

	  _doProcessBlock: function (M, offset) {
	    // Shortcuts
	    var H = this._hash.words;

	    var H0 = H[0]; var H1 = H[1]; var H2 = H[2];
	    var H3 = H[3]; var H4 = H[4]; var H5 = H[5];
	    var H6 = H[6]; var H7 = H[7];

	    var H0h = H0.high; var H0l = H0.low;
	    var H1h = H1.high; var H1l = H1.low;
	    var H2h = H2.high; var H2l = H2.low;
	    var H3h = H3.high; var H3l = H3.low;
	    var H4h = H4.high; var H4l = H4.low;
	    var H5h = H5.high; var H5l = H5.low;
	    var H6h = H6.high; var H6l = H6.low;
	    var H7h = H7.high; var H7l = H7.low;

	    // Working variables
	    var ah = H0h; var al = H0l;
	    var bh = H1h; var bl = H1l;
	    var ch = H2h; var cl = H2l;
	    var dh = H3h; var dl = H3l;
	    var eh = H4h; var el = H4l;
	    var fh = H5h; var fl = H5l;
	    var gh = H6h; var gl = H6l;
	    var hh = H7h; var hl = H7l;

	    // Rounds
	    for (var i = 0; i < 80; i++) {
	      // Shortcut
	      var Wi = W[i];

	      // Extend message
	      if (i < 16) {
	        var Wih = Wi.high = M[offset + i * 2]     | 0;
	        var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	      } else {
	        // Gamma0
	        var gamma0x  = W[i - 15];
	        var gamma0xh = gamma0x.high;
	        var gamma0xl = gamma0x.low;
	        var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	        var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	        // Gamma1
	        var gamma1x  = W[i - 2];
	        var gamma1xh = gamma1x.high;
	        var gamma1xl = gamma1x.low;
	        var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	        var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[i - 7];
	        var Wi7h = Wi7.high;
	        var Wi7l = Wi7.low;

	        var Wi16  = W[i - 16];
	        var Wi16h = Wi16.high;
	        var Wi16l = Wi16.low;

	        var Wil = gamma0l + Wi7l;
	        var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	        var Wil = Wil + gamma1l;
	        var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	        var Wil = Wil + Wi16l;
	        var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	        Wi.high = Wih;
	        Wi.low  = Wil;
	      }

	      var chh  = (eh & fh) ^ (~eh & gh);
	      var chl  = (el & fl) ^ (~el & gl);
	      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	      var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	      var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	      var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	      var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki  = K[i];
	      var Kih = Ki.high;
	      var Kil = Ki.low;

	      var t1l = hl + sigma1l;
	      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	      var t1l = t1l + chl;
	      var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	      var t1l = t1l + Kil;
	      var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	      var t1l = t1l + Wil;
	      var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl;
	      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	      // Update working variables
	      hh = gh; hl = gl;
	      gh = fh; gl = fl;
	      fh = eh; fl = el;
	      el = (dl + t1l) | 0;
	      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	      dh = ch; dl = cl;
	      ch = bh; cl = bl;
	      bh = ah; bl = al;
	      al = (t1l + t2l) | 0;
	      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	    }

	    // Intermediate hash value
	    H0l = H0.low  = (H0l + al);
	    H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	    H1l = H1.low  = (H1l + bl);
	    H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	    H2l = H2.low  = (H2l + cl);
	    H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	    H3l = H3.low  = (H3l + dl);
	    H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	    H4l = H4.low  = (H4l + el);
	    H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	    H5l = H5.low  = (H5l + fl);
	    H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	    H6l = H6.low  = (H6l + gl);
	    H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	    H7l = H7.low  = (H7l + hl);
	    H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	  },

	  _doFinalize: function () {
	    // Shortcuts
	    var data = this._data;
	    var dataWords = data.words;

	    var nBitsTotal = this._nDataBytes * 8;
	    var nBitsLeft = data.sigBytes * 8;

	    // Add padding
	    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	    dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	    dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	    data.sigBytes = dataWords.length * 4;

	    // Hash final blocks
	    this._process();

	    // Convert hash to 32-bit word array before returning
	    var hash = this._hash.toX32();

	    // Return final computed hash
	    return hash;
	  },

	  clone: function () {
	    var clone = Hasher.clone.call(this);
	    clone._hash = this._hash.clone();

	    return clone;
	  },

	  blockSize: 1024/32
	});


	module.exports = Hasher._createHelper(SHA512);
	module.exports.sha512 = SHA512



/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = Buffers;

	function Buffers (bufs) {
	    if (!(this instanceof Buffers)) return new Buffers(bufs);
	    this.buffers = bufs || [];
	    this.length = this.buffers.reduce(function (size, buf) {
	        return size + buf.length
	    }, 0);
	}

	Buffers.prototype.push = function () {
	    for (var i = 0; i < arguments.length; i++) {
	        if (!Buffer.isBuffer(arguments[i])) {
	            throw new TypeError('Tried to push a non-buffer');
	        }
	    }
	    
	    for (var i = 0; i < arguments.length; i++) {
	        var buf = arguments[i];
	        this.buffers.push(buf);
	        this.length += buf.length;
	    }
	    return this.length;
	};

	Buffers.prototype.unshift = function () {
	    for (var i = 0; i < arguments.length; i++) {
	        if (!Buffer.isBuffer(arguments[i])) {
	            throw new TypeError('Tried to unshift a non-buffer');
	        }
	    }
	    
	    for (var i = 0; i < arguments.length; i++) {
	        var buf = arguments[i];
	        this.buffers.unshift(buf);
	        this.length += buf.length;
	    }
	    return this.length;
	};

	Buffers.prototype.copy = function (dst, dStart, start, end) {
	    return this.slice(start, end).copy(dst, dStart, 0, end - start);
	};

	Buffers.prototype.splice = function (i, howMany) {
	    var buffers = this.buffers;
	    var index = i >= 0 ? i : this.length - i;
	    var reps = [].slice.call(arguments, 2);
	    
	    if (howMany === undefined) {
	        howMany = this.length - index;
	    }
	    else if (howMany > this.length - index) {
	        howMany = this.length - index;
	    }
	    
	    for (var i = 0; i < reps.length; i++) {
	        this.length += reps[i].length;
	    }
	    
	    var removed = new Buffers();
	    var bytes = 0;
	    
	    var startBytes = 0;
	    for (
	        var ii = 0;
	        ii < buffers.length && startBytes + buffers[ii].length < index;
	        ii ++
	    ) { startBytes += buffers[ii].length }
	    
	    if (index - startBytes > 0) {
	        var start = index - startBytes;
	        
	        if (start + howMany < buffers[ii].length) {
	            removed.push(buffers[ii].slice(start, start + howMany));
	            
	            var orig = buffers[ii];
	            //var buf = new Buffer(orig.length - howMany);
	            var buf0 = new Buffer(start);
	            for (var i = 0; i < start; i++) {
	                buf0[i] = orig[i];
	            }
	            
	            var buf1 = new Buffer(orig.length - start - howMany);
	            for (var i = start + howMany; i < orig.length; i++) {
	                buf1[ i - howMany - start ] = orig[i]
	            }
	            
	            if (reps.length > 0) {
	                var reps_ = reps.slice();
	                reps_.unshift(buf0);
	                reps_.push(buf1);
	                buffers.splice.apply(buffers, [ ii, 1 ].concat(reps_));
	                ii += reps_.length;
	                reps = [];
	            }
	            else {
	                buffers.splice(ii, 1, buf0, buf1);
	                //buffers[ii] = buf;
	                ii += 2;
	            }
	        }
	        else {
	            removed.push(buffers[ii].slice(start));
	            buffers[ii] = buffers[ii].slice(0, start);
	            ii ++;
	        }
	    }
	    
	    if (reps.length > 0) {
	        buffers.splice.apply(buffers, [ ii, 0 ].concat(reps));
	        ii += reps.length;
	    }
	    
	    while (removed.length < howMany) {
	        var buf = buffers[ii];
	        var len = buf.length;
	        var take = Math.min(len, howMany - removed.length);
	        
	        if (take === len) {
	            removed.push(buf);
	            buffers.splice(ii, 1);
	        }
	        else {
	            removed.push(buf.slice(0, take));
	            buffers[ii] = buffers[ii].slice(take);
	        }
	    }
	    
	    this.length -= removed.length;
	    
	    return removed;
	};
	 
	Buffers.prototype.slice = function (i, j) {
	    var buffers = this.buffers;
	    if (j === undefined) j = this.length;
	    if (i === undefined) i = 0;
	    
	    if (j > this.length) j = this.length;
	    
	    var startBytes = 0;
	    for (
	        var si = 0;
	        si < buffers.length && startBytes + buffers[si].length <= i;
	        si ++
	    ) { startBytes += buffers[si].length }
	    
	    var target = new Buffer(j - i);
	    
	    var ti = 0;
	    for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
	        var len = buffers[ii].length;
	        
	        var start = ti === 0 ? i - startBytes : 0;
	        var end = ti + len >= j - i
	            ? Math.min(start + (j - i) - ti, len)
	            : len
	        ;
	        
	        buffers[ii].copy(target, ti, start, end);
	        ti += end - start;
	    }
	    
	    return target;
	};

	Buffers.prototype.pos = function (i) {
	    if (i < 0 || i >= this.length) throw new Error('oob');
	    var l = i, bi = 0, bu = null;
	    for (;;) {
	        bu = this.buffers[bi];
	        if (l < bu.length) {
	            return {buf: bi, offset: l};
	        } else {
	            l -= bu.length;
	        }
	        bi++;
	    }
	};

	Buffers.prototype.get = function get (i) {
	    var pos = this.pos(i);

	    return this.buffers[pos.buf].get(pos.offset);
	};

	Buffers.prototype.set = function set (i, b) {
	    var pos = this.pos(i);

	    return this.buffers[pos.buf].set(pos.offset, b);
	};

	Buffers.prototype.indexOf = function (needle, offset) {
	    if ("string" === typeof needle) {
	        needle = new Buffer(needle);
	    } else if (needle instanceof Buffer) {
	        // already a buffer
	    } else {
	        throw new Error('Invalid type for a search string');
	    }

	    if (!needle.length) {
	        return 0;
	    }

	    if (!this.length) {
	        return -1;
	    }

	    var i = 0, j = 0, match = 0, mstart, pos = 0;

	    // start search from a particular point in the virtual buffer
	    if (offset) {
	        var p = this.pos(offset);
	        i = p.buf;
	        j = p.offset;
	        pos = offset;
	    }

	    // for each character in virtual buffer
	    for (;;) {
	        while (j >= this.buffers[i].length) {
	            j = 0;
	            i++;

	            if (i >= this.buffers.length) {
	                // search string not found
	                return -1;
	            }
	        }

	        var char = this.buffers[i][j];

	        if (char == needle[match]) {
	            // keep track where match started
	            if (match == 0) {
	                mstart = {
	                    i: i,
	                    j: j,
	                    pos: pos
	                };
	            }
	            match++;
	            if (match == needle.length) {
	                // full match
	                return mstart.pos;
	            }
	        } else if (match != 0) {
	            // a partial match ended, go back to match starting position
	            // this will continue the search at the next character
	            i = mstart.i;
	            j = mstart.j;
	            pos = mstart.pos;
	            match = 0;
	        }

	        j++;
	        pos++;
	    }
	};

	Buffers.prototype.toBuffer = function() {
	    return this.slice();
	}

	Buffers.prototype.toString = function(encoding, start, end) {
	    return this.slice(start, end).toString(encoding);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {/**
	 * net
	 * ===
	 *
	 * The net module provides you with an asynchronous network wrapper. It
	 * contains methods for creating both servers and clients (called streams).
	 * You can include this module with require('chrome-net')
	 */

	var EventEmitter = __webpack_require__(26).EventEmitter
	var inherits = __webpack_require__(116)
	var ipaddr = __webpack_require__(117)
	var is = __webpack_require__(115)
	var stream = __webpack_require__(31)

	// Track open servers and sockets to route incoming sockets (via onAccept and onReceive)
	// to the right handlers.
	var servers = {}
	var sockets = {}

	if (typeof chrome !== 'undefined') {
	  chrome.sockets.tcpServer.onAccept.addListener(onAccept)
	  chrome.sockets.tcpServer.onAcceptError.addListener(onAcceptError)
	  chrome.sockets.tcp.onReceive.addListener(onReceive)
	  chrome.sockets.tcp.onReceiveError.addListener(onReceiveError)
	}

	function onAccept (info) {
	  if (info.socketId in servers) {
	    servers[info.socketId]._onAccept(info.clientSocketId)
	  } else {
	    console.error('Unknown server socket id: ' + info.socketId)
	  }
	}

	function onAcceptError (info) {
	  if (info.socketId in servers) {
	    servers[info.socketId]._onAcceptError(info.resultCode)
	  } else {
	    console.error('Unknown server socket id: ' + info.socketId)
	  }
	}

	function onReceive (info) {
	  if (info.socketId in sockets) {
	    sockets[info.socketId]._onReceive(info.data)
	  } else {
	    console.error('Unknown socket id: ' + info.socketId)
	  }
	}

	function onReceiveError (info) {
	  if (info.socketId in sockets) {
	    sockets[info.socketId]._onReceiveError(info.resultCode)
	  } else {
	    if (info.resultCode === -100) // net::ERR_CONNECTION_CLOSED
	      return
	    console.error('Unknown socket id: ' + info.socketId)
	  }
	}

	/**
	 * Creates a new TCP server. The connectionListener argument is automatically
	 * set as a listener for the 'connection' event.
	 *
	 * @param  {Object} options
	 * @param  {function} listener
	 * @return {Server}
	 */
	exports.createServer = function (options, listener) {
	  return new Server(options, listener)
	}

	/**
	 * net.connect(options, [connectionListener])
	 * net.createConnection(options, [connectionListener])
	 *
	 * Constructs a new socket object and opens the socket to the given location.
	 * When the socket is established, the 'connect' event will be emitted.
	 *
	 * For TCP sockets, options argument should be an object which specifies:
	 *
	 *   port: Port the client should connect to (Required).
	 *   host: Host the client should connect to. Defaults to 'localhost'.
	 *   localAddress: Local interface to bind to for network connections.
	 *
	 * ===============================================================
	 *
	 * net.connect(port, [host], [connectListener])
	 * net.createConnection(port, [host], [connectListener])
	 *
	 * Creates a TCP connection to port on host. If host is omitted,
	 * 'localhost' will be assumed. The connectListener parameter will be
	 * added as an listener for the 'connect' event.
	 *
	 * @param {Object} options
	 * @param {function} listener
	 * @return {Socket}
	 */
	exports.connect = exports.createConnection = function () {
	  var args = normalizeConnectArgs(arguments)
	  var s = new Socket(args[0])
	  return Socket.prototype.connect.apply(s, args)
	}

	inherits(Server, EventEmitter)

	/**
	 * Class: net.Server
	 * =================
	 *
	 * This class is used to create a TCP server.
	 *
	 * Event: 'listening'
	 *   Emitted when the server has been bound after calling server.listen.
	 *
	 * Event: 'connection'
	 *   - Socket object The connection object
	 *   Emitted when a new connection is made. socket is an instance of net.Socket.
	 *
	 * Event: 'close'
	 *   Emitted when the server closes. Note that if connections exist, this event
	 *   is not emitted until all connections are ended.
	 *
	 * Event: 'error'
	 *   - Error Object
	 *   Emitted when an error occurs. The 'close' event will be called directly
	 *   following this event. See example in discussion of server.listen.
	 */
	function Server (/* [options], listener */) {
	  var self = this
	  if (!(self instanceof Server)) return new Server(arguments[0], arguments[1])
	  EventEmitter.call(self)

	  var options

	  if (is.isFunction(arguments[0])) {
	    options = {}
	    self.on('connection', arguments[0])
	  } else {
	    options = arguments[0] || {}

	    if (is.isFunction(arguments[1])) {
	      self.on('connection', arguments[1])
	    }
	  }

	  self._destroyed = false
	  self._connections = 0
	}
	exports.Server = Server

	/**
	 * server.listen(port, [host], [backlog], [callback])
	 *
	 * Begin accepting connections on the specified port and host. If the host is
	 * omitted, the server will accept connections directed to any IPv4 address
	 * (INADDR_ANY). A port value of zero will assign a random port.
	 *
	 * Backlog is the maximum length of the queue of pending connections. The
	 * actual length will be determined by your OS through sysctl settings such as
	 * tcp_max_syn_backlog and somaxconn on linux. The default value of this
	 * parameter is 511 (not 512).
	 *
	 * This function is asynchronous. When the server has been bound, 'listening'
	 * event will be emitted. The last parameter callback will be added as an
	 * listener for the 'listening' event.
	 *
	 * @return {Socket}
	 */
	Server.prototype.listen = function (/* variable arguments... */) {
	  var self = this

	  var lastArg = arguments[arguments.length - 1]
	  if (is.isFunction(lastArg)) {
	    self.once('listening', lastArg)
	  }

	  // If port is invalid or undefined, bind to a random port.
	  var port = toNumber(arguments[0]) || 0

	  var address
	  if (arguments[1] == null ||
	      is.isFunction(arguments[1]) ||
	      is.isNumber(arguments[1])) {
	    // The first argument is the port, no IP given.
	    address = '0.0.0.0'
	  } else {
	    address = arguments[1]
	  }

	  // The third optional argument is the backlog size.
	  // When the ip is omitted it can be the second argument.
	  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]) || undefined

	  chrome.sockets.tcpServer.create(function (createInfo) {
	    self.id = createInfo.socketId

	    chrome.sockets.tcpServer.listen(self.id, address, port, backlog, function (result) {
	      if (result < 0) {
	        self.emit('error', new Error('Socket ' + self.id + ' failed to listen. ' +
	          chrome.runtime.lastError.message))
	        self._destroy()
	        return
	      }

	      servers[self.id] = self

	      chrome.sockets.tcpServer.getInfo(self.id, function (socketInfo) {
	        self._address = socketInfo.localAddress
	        self._port = socketInfo.localPort
	        self.emit('listening')
	      })

	    })
	  })

	  return self
	}

	Server.prototype._onAccept = function (clientSocketId) {
	  var self = this

	  // Set the `maxConnections` property to reject connections when the server's
	  // connection count gets high.
	  if (self.maxConnections && self._connections >= self.maxConnections) {
	    chrome.sockets.tcpServer.disconnect(clientSocketId)
	    chrome.sockets.tcpServer.close(clientSocketId)
	    console.warn('Rejected connection - hit `maxConnections` limit')
	    return
	  }

	  self._connections += 1

	  var acceptedSocket = new Socket({
	    server: self,
	    id: clientSocketId
	  })
	  acceptedSocket.on('connect', function () {
	    self.emit('connection', acceptedSocket)
	  })

	  chrome.sockets.tcp.setPaused(clientSocketId, false)
	}

	Server.prototype._onAcceptError = function (resultCode) {
	  var self = this
	  self.emit('error', new Error('Socket ' + self.id + ' failed to accept (' +
	    resultCode + ')'))
	  self._destroy()
	}

	/**
	 * Stops the server from accepting new connections and keeps existing
	 * connections. This function is asynchronous, the server is finally closed
	 * when all connections are ended and the server emits a 'close' event.
	 * Optionally, you can pass a callback to listen for the 'close' event.
	 * @param  {function} callback
	 */
	Server.prototype.close = function (callback) {
	  var self = this
	  self._destroy(callback)
	}

	Server.prototype._destroy = function (exception, cb) {
	  var self = this

	  if (self._destroyed)
	    return

	  if (cb)
	    this.once('close', cb)

	  this._destroyed = true
	  this._connections = 0
	  delete servers[self.id]

	  chrome.sockets.tcpServer.disconnect(self.id, function () {
	    chrome.sockets.tcpServer.close(self.id, function () {
	      self.emit('close')
	    })
	  })
	}

	/**
	 * Returns the bound address, the address family name and port of the socket
	 * as reported by the operating system. Returns an object with three
	 * properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }
	 *
	 * @return {Object} information
	 */
	Server.prototype.address = function () {
	  var self = this
	  return {
	    address: self._address,
	    port: self._port,
	    family: 'IPv4'
	  }
	}

	Server.prototype.unref = function () {
	  // No chrome.socket equivalent
	}

	Server.prototype.ref = function () {
	  // No chrome.socket equivalent
	}

	/**
	 * Asynchronously get the number of concurrent connections on the server.
	 * Works when sockets were sent to forks.
	 *
	 * Callback should take two arguments err and count.
	 *
	 * @param  {function} callback
	 */
	Server.prototype.getConnections = function (callback) {
	  var self = this
	  process.nextTick(function () {
	    callback(null, self._connections)
	  })
	}


	inherits(Socket, stream.Duplex)

	/**
	 * Class: net.Socket
	 * =================
	 *
	 * This object is an abstraction of a TCP or UNIX socket. net.Socket instances
	 * implement a duplex Stream interface. They can be created by the user and
	 * used as a client (with connect()) or they can be created by Node and passed
	 * to the user through the 'connection' event of a server.
	 *
	 * Construct a new socket object.
	 *
	 * options is an object with the following defaults:
	 *
	 *   { fd: null // NO CHROME EQUIVALENT
	 *     type: null
	 *     allowHalfOpen: false // NO CHROME EQUIVALENT
	 *   }
	 *
	 * `type` can only be 'tcp4' (for now).
	 *
	 * Event: 'connect'
	 *   Emitted when a socket connection is successfully established. See
	 *   connect().
	 *
	 * Event: 'data'
	 *   - Buffer object
	 *   Emitted when data is received. The argument data will be a Buffer or
	 *   String. Encoding of data is set by socket.setEncoding(). (See the Readable
	 *   Stream section for more information.)
	 *
	 *   Note that the data will be lost if there is no listener when a Socket
	 *   emits a 'data' event.
	 *
	 * Event: 'end'
	 *   Emitted when the other end of the socket sends a FIN packet.
	 *
	 *   By default (allowHalfOpen == false) the socket will destroy its file
	 *   descriptor once it has written out its pending write queue. However,
	 *   by setting allowHalfOpen == true the socket will not automatically
	 *   end() its side allowing the user to write arbitrary amounts of data,
	 *   with the caveat that the user is required to end() their side now.
	 *
	 * Event: 'timeout'
	 *   Emitted if the socket times out from inactivity. This is only to notify
	 *   that the socket has been idle. The user must manually close the connection.
	 *
	 *   See also: socket.setTimeout()
	 *
	 * Event: 'drain'
	 *   Emitted when the write buffer becomes empty. Can be used to throttle
	 *   uploads.
	 *
	 *   See also: the return values of socket.write()
	 *
	 * Event: 'error'
	 *   - Error object
	 *   Emitted when an error occurs. The 'close' event will be called directly
	 *   following this event.
	 *
	 * Event: 'close'
	 *   - had_error Boolean true if the socket had a transmission error
	 *   Emitted once the socket is fully closed. The argument had_error is a
	 *   boolean which says if the socket was closed due to a transmission error.
	 */
	function Socket (options) {
	  var self = this
	  if (!(self instanceof Socket)) return new Socket(options)

	  if (is.isUndefined(options))
	    options = {}

	  stream.Duplex.call(self, options)

	  self.destroyed = false
	  self.errorEmitted = false
	  self.readable = self.writable = false

	  // The amount of received bytes.
	  self.bytesRead = 0

	  self._bytesDispatched = 0
	  self._connecting = false

	  self.ondata = null
	  self.onend = null

	  if (options.server) {
	    self.server = options.server
	    self.id = options.id

	    // For incoming sockets (from server), it's already connected.
	    self._connecting = true
	    self._onConnect()
	  }
	}
	exports.Socket = Socket

	/**
	 * socket.connect(port, [host], [connectListener])
	 * socket.connect(options, [connectListener])
	 *
	 * Opens the connection for a given socket. If port and host are given, then
	 * the socket will be opened as a TCP socket, if host is omitted, localhost
	 * will be assumed. If a path is given, the socket will be opened as a unix
	 * socket to that path.
	 *
	 * Normally this method is not needed, as net.createConnection opens the
	 * socket. Use this only if you are implementing a custom Socket.
	 *
	 * This function is asynchronous. When the 'connect' event is emitted the
	 * socket is established. If there is a problem connecting, the 'connect'
	 * event will not be emitted, the 'error' event will be emitted with the
	 * exception.
	 *
	 * The connectListener parameter will be added as an listener for the
	 * 'connect' event.
	 *
	 * @param  {Object} options
	 * @param  {function} cb
	 * @return {Socket}   this socket (for chaining)
	 */
	Socket.prototype.connect = function (options, cb) {
	  var self = this

	  if (self._connecting)
	    return
	  self._connecting = true

	  var port = Number(options.port)

	  if (is.isFunction(cb)) {
	    self.once('connect', cb)
	  }

	  chrome.sockets.tcp.create(function (createInfo) {
	    if (self.destroyed) {
	      chrome.sockets.tcp.close(createInfo.socketId)
	      return
	    }

	    self.id = createInfo.socketId

	    chrome.sockets.tcp.connect(self.id, options.host, port, function (result) {
	      if (result < 0) {
	        self.destroy(new Error('Socket ' + self.id + ' connect error ' + result
	          + ': ' + chrome.runtime.lastError.message))
	        return
	      }

	      self._onConnect()
	    })
	  })

	  return self
	}

	Socket.prototype._onConnect = function () {
	  var self = this

	  sockets[self.id] = self
	  chrome.sockets.tcp.getInfo(self.id, function (result) {
	    self.remoteAddress = result.peerAddress
	    self.remotePort = result.peerPort
	    self.localAddress = result.localAddress
	    self.localPort = result.localPort

	    self._connecting = false
	    self.readable = self.writable = true

	    self.emit('connect')
	    // start the first read, or get an immediate EOF.
	    // this doesn't actually consume any bytes, because len=0
	    self.read(0)
	  })
	}

	/**
	 * The number of characters currently buffered to be written.
	 * @type {number}
	 */
	Object.defineProperty(Socket.prototype, 'bufferSize', {
	  get: function () {
	    var self = this
	    if (self._pendingData)
	      return self._pendingData.length
	    else
	      return 0 // Unfortunately, chrome.socket does not make this info available
	  }
	})

	/**
	 * Sends data on the socket. The second parameter specifies the encoding in
	 * the case of a string--it defaults to UTF8 encoding.
	 *
	 * Returns true if the entire data was flushed successfully to the kernel
	 * buffer. Returns false if all or part of the data was queued in user memory.
	 * 'drain' will be emitted when the buffer is again free.
	 *
	 * The optional callback parameter will be executed when the data is finally
	 * written out - this may not be immediately.
	 *
	 * @param  {Buffer|Arrayish|string} chunk
	 * @param  {string} [encoding]
	 * @param  {function} [callback]
	 * @return {boolean}             flushed to kernel completely?
	 */
	Socket.prototype.write = function (chunk, encoding, callback) {
	  var self = this
	  if (!Buffer.isBuffer(chunk))
	    chunk = new Buffer(chunk, encoding)

	  return stream.Duplex.prototype.write.call(self, chunk, encoding, callback)
	}

	Socket.prototype._write = function (buffer, encoding, callback) {
	  var self = this
	  if (!callback) callback = function () {}

	  if (!self.writable) {
	    self._pendingData = buffer
	    self._pendingEncoding = encoding
	    self.once('connect', function () {
	      self._write(buffer, encoding, callback)
	    })
	    return
	  }
	  self._pendingData = null
	  self._pendingEncoding = null

	  // assuming buffer is browser implementation (`buffer` package on npm)
	  var buf = buffer.buffer
	  if (buffer.byteOffset || buffer.byteLength !== buf.byteLength)
	    buf = buf.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength)

	  chrome.sockets.tcp.send(self.id, buf, function (sendInfo) {
	    if (sendInfo.resultCode < 0) {
	      var err = new Error('Socket ' + self.id + ' write error: ' + sendInfo.resultCode)
	      callback(err)
	      self.destroy(err)
	    } else {
	      self._resetTimeout()
	      callback(null)
	    }
	  })

	  self._bytesDispatched += buffer.length
	}

	Socket.prototype._read = function (bufferSize) {
	  var self = this
	  if (self._connecting) {
	    self.once('connect', self._read.bind(self, bufferSize))
	    return
	  }

	  chrome.sockets.tcp.setPaused(self.id, false)
	}

	Socket.prototype._onReceive = function (data) {
	  var self = this
	  var buffer = new Buffer(new Uint8Array(data))
	  var offset = self.bytesRead

	  self.bytesRead += buffer.length
	  self._resetTimeout()

	  if (self.ondata) self.ondata(buffer, offset, self.bytesRead)
	  if (!self.push(buffer)) { // if returns false, then apply backpressure
	    chrome.sockets.tcp.setPaused(self.id, true)
	  }
	}

	Socket.prototype._onReceiveError = function (resultCode) {
	  var self = this
	  if (resultCode === -100) {
	    if (self.onend) self.once('end', self.onend)
	    self.push(null)
	    self.destroy()
	  } else if (resultCode < 0) {
	    self.destroy(new Error('Socket ' + self.id + ' receive error ' + resultCode))
	  }
	}

	/**
	 * The amount of bytes sent.
	 * @return {number}
	 */
	Object.defineProperty(Socket.prototype, 'bytesWritten', {
	  get: function () {
	    var self = this
	    var bytes = self._bytesDispatched

	    self._writableState.toArrayBuffer().forEach(function (el) {
	      if (Buffer.isBuffer(el.chunk))
	        bytes += el.chunk.length
	      else
	        bytes += new Buffer(el.chunk, el.encoding).length
	    })

	    if (self._pendingData) {
	      if (Buffer.isBuffer(self._pendingData))
	        bytes += self._pendingData.length
	      else
	        bytes += Buffer.byteLength(self._pendingData, self._pendingEncoding)
	    }

	    return bytes
	  }
	})

	Socket.prototype.destroy = function (exception) {
	  var self = this
	  self._destroy(exception)
	}

	Socket.prototype._destroy = function (exception, cb) {
	  var self = this

	  function fireErrorCallbacks () {
	    if (cb) cb(exception)
	    if (exception && !self.errorEmitted) {
	      process.nextTick(function () {
	        self.emit('error', exception)
	      })
	      self.errorEmitted = true
	    }
	  }

	  if (self.destroyed) {
	    // already destroyed, fire error callbacks
	    fireErrorCallbacks()
	    return
	  }

	  if (this.server) {
	    this.server._connections -= 1
	  }

	  self._connecting = false
	  this.readable = this.writable = false
	  self.destroyed = true
	  delete sockets[self.id]

	  // if _destroy() has been called before chrome.sockets.tcp.create()
	  // callback, we don't have an id. Therefore we don't need to close
	  // or disconnect
	  if (self.id) {
	    chrome.sockets.tcp.disconnect(self.id, function () {
	      chrome.sockets.tcp.close(self.id, function () {
	        self.emit('close', !!exception)
	        fireErrorCallbacks()
	      })
	    })
	  }
	}

	Socket.prototype.destroySoon = function () {
	  var self = this

	  if (self.writable)
	    self.end()

	  if (self._writableState.finished)
	    self.destroy()
	  else
	    self.once('finish', self._destroy.bind(self))
	}

	/**
	 * Sets the socket to timeout after timeout milliseconds of inactivity on the socket.
	 * By default net.Socket do not have a timeout. When an idle timeout is triggered the
	 * socket will receive a 'timeout' event but the connection will not be severed. The
	 * user must manually end() or destroy() the socket.
	 *
	 * If timeout is 0, then the existing idle timeout is disabled.
	 *
	 * The optional callback parameter will be added as a one time listener for the 'timeout' event.
	 *
	 * @param {number}   timeout
	 * @param {function} callback
	 */
	Socket.prototype.setTimeout = function (timeout, callback) {
	  var self = this
	  if (callback) self.once('timeout', callback)
	  self._timeoutMs = timeout
	  self._resetTimeout()
	}

	Socket.prototype._onTimeout = function () {
	  var self = this
	  self._timeout = null
	  self._timeoutMs = 0
	  self.emit('timeout')
	}

	Socket.prototype._resetTimeout = function () {
	  var self = this
	  if (self._timeout) {
	    clearTimeout(self._timeout)
	  }
	  if (self._timeoutMs) {
	    self._timeout = setTimeout(self._onTimeout.bind(self), self._timeoutMs)
	  }
	}

	/**
	 * Disables the Nagle algorithm. By default TCP connections use the Nagle
	 * algorithm, they buffer data before sending it off. Setting true for noDelay
	 * will immediately fire off data each time socket.write() is called. noDelay
	 * defaults to true.
	 *
	 * NOTE: The Chrome version of this function is async, whereas the node
	 * version is sync. Keep this in mind.
	 *
	 * @param {boolean} [noDelay] Optional
	 * @param {function} callback CHROME-SPECIFIC: Called when the configuration
	 *                            operation is done.
	 */
	Socket.prototype.setNoDelay = function (noDelay, callback) {
	  var self = this
	  // backwards compatibility: assume true when `enable` is omitted
	  noDelay = is.isUndefined(noDelay) ? true : !!noDelay
	  if (!callback) callback = function () {}
	  chrome.sockets.tcp.setNoDelay(self.id, noDelay, callback)
	}

	/**
	 * Enable/disable keep-alive functionality, and optionally set the initial
	 * delay before the first keepalive probe is sent on an idle socket. enable
	 * defaults to false.
	 *
	 * Set initialDelay (in milliseconds) to set the delay between the last data
	 * packet received and the first keepalive probe. Setting 0 for initialDelay
	 * will leave the value unchanged from the default (or previous) setting.
	 * Defaults to 0.
	 *
	 * NOTE: The Chrome version of this function is async, whereas the node
	 * version is sync. Keep this in mind.
	 *
	 * @param {boolean} [enable] Optional
	 * @param {number} [initialDelay]
	 * @param {function} callback CHROME-SPECIFIC: Called when the configuration
	 *                            operation is done.
	 */
	Socket.prototype.setKeepAlive = function (enable, initialDelay, callback) {
	  var self = this
	  if (!callback) callback = function () {}
	  chrome.sockets.tcp.setKeepAlive(self.id, !!enable, ~~(initialDelay / 1000),
	      callback)
	}

	/**
	 * Returns the bound address, the address family name and port of the socket
	 * as reported by the operating system. Returns an object with three
	 * properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }
	 *
	 * @return {Object} information
	 */
	Socket.prototype.address = function () {
	  var self = this
	  return {
	    address: self.localAddress,
	    port: self.localPort,
	    family: 'IPv4'
	  }
	}

	Object.defineProperty(Socket.prototype, 'readyState', {
	  get: function () {
	    var self = this
	    if (self._connecting) {
	      return 'opening'
	    } else if (self.readable && self.writable) {
	      return 'open'
	    } else {
	      return 'closed'
	    }
	  }
	})

	Socket.prototype.unref = function () {
	  // No chrome.socket equivalent
	}

	Socket.prototype.ref = function () {
	  // No chrome.socket equivalent
	}

	//
	// EXPORTED HELPERS
	//

	exports.isIP = function (input) {
	  try {
	    ipaddr.parse(input)
	  } catch (e) {
	    return false
	  }
	  return true
	}

	exports.isIPv4 = function (input) {
	  try {
	    var parsed = ipaddr.parse(input)
	    return (parsed.kind() === 'ipv4')
	  } catch (e) {
	    return false
	  }
	}

	exports.isIPv6 = function (input) {
	  try {
	    var parsed = ipaddr.parse(input)
	    return (parsed.kind() === 'ipv6')
	  } catch (e) {
	    return false
	  }
	}

	//
	// HELPERS
	//

	/**
	 * Returns an array [options] or [options, cb]
	 * It is the same as the argument of Socket.prototype.connect().
	 */
	function normalizeConnectArgs (args) {
	  var options = {}

	  if (is.isObject(args[0])) {
	    // connect(options, [cb])
	    options = args[0]
	  } else {
	    // connect(port, [host], [cb])
	    options.port = args[0]
	    if (is.isString(args[1])) {
	      options.host = args[1]
	    } else {
	      options.host = '127.0.0.1'
	    }
	  }

	  var cb = args[args.length - 1]
	  return is.isFunction(cb) ? [options, cb] : [options]
	}

	function toNumber (x) {
	  return (x = Number(x)) >= 0 ? x : false
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21), __webpack_require__(1).Buffer))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(133)

	var md5 = toConstructor(__webpack_require__(126))
	var rmd160 = toConstructor(__webpack_require__(131))

	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}

	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = function (crypto, password, keyLen, ivLen) {
	  keyLen = keyLen/8;
	  ivLen = ivLen || 0;
	  var ki = 0;
	  var ii = 0;
	  var key = new Buffer(keyLen);
	  var iv = new Buffer(ivLen);
	  var addmd = 0;
	  var md, md_buf;
	  var i;
	  while (true) {
	    md = crypto.createHash('md5');
	    if(addmd++ > 0) {
	       md.update(md_buf);
	    }
	    md.update(password);
	    md_buf = md.digest();
	    i = 0;
	    if(keyLen > 0) {
	      while(true) {
	        if(keyLen === 0) {
	          break;
	        }
	        if(i === md_buf.length) {
	          break;
	        }
	        key[ki++] = md_buf[i];
	        keyLen--;
	        i++;
	       }
	    }
	    if(ivLen > 0 && i !== md_buf.length) {
	      while(true) {
	        if(ivLen === 0) {
	          break;
	        }
	        if(i === md_buf.length) {
	          break;
	        }
	       iv[ii++] = md_buf[i];
	       ivLen--;
	       i++;
	     }
	   }
	   if(keyLen === 0 && ivLen === 0) {
	      break;
	    }
	  }
	  for(i=0;i<md_buf.length;i++) {
	    md_buf[i] = 0;
	  }
	  return {
	    key: key,
	    iv: iv
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var xor = __webpack_require__(38);
	exports.encrypt = function (self, block) {
	  var data = xor(block, self._prev);
	  self._prev = self._cipher.encryptBlock(data);
	  return self._prev;
	};
	exports.decrypt = function (self, block) {
	  var pad = self._prev;
	  self._prev = block;
	  var out = self._cipher.decryptBlock(block);
	  return xor(out, pad);
	};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(38);
	exports.encrypt = function (self, data, decrypt) {
	  var out = new Buffer('');
	  var len;
	  while (data.length) {
	    if (self._cache.length === 0) {
	      self._cache = self._cipher.encryptBlock(self._prev);
	      self._prev = new Buffer('');
	    }
	    if (self._cache.length <= data.length) {
	      len = self._cache.length;
	      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
	      data = data.slice(len);
	    } else {
	      out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
	      break;
	    }
	  }
	  return out;
	};
	function encryptStart(self, data, decrypt) {
	  var len = data.length;
	  var out = xor(data, self._cache);
	  self._cache = self._cache.slice(len);
	  self._prev = Buffer.concat([self._prev, decrypt?data:out]);
	  return out;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(38);
	function getBlock(self) {
	  var out = self._cipher.encryptBlock(self._prev);
	  incr32(self._prev);
	  return out;
	}
	exports.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer.concat([self._cache, getBlock(self)]);
	  }
	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor(chunk, pad);
	};
	function incr32(iv) {
	  var len = iv.length;
	  var item;
	  while (len--) {
	    item = iv.readUInt8(len);
	    if (item === 255) {
	      iv.writeUInt8(0, len);
	    } else {
	      item++;
	      iv.writeUInt8(item, len);
	      break;
	    }
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	exports.encrypt = function (self, block) {
	  return self._cipher.encryptBlock(block);
	};
	exports.decrypt = function (self, block) {
	  return self._cipher.decryptBlock(block);
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(38);
	function getBlock(self) {
	  self._prev = self._cipher.encryptBlock(self._prev);
	  return self._prev;
	}
	exports.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer.concat([self._cache, getBlock(self)]);
	  }
	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor(chunk, pad);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(48);
	var Transform = __webpack_require__(49);
	var inherits = __webpack_require__(37);

	inherits(StreamCipher, Transform);
	module.exports = StreamCipher;
	function StreamCipher(mode, key, iv, decrypt) {
	  if (!(this instanceof StreamCipher)) {
	    return new StreamCipher(mode, key, iv);
	  }
	  Transform.call(this);
	  this._cipher = new aes.AES(key);
	  this._prev = new Buffer(iv.length);
	  this._cache = new Buffer('');
	  this._secCache = new Buffer('');
	  this._decrypt = decrypt;
	  iv.copy(this._prev);
	  this._mode = mode;
	}
	StreamCipher.prototype._transform = function (chunk, _, next) {
	  next(null, this._mode.encrypt(this, chunk, this._decrypt));
	};
	StreamCipher.prototype._flush = function (next) {
	  this._cipher.scrub();
	  next();
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(51);

	/*<replacement>*/
	var util = __webpack_require__(29);
	util.inherits = __webpack_require__(30);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(144);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(1).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(26).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(31);

	/*<replacement>*/
	var util = __webpack_require__(29);
	util.inherits = __webpack_require__(30);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(154);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(22);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(77).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(22);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(77).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(1).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/* This is a 'dns' module 'replacement' since Chrome App API
	 * has no dns abilities :(  I didn't want to make a full blown
	 * dns client, so this is a temporary workaround using statdns.com's
	 * HTTP interface to DNS, as this was simple to get up and running
	 * with quickly.
	 *
	 * Currently this is just barebones what is needed by bitcoin-p2p/pool.js
	 * May break this out into its own module eventually.
	 *
	 */

	var base_url='http://api.statdns.com/';

	// This is for running with node for testing
	//if(!window) {
	    //require.ensure([], function(require){
	        //XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
	    //});
	//}

	exports.resolve = function(domain, rrtype, cb) {
	    var res;
	    if (!cb) {
	        cb = rrtype;
	        rrtype = undefined;
	    }
	    if(!rrtype) {
	        rrtype = 'A'
	    }

	    var xhr = new XMLHttpRequest();
	    xhr.open("GET", base_url + domain + '/' + rrtype, true);
	    xhr.onload = function(e) {
	        var ips = [];
	        var response = JSON.parse(this.responseText);
	        if(response.code) {
	            return cb("Bad DNS lookup response")
	        };
	        for (var i in response.answer) {
	            ips.push(response.answer[i].rdata);
	        }
	        cb(null, ips);
	    }
	    xhr.onerror = function(e) { cb("Error with dns lookup request") }
	    xhr.send();
	};


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var bitcore = __webpack_require__(32);
	bitcore.P2P = __webpack_require__(80);

	module.exports = bitcore.P2P;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @namespace P2P
	 */
	module.exports = {
	  Messages: __webpack_require__(53),
	  Peer: __webpack_require__(54),
	  Pool: __webpack_require__(81)
	};


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var dns = __webpack_require__(78);
	var EventEmitter = __webpack_require__(26).EventEmitter;

	var bitcore = __webpack_require__(32);
	var Networks = bitcore.Networks;
	var sha256 = bitcore.crypto.Hash.sha256;
	var Peer = __webpack_require__(54);
	var util = __webpack_require__(16);

	function now() {
	  return Math.floor(new Date().getTime() / 1000);
	}

	/**
	 * A pool is a collection of Peers. A pool will discover peers from DNS seeds, and
	 * collect information about new peers in the network. When a peer disconnects the pool
	 * will connect to others that are available to maintain a max number of
	 * ongoing peer connections. Peer events are relayed to the pool.
	 *
	 * @example
	 * ```javascript
	 *
	 * var pool = new Pool(Networks.livenet);
	 * pool.on('peerinv', function(peer, message) {
	 *   // do something with the inventory announcement
	 * });
	 * pool.connect();
	 * ```
	 *
	 * @param {Network|String} network - The network to connect
	 * @returns {Pool}
	 * @constructor
	 */
	function Pool(network) {

	  var self = this;

	  this.network = Networks.get(network) || Networks.defaultNetwork;
	  this.keepalive = false;
	  this._connectedPeers = {};
	  this._addrs = [];

	  this.on('peeraddr', function peerAddrEvent(peer, message) {
	    var addrs = message.addresses;
	    var length = addrs.length;
	    for (var i = 0; i < length; i++) {
	      var addr = addrs[i];
	      // In case of an invalid time, assume "5 days ago"
	      if (addr.time <= 100000000 || addr.time > (now() + 10 * 60)) {
	        addr.time = now() - 5 * 24 * 60 * 60;
	      }
	      this._addAddr(addr);
	    }
	  });

	  this.on('seed', function seedEvent(ips) {
	    ips.forEach(function(ip) {
	      self._addAddr({
	        ip: {
	          v4: ip
	        }
	      });
	    });
	    if (self.keepalive) {
	      self._fillConnections();
	    }
	  });

	  this.on('peerdisconnect', function peerDisconnectEvent(peer, addr) {
	    self._deprioritizeAddr(addr);
	    self._removeConnectedPeer(addr);
	    if (self.keepalive) {
	      self._fillConnections();
	    }
	  });

	  return this;

	}

	util.inherits(Pool, EventEmitter);

	Pool.MaxConnectedPeers = 8;
	Pool.RetrySeconds = 30;
	Pool.PeerEvents = ['version', 'inv', 'getdata', 'ping', 'ping', 'addr',
	  'getaddr', 'verack', 'reject', 'alert', 'headers', 'block',
	  'tx', 'getblocks', 'getheaders'
	];


	/**
	 * Will initiatiate connection to peers, if available peers have been added to
	 * the pool, it will connect to those, otherwise will use DNS seeds to find
	 * peers to connect. When a peer disconnects it will add another.
	 */
	Pool.prototype.connect = function connect() {
	  this.keepalive = true;
	  var self = this;
	  if (self._addrs.length === 0) {
	    self._addAddrsFromSeeds();
	  } else {
	    self._fillConnections();
	  }
	  return this;
	};


	/**
	 * Will disconnect all peers that are connected.
	 */
	Pool.prototype.disconnect = function disconnect() {
	  this.keepalive = false;
	  for (var i in this._connectedPeers) {
	    this._connectedPeers[i].disconnect();
	  }
	  return this;
	};

	/**
	 * @returns {Number} The number of peers currently connected.
	 */
	Pool.prototype.numberConnected = function numberConnected() {
	  return Object.keys(this._connectedPeers).length;
	};

	/**
	 * Will fill the conneted peers to the maximum amount.
	 */
	Pool.prototype._fillConnections = function _fillConnections() {
	  var length = this._addrs.length;
	  for (var i = 0; i < length; i++) {
	    if (this.numberConnected() >= Pool.MaxConnectedPeers) {
	      break;
	    }
	    var addr = this._addrs[i];
	    if (!addr.retryTime || now() > addr.retryTime) {
	      this._connectPeer(addr);
	    }
	  }
	  return this;
	};

	/**
	 * Will remove a peer from the list of connected peers.
	 * @param {Object} addr - An addr from the list of addrs
	 */
	Pool.prototype._removeConnectedPeer = function _removeConnectedPeer(addr) {
	  if (this._connectedPeers[addr.hash].status !== Peer.STATUS.DISCONNECTED) {
	    this._connectedPeers[addr.hash].disconnect();
	  } else {
	    delete this._connectedPeers[addr.hash];
	  }
	  return this;
	};

	/**
	 * Will connect a peer and add to the list of connected peers.
	 * @param {Object} addr - An addr from the list of addrs
	 */
	Pool.prototype._connectPeer = function _connectPeer(addr) {
	  var self = this;

	  function addConnectedPeer(addr) {
	    var port = addr.port || self.network.port;
	    var ip = addr.ip.v4 || addr.ip.v6;
	    var peer = new Peer(ip, port, self.network);
	    peer.on('disconnect', function peerDisconnect() {
	      self.emit('peerdisconnect', peer, addr);
	    });
	    peer.on('ready', function peerReady() {
	      self.emit('peerready', peer, addr);
	    });
	    Pool.PeerEvents.forEach(function addPeerEvents(event) {
	      peer.on(event, function peerEvent(message) {
	        self.emit('peer' + event, peer, message);
	      });
	    });
	    peer.connect();
	    self._connectedPeers[addr.hash] = peer;
	  }

	  if (!this._connectedPeers[addr.hash]) {
	    addConnectedPeer(addr);
	  }

	  return this;
	};

	/**
	 * Will deprioritize an addr in the list of addrs by moving it to the end
	 * of the array, and setting a retryTime
	 * @param {Object} addr - An addr from the list of addrs
	 */
	Pool.prototype._deprioritizeAddr = function _deprioritizeAddr(addr) {
	  for (var i = 0; i < this._addrs.length; i++) {
	    if (this._addrs[i].hash === addr.hash) {
	      var middle = this._addrs[i];
	      middle.retryTime = now() + Pool.RetrySeconds;
	      var beginning = this._addrs.splice(0, i);
	      var end = this._addrs.splice(i + 1, this._addrs.length);
	      var combined = beginning.concat(end);
	      this._addrs = combined.concat([middle]);
	    }
	  }
	  return this;
	};

	/**
	 * Will add an addr to the beginning of the addrs array
	 * @param {Object}
	 */
	Pool.prototype._addAddr = function _addAddr(addr) {

	  // make a unique key
	  addr.hash = sha256(new Buffer(addr.ip.v6 + addr.ip.v4 + addr.port)).toString('hex');

	  var length = this._addrs.length;
	  var exists = false;
	  for (var i = 0; i < length; i++) {
	    if (this._addrs[i].hash === addr.hash) {
	      exists = true;
	    }
	  }
	  if (!exists) {
	    this._addrs.unshift(addr);
	  }
	  return this;
	};

	/**
	 * Will add addrs to the list of addrs from a DNS seed
	 * @param {String} seed - A domain name to resolve known peers
	 * @param {Function} done
	 */
	Pool.prototype._addAddrsFromSeed = function _addAddrsFromSeed(seed) {
	  var self = this;
	  dns.resolve(seed, function(err, ips) {
	    if (err) {
	      self.emit('seederror', err);
	      return;
	    }
	    if (!ips || !ips.length) {
	      self.emit('seederror', new Error('No IPs found from seed lookup.'));
	      return;
	    }
	    // announce to pool
	    self.emit('seed', ips);
	  });
	  return this;
	};

	/**
	 * Will add addrs to the list of addrs from network DNS seeds
	 * @param {Function} done
	 */
	Pool.prototype._addAddrsFromSeeds = function _addAddrsFromSeeds() {
	  var self = this;
	  var seeds = this.network.dnsSeeds;
	  seeds.forEach(function(seed) {
	    self._addAddrsFromSeed(seed);
	  });
	  return this;
	};

	/**
	 * @returns {String} A string formatted for the console
	 */
	Pool.prototype.inspect = function inspect() {
	  return '<Pool network: ' +
	    this.network + ', connected: ' +
	    this.numberConnected() + ', available: ' +
	    this._addrs.length + '>';
	};

	module.exports = Pool;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var BufferWriter = __webpack_require__(12);
	var BufferReader = __webpack_require__(18);
	var BN = __webpack_require__(6);

	var Varint = function Varint(buf) {
	  if (!(this instanceof Varint))
	    return new Varint(buf);
	  if (Buffer.isBuffer(buf)) {
	    this.buf = buf;
	  } else if (typeof buf === 'number') {
	    var num = buf;
	    this.fromNumber(num);
	  } else if (buf instanceof BN) {
	    var bn = buf;
	    this.fromBN(bn);
	  } else if (buf) {
	    var obj = buf;
	    this.set(obj);
	  }
	};

	Varint.prototype.set = function(obj) {
	  this.buf = obj.buf || this.buf;
	  return this;
	};

	Varint.prototype.fromString = function(str) {
	  this.set({
	    buf: new Buffer(str, 'hex')
	  });
	  return this;
	};

	Varint.prototype.toString = function() {
	  return this.buf.toString('hex');
	};

	Varint.prototype.fromBuffer = function(buf) {
	  this.buf = buf;
	  return this;
	};

	Varint.prototype.fromBufferReader = function(br) {
	  this.buf = br.readVarintBuf();
	  return this;
	};

	Varint.prototype.fromBN = function(bn) {
	  this.buf = BufferWriter().writeVarintBN(bn).concat();
	  return this;
	};

	Varint.prototype.fromNumber = function(num) {
	  this.buf = BufferWriter().writeVarintNum(num).concat();
	  return this;
	};

	Varint.prototype.toBuffer = function() {
	  return this.buf;
	};

	Varint.prototype.toBN = function() {
	  return BufferReader(this.buf).readVarintBN();
	};

	Varint.prototype.toNumber = function() {
	  return BufferReader(this.buf).readVarintNum();
	};

	module.exports = Varint;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = [{
	  name: 'InvalidB58Char',
	  message: 'Invalid Base58 character: {0} in {1}'
	}, {
	  name: 'InvalidB58Checksum',
	  message: 'Invalid Base58 checksum for {0}'
	}, {
	  name: 'InvalidNetwork',
	  message: 'Invalid version for network: got {0}'
	}, {
	  name: 'InvalidState',
	  message: 'Invalid state: {0}'
	}, {
	  name: 'NotImplemented',
	  message: 'Function {0} was not implemented yet'
	}, {
	  name: 'InvalidNetworkArgument',
	  message: 'Invalid network: must be "livenet" or "testnet", got {0}'
	}, {
	  name: 'InvalidArgument',
	  message: function() {
	    return 'Invalid Argument' + (arguments[0] ? (': ' + arguments[0]) : '');
	  }
	}, {
	  name: 'AbstractMethodInvoked',
	  message: 'Abstract Method Invokation: {0}'
	}, {
	  name: 'InvalidArgumentType',
	  message: function() {
	    return 'Invalid Argument for ' + arguments[2] + ', expected ' + arguments[1] + ' but got ' + typeof arguments[0];
	  }
	}, {
	  name: 'Unit',
	  message: 'Internal Error on Unit {0}',
	  errors: [{
	    'name': 'UnknownCode',
	    'message': 'Unrecognized unit code: {0}'
	  }, {
	    'name': 'InvalidRate',
	    'message': 'Invalid exchange rate: {0}'
	  }]
	}, {
	  name: 'Transaction',
	  message: 'Internal Error on Transaction {0}',
	  errors: [{
	    name: 'Input',
	    message: 'Internal Error on Input {0}',
	    errors: [{
	      name: 'MissingScript',
	      message: 'Need a script to create an input'
	    }]
	  }, {
	    name: 'NeedMoreInfo',
	    message: '{0}'
	  }, {
	    name: 'UnableToVerifySignature',
	    message: 'Unable to verify signature: {0}'
	  }, {
	    name: 'DustOutputs',
	    message: 'Dust amount detected in one output'
	  }, {
	    name: 'FeeError',
	    message: 'Fees are not correctly set {0}',
	  }, {
	    name: 'ChangeAddressMissing',
	    message: 'Change address is missing'
	  }]
	}, {
	  name: 'Script',
	  message: 'Internal Error on Script {0}',
	  errors: [{
	    name: 'UnrecognizedAddress',
	    message: 'Expected argument {0} to be an address'
	  }]
	}, {
	  name: 'HDPrivateKey',
	  message: 'Internal Error on HDPrivateKey {0}',
	  errors: [{
	    name: 'InvalidDerivationArgument',
	    message: 'Invalid derivation argument {0}, expected string, or number and boolean'
	  }, {
	    name: 'InvalidEntropyArgument',
	    message: 'Invalid entropy: must be an hexa string or binary buffer, got {0}',
	    errors: [{
	      name: 'TooMuchEntropy',
	      message: 'Invalid entropy: more than 512 bits is non standard, got "{0}"'
	    }, {
	      name: 'NotEnoughEntropy',
	      message: 'Invalid entropy: at least 128 bits needed, got "{0}"'
	    }]
	  }, {
	    name: 'InvalidLength',
	    message: 'Invalid length for xprivkey string in {0}'
	  }, {
	    name: 'InvalidPath',
	    message: 'Invalid derivation path: {0}'
	  }, {
	    name: 'UnrecognizedArgument',
	    message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got "{0}"'
	  }]
	}, {
	  name: 'HDPublicKey',
	  message: 'Internal Error on HDPublicKey {0}',
	  errors: [{
	    name: 'ArgumentIsPrivateExtended',
	    message: 'Argument is an extended private key: {0}'
	  }, {
	    name: 'InvalidDerivationArgument',
	    message: 'Invalid derivation argument: got {0}'
	  }, {
	    name: 'InvalidLength',
	    message: 'Invalid length for xpubkey: got "{0}"'
	  }, {
	    name: 'InvalidPath',
	    message: 'Invalid derivation path, it should look like: "m/1/100", got "{0}"'
	  }, {
	    name: 'MustSupplyArgument',
	    message: 'Must supply an argument to create a HDPublicKey'
	  }, {
	    name: 'UnrecognizedArgument',
	    message: 'Invalid argument for creation, must be string, json, buffer, or object'
	  }]
	}];


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	var _ = __webpack_require__(2);

	var Script = __webpack_require__(60);
	var Opcode = __webpack_require__(40);
	var BN = __webpack_require__(6);
	var Hash = __webpack_require__(7);
	var Signature = __webpack_require__(14);
	var PublicKey = __webpack_require__(13);

	/**
	 * Bitcoin transactions contain scripts. Each input has a script called the
	 * scriptSig, and each output has a script called the scriptPubkey. To validate
	 * an input, the input's script is concatenated with the referenced output script,
	 * and the result is executed. If at the end of execution the stack contains a
	 * "true" value, then the transaction is valid.
	 *
	 * The primary way to use this class is via the verify function.
	 * e.g., Interpreter().verify( ... );
	 */
	var Interpreter = function Interpreter(obj) {
	  if (!(this instanceof Interpreter)) {
	    return new Interpreter(obj);
	  }
	  if (obj) {
	    this.initialize();
	    this.set(obj);
	  } else {
	    this.initialize();
	  }
	};

	/**
	 * Verifies a Script by executing it and returns true if it is valid.
	 * This function needs to be provided with the scriptSig and the scriptPubkey
	 * separately.
	 * @param {Script} scriptSig - the script's first part (corresponding to the tx input)
	 * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)
	 * @param {Transaction} [tx] - the Transaction containing the scriptSig in one input (used
	 *    to check signature validity for some opcodes like OP_CHECKSIG)
	 * @param {number} nin - index of the transaction input containing the scriptSig verified.
	 * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants
	 *
	 * Translated from bitcoind's VerifyScript
	 */
	Interpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags) {
	  var Transaction = __webpack_require__(41);
	  if (_.isUndefined(tx)) {
	    tx = new Transaction();
	  }
	  if (_.isUndefined(nin)) {
	    nin = 0;
	  }
	  if (_.isUndefined(flags)) {
	    flags = 0;
	  }
	  this.set({
	    script: scriptSig,
	    tx: tx,
	    nin: nin,
	    flags: flags
	  });
	  var stackCopy;

	  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {
	    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';
	    return false;
	  }

	  // evaluate scriptSig
	  if (!this.evaluate()) {
	    return false;
	  }

	  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {
	    stackCopy = this.stack.slice();
	  }

	  var stack = this.stack;
	  this.initialize();
	  this.set({
	    script: scriptPubkey,
	    stack: stack,
	    tx: tx,
	    nin: nin,
	    flags: flags
	  });

	  // evaluate scriptPubkey
	  if (!this.evaluate()) {
	    return false;
	  }

	  if (this.stack.length === 0) {
	    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';
	    return false;
	  }

	  var buf = this.stack[this.stack.length - 1];
	  if (!Interpreter.castToBool(buf)) {
	    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';
	    return false;
	  }

	  // Additional validation for spend-to-script-hash transactions:
	  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {
	    // scriptSig must be literals-only or validation fails
	    if (!scriptSig.isPushOnly()) {
	      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';
	      return false;
	    }

	    // stackCopy cannot be empty here, because if it was the
	    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with
	    // an empty stack and the EvalScript above would return false.
	    if (stackCopy.length === 0) {
	      throw new Error('internal error - stack copy empty');
	    }

	    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];
	    var redeemScript = Script.fromBuffer(redeemScriptSerialized);
	    stackCopy.pop();

	    this.initialize();
	    this.set({
	      script: redeemScript,
	      stack: stackCopy,
	      tx: tx,
	      nin: nin,
	      flags: flags
	    });

	    // evaluate redeemScript
	    if (!this.evaluate()) {
	      return false;
	    }

	    if (stackCopy.length === 0) {
	      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';
	      return false;
	    }

	    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {
	      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';
	      return false;
	    } else {
	      return true;
	    }
	  }

	  return true;
	};

	module.exports = Interpreter;

	Interpreter.prototype.initialize = function(obj) {
	  this.stack = [];
	  this.altstack = [];
	  this.pc = 0;
	  this.pbegincodehash = 0;
	  this.nOpCount = 0;
	  this.vfExec = [];
	  this.errstr = '';
	  this.flags = 0;
	};

	Interpreter.prototype.set = function(obj) {
	  this.script = obj.script || this.script;
	  this.tx = obj.tx || this.tx;
	  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;
	  this.stack = obj.stack || this.stack;
	  this.altstack = obj.altack || this.altstack;
	  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;
	  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;
	  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;
	  this.vfExec = obj.vfExec || this.vfExec;
	  this.errstr = obj.errstr || this.errstr;
	  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;
	};

	Interpreter.true = new Buffer([1]);
	Interpreter.false = new Buffer([]);

	Interpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;

	// flags taken from bitcoind
	// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
	Interpreter.SCRIPT_VERIFY_NONE = 0;

	// Evaluate P2SH subscripts (softfork safe, BIP16).
	Interpreter.SCRIPT_VERIFY_P2SH = (1 << 0);

	// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
	// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be
	// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
	Interpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);

	// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)
	Interpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);

	// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
	// (softfork safe, BIP62 rule 5).
	Interpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);

	// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).
	Interpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);

	// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
	Interpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);

	// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct
	// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating
	// any other push causes the script to fail (BIP62 rule 3).
	// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).
	// (softfork safe)
	Interpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);

	// Discourage use of NOPs reserved for upgrades (NOP1-10)
	//
	// Provided so that nodes can avoid accepting or mining transactions
	// containing executed NOP's whose meaning may change after a soft-fork,
	// thus rendering the script invalid; with this flag set executing
	// discouraged NOPs fails the script. This verification flag will never be
	// a mandatory flag applied to scripts in a block. NOPs that are not
	// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.
	Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);

	Interpreter.castToBool = function(buf) {
	  for (var i = 0; i < buf.length; i++) {
	    if (buf[i] !== 0) {
	      // can be negative zero
	      if (i === buf.length - 1 && buf[i] === 0x80) {
	        return false;
	      }
	      return true;
	    }
	  }
	  return false;
	};

	/**
	 * Translated from bitcoind's CheckSignatureEncoding
	 */
	Interpreter.prototype.checkSignatureEncoding = function(buf) {
	  var sig;
	  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {
	    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';
	    return false;
	  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {
	    sig = Signature.fromTxFormat(buf);
	    if (!sig.hasLowS()) {
	      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';
	      return false;
	    }
	  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {
	    sig = Signature.fromTxFormat(buf);
	    if (!sig.hasDefinedHashtype()) {
	      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';
	      return false;
	    }
	  }
	  return true;
	};

	/**
	 * Translated from bitcoind's CheckPubKeyEncoding
	 */
	Interpreter.prototype.checkPubkeyEncoding = function(buf) {
	  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {
	    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';
	    return false;
	  }
	  return true;
	};

	/**
	 * Based on bitcoind's EvalScript function, with the inner loop moved to
	 * Interpreter.prototype.step()
	 * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
	 */
	Interpreter.prototype.evaluate = function() {
	  if (this.script.toBuffer().length > 10000) {
	    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';
	    return false;
	  }

	  try {
	    while (this.pc < this.script.chunks.length) {
	      var fSuccess = this.step();
	      if (!fSuccess) {
	        return false;
	      }
	    }

	    // Size limits
	    if (this.stack.length + this.altstack.length > 1000) {
	      this.errstr = 'SCRIPT_ERR_STACK_SIZE';
	      return false;
	    }
	  } catch (e) {
	    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;
	    return false;
	  }

	  if (this.vfExec.length > 0) {
	    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
	    return false;
	  }

	  return true;
	};

	/** 
	 * Based on the inner loop of bitcoind's EvalScript function
	 * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104
	 */
	Interpreter.prototype.step = function() {

	  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;

	  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);
	  var fExec = (this.vfExec.indexOf(false) === -1);
	  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;
	  var sig, pubkey;
	  var fValue, fSuccess;

	  // Read instruction
	  var chunk = this.script.chunks[this.pc];
	  this.pc++;
	  var opcodenum = chunk.opcodenum;
	  if (_.isUndefined(opcodenum)) {
	    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';
	    return false;
	  }
	  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
	    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';
	    return false;
	  }

	  // Note how Opcode.OP_RESERVED does not count towards the opcode limit.
	  if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {
	    this.errstr = 'SCRIPT_ERR_OP_COUNT';
	    return false;
	  }


	  if (opcodenum === Opcode.OP_CAT ||
	    opcodenum === Opcode.OP_SUBSTR ||
	    opcodenum === Opcode.OP_LEFT ||
	    opcodenum === Opcode.OP_RIGHT ||
	    opcodenum === Opcode.OP_INVERT ||
	    opcodenum === Opcode.OP_AND ||
	    opcodenum === Opcode.OP_OR ||
	    opcodenum === Opcode.OP_XOR ||
	    opcodenum === Opcode.OP_2MUL ||
	    opcodenum === Opcode.OP_2DIV ||
	    opcodenum === Opcode.OP_MUL ||
	    opcodenum === Opcode.OP_DIV ||
	    opcodenum === Opcode.OP_MOD ||
	    opcodenum === Opcode.OP_LSHIFT ||
	    opcodenum === Opcode.OP_RSHIFT) {
	    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';
	    return false;
	  }

	  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {
	    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {
	      this.errstr = 'SCRIPT_ERR_MINIMALDATA';
	      return false;
	    }
	    if (!chunk.buf) {
	      this.stack.push(Interpreter.false);
	    } else if (chunk.len !== chunk.buf.length) {
	      throw new Error('Length of push value not equal to length of data');
	    } else {
	      this.stack.push(chunk.buf);
	    }
	  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {
	    switch (opcodenum) {
	      // Push value
	      case Opcode.OP_1NEGATE:
	      case Opcode.OP_1:
	      case Opcode.OP_2:
	      case Opcode.OP_3:
	      case Opcode.OP_4:
	      case Opcode.OP_5:
	      case Opcode.OP_6:
	      case Opcode.OP_7:
	      case Opcode.OP_8:
	      case Opcode.OP_9:
	      case Opcode.OP_10:
	      case Opcode.OP_11:
	      case Opcode.OP_12:
	      case Opcode.OP_13:
	      case Opcode.OP_14:
	      case Opcode.OP_15:
	      case Opcode.OP_16:
	        {
	          // ( -- value)
	          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));
	          n = opcodenum - (Opcode.OP_1 - 1);
	          buf = BN(n).toScriptNumBuffer();
	          this.stack.push(buf);
	          // The result of these opcodes should always be the minimal way to push the data
	          // they push, so no need for a CheckMinimalPush here.
	        }
	        break;


	        //
	        // Control
	        //
	      case Opcode.OP_NOP:
	        break;

	      case Opcode.OP_NOP1:
	      case Opcode.OP_NOP2:
	      case Opcode.OP_NOP3:
	      case Opcode.OP_NOP4:
	      case Opcode.OP_NOP5:
	      case Opcode.OP_NOP6:
	      case Opcode.OP_NOP7:
	      case Opcode.OP_NOP8:
	      case Opcode.OP_NOP9:
	      case Opcode.OP_NOP10:
	        {
	          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
	            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';
	            return false;
	          }
	        }
	        break;

	      case Opcode.OP_IF:
	      case Opcode.OP_NOTIF:
	        {
	          // <expression> if [statements] [else [statements]] endif
	          // bool fValue = false;
	          fValue = false;
	          if (fExec) {
	            if (this.stack.length < 1) {
	              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
	              return false;
	            }
	            buf = this.stack.pop();
	            fValue = Interpreter.castToBool(buf);
	            if (opcodenum === Opcode.OP_NOTIF) {
	              fValue = !fValue;
	            }
	          }
	          this.vfExec.push(fValue);
	        }
	        break;

	      case Opcode.OP_ELSE:
	        {
	          if (this.vfExec.length === 0) {
	            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
	            return false;
	          }
	          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];
	        }
	        break;

	      case Opcode.OP_ENDIF:
	        {
	          if (this.vfExec.length === 0) {
	            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';
	            return false;
	          }
	          this.vfExec.pop();
	        }
	        break;

	      case Opcode.OP_VERIFY:
	        {
	          // (true -- ) or
	          // (false -- false) and return
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf = this.stack[this.stack.length - 1];
	          fValue = Interpreter.castToBool(buf);
	          if (fValue) {
	            this.stack.pop();
	          } else {
	            this.errstr = 'SCRIPT_ERR_VERIFY';
	            return false;
	          }
	        }
	        break;

	      case Opcode.OP_RETURN:
	        {
	          this.errstr = 'SCRIPT_ERR_OP_RETURN';
	          return false;
	        }
	        break;


	        //
	        // Stack ops
	        //
	      case Opcode.OP_TOALTSTACK:
	        {
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          this.altstack.push(this.stack.pop());
	        }
	        break;

	      case Opcode.OP_FROMALTSTACK:
	        {
	          if (this.altstack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';
	            return false;
	          }
	          this.stack.push(this.altstack.pop());
	        }
	        break;

	      case Opcode.OP_2DROP:
	        {
	          // (x1 x2 -- )
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          this.stack.pop();
	          this.stack.pop();
	        }
	        break;

	      case Opcode.OP_2DUP:
	        {
	          // (x1 x2 -- x1 x2 x1 x2)
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf1 = this.stack[this.stack.length - 2];
	          buf2 = this.stack[this.stack.length - 1];
	          this.stack.push(buf1);
	          this.stack.push(buf2);
	        }
	        break;

	      case Opcode.OP_3DUP:
	        {
	          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)
	          if (this.stack.length < 3) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf1 = this.stack[this.stack.length - 3];
	          buf2 = this.stack[this.stack.length - 2];
	          var buf3 = this.stack[this.stack.length - 1];
	          this.stack.push(buf1);
	          this.stack.push(buf2);
	          this.stack.push(buf3);
	        }
	        break;

	      case Opcode.OP_2OVER:
	        {
	          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)
	          if (this.stack.length < 4) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf1 = this.stack[this.stack.length - 4];
	          buf2 = this.stack[this.stack.length - 3];
	          this.stack.push(buf1);
	          this.stack.push(buf2);
	        }
	        break;

	      case Opcode.OP_2ROT:
	        {
	          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)
	          if (this.stack.length < 6) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          spliced = this.stack.splice(this.stack.length - 6, 2);
	          this.stack.push(spliced[0]);
	          this.stack.push(spliced[1]);
	        }
	        break;

	      case Opcode.OP_2SWAP:
	        {
	          // (x1 x2 x3 x4 -- x3 x4 x1 x2)
	          if (this.stack.length < 4) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          spliced = this.stack.splice(this.stack.length - 4, 2);
	          this.stack.push(spliced[0]);
	          this.stack.push(spliced[1]);
	        }
	        break;

	      case Opcode.OP_IFDUP:
	        {
	          // (x - 0 | x x)
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf = this.stack[this.stack.length - 1];
	          fValue = Interpreter.castToBool(buf);
	          if (fValue) {
	            this.stack.push(buf);
	          }
	        }
	        break;

	      case Opcode.OP_DEPTH:
	        {
	          // -- stacksize
	          buf = BN(this.stack.length).toScriptNumBuffer();
	          this.stack.push(buf);
	        }
	        break;

	      case Opcode.OP_DROP:
	        {
	          // (x -- )
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          this.stack.pop();
	        }
	        break;

	      case Opcode.OP_DUP:
	        {
	          // (x -- x x)
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          this.stack.push(this.stack[this.stack.length - 1]);
	        }
	        break;

	      case Opcode.OP_NIP:
	        {
	          // (x1 x2 -- x2)
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          this.stack.splice(this.stack.length - 2, 1);
	        }
	        break;

	      case Opcode.OP_OVER:
	        {
	          // (x1 x2 -- x1 x2 x1)
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          this.stack.push(this.stack[this.stack.length - 2]);
	        }
	        break;

	      case Opcode.OP_PICK:
	      case Opcode.OP_ROLL:
	        {
	          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)
	          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf = this.stack[this.stack.length - 1];
	          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
	          n = bn.toNumber();
	          this.stack.pop();
	          if (n < 0 || n >= this.stack.length) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf = this.stack[this.stack.length - n - 1];
	          if (opcodenum === Opcode.OP_ROLL) {
	            this.stack.splice(this.stack.length - n - 1, 1);
	          }
	          this.stack.push(buf);
	        }
	        break;

	      case Opcode.OP_ROT:
	        {
	          // (x1 x2 x3 -- x2 x3 x1)
	          //  x2 x1 x3  after first swap
	          //  x2 x3 x1  after second swap
	          if (this.stack.length < 3) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          x1 = this.stack[this.stack.length - 3];
	          x2 = this.stack[this.stack.length - 2];
	          var x3 = this.stack[this.stack.length - 1];
	          this.stack[this.stack.length - 3] = x2;
	          this.stack[this.stack.length - 2] = x3;
	          this.stack[this.stack.length - 1] = x1;
	        }
	        break;

	      case Opcode.OP_SWAP:
	        {
	          // (x1 x2 -- x2 x1)
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          x1 = this.stack[this.stack.length - 2];
	          x2 = this.stack[this.stack.length - 1];
	          this.stack[this.stack.length - 2] = x2;
	          this.stack[this.stack.length - 1] = x1;
	        }
	        break;

	      case Opcode.OP_TUCK:
	        {
	          // (x1 x2 -- x2 x1 x2)
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);
	        }
	        break;


	      case Opcode.OP_SIZE:
	        {
	          // (in -- in size)
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          bn = BN(this.stack[this.stack.length - 1].length);
	          this.stack.push(bn.toScriptNumBuffer());
	        }
	        break;


	        //
	        // Bitwise logic
	        //
	      case Opcode.OP_EQUAL:
	      case Opcode.OP_EQUALVERIFY:
	        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL
	        {
	          // (x1 x2 - bool)
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf1 = this.stack[this.stack.length - 2];
	          buf2 = this.stack[this.stack.length - 1];
	          var fEqual = buf1.toString('hex') === buf2.toString('hex');
	          this.stack.pop();
	          this.stack.pop();
	          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);
	          if (opcodenum === Opcode.OP_EQUALVERIFY) {
	            if (fEqual) {
	              this.stack.pop();
	            } else {
	              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';
	              return false;
	            }
	          }
	        }
	        break;


	        //
	        // Numeric
	        //
	      case Opcode.OP_1ADD:
	      case Opcode.OP_1SUB:
	      case Opcode.OP_NEGATE:
	      case Opcode.OP_ABS:
	      case Opcode.OP_NOT:
	      case Opcode.OP_0NOTEQUAL:
	        {
	          // (in -- out)
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf = this.stack[this.stack.length - 1];
	          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
	          switch (opcodenum) {
	            case Opcode.OP_1ADD:
	              bn = bn.add(1);
	              break;
	            case Opcode.OP_1SUB:
	              bn = bn.sub(1);
	              break;
	            case Opcode.OP_NEGATE:
	              bn = bn.neg();
	              break;
	            case Opcode.OP_ABS:
	              if (bn.cmp(0) < 0) {
	                bn = bn.neg();
	              }
	              break;
	            case Opcode.OP_NOT:
	              bn = BN((bn.cmp(0) === 0) + 0);
	              break;
	            case Opcode.OP_0NOTEQUAL:
	              bn = BN((bn.cmp(0) !== 0) + 0);
	              break;
	              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?
	          }
	          this.stack.pop();
	          this.stack.push(bn.toScriptNumBuffer());
	        }
	        break;

	      case Opcode.OP_ADD:
	      case Opcode.OP_SUB:
	      case Opcode.OP_BOOLAND:
	      case Opcode.OP_BOOLOR:
	      case Opcode.OP_NUMEQUAL:
	      case Opcode.OP_NUMEQUALVERIFY:
	      case Opcode.OP_NUMNOTEQUAL:
	      case Opcode.OP_LESSTHAN:
	      case Opcode.OP_GREATERTHAN:
	      case Opcode.OP_LESSTHANOREQUAL:
	      case Opcode.OP_GREATERTHANOREQUAL:
	      case Opcode.OP_MIN:
	      case Opcode.OP_MAX:
	        {
	          // (x1 x2 -- out)
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
	          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
	          bn = BN(0);

	          switch (opcodenum) {
	            case Opcode.OP_ADD:
	              bn = bn1.add(bn2);
	              break;

	            case Opcode.OP_SUB:
	              bn = bn1.sub(bn2);
	              break;

	              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;
	            case Opcode.OP_BOOLAND:
	              bn = BN(((bn1.cmp(0) !== 0) && (bn2.cmp(0) !== 0)) + 0);
	              break;
	              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;
	            case Opcode.OP_BOOLOR:
	              bn = BN(((bn1.cmp(0) !== 0) || (bn2.cmp(0) !== 0)) + 0);
	              break;
	              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;
	            case Opcode.OP_NUMEQUAL:
	              bn = BN((bn1.cmp(bn2) === 0) + 0);
	              break;
	              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;
	            case Opcode.OP_NUMEQUALVERIFY:
	              bn = BN((bn1.cmp(bn2) === 0) + 0);
	              break;
	              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;
	            case Opcode.OP_NUMNOTEQUAL:
	              bn = BN((bn1.cmp(bn2) !== 0) + 0);
	              break;
	              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;
	            case Opcode.OP_LESSTHAN:
	              bn = BN((bn1.cmp(bn2) < 0) + 0);
	              break;
	              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;
	            case Opcode.OP_GREATERTHAN:
	              bn = BN((bn1.cmp(bn2) > 0) + 0);
	              break;
	              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;
	            case Opcode.OP_LESSTHANOREQUAL:
	              bn = BN((bn1.cmp(bn2) <= 0) + 0);
	              break;
	              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;
	            case Opcode.OP_GREATERTHANOREQUAL:
	              bn = BN((bn1.cmp(bn2) >= 0) + 0);
	              break;
	            case Opcode.OP_MIN:
	              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);
	              break;
	            case Opcode.OP_MAX:
	              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);
	              break;
	              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?
	          }
	          this.stack.pop();
	          this.stack.pop();
	          this.stack.push(bn.toScriptNumBuffer());

	          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {
	            // if (CastToBool(stacktop(-1)))
	            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {
	              this.stack.pop();
	            } else {
	              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';
	              return false;
	            }
	          }
	        }
	        break;

	      case Opcode.OP_WITHIN:
	        {
	          // (x min max -- out)
	          if (this.stack.length < 3) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);
	          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
	          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
	          //bool fValue = (bn2 <= bn1 && bn1 < bn3);
	          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);
	          this.stack.pop();
	          this.stack.pop();
	          this.stack.pop();
	          this.stack.push(fValue ? Interpreter.true : Interpreter.false);
	        }
	        break;


	        //
	        // Crypto
	        //
	      case Opcode.OP_RIPEMD160:
	      case Opcode.OP_SHA1:
	      case Opcode.OP_SHA256:
	      case Opcode.OP_HASH160:
	      case Opcode.OP_HASH256:
	        {
	          // (in -- hash)
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          buf = this.stack[this.stack.length - 1];
	          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||
	          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);
	          var bufHash;
	          if (opcodenum === Opcode.OP_RIPEMD160) {
	            bufHash = Hash.ripemd160(buf);
	          } else if (opcodenum === Opcode.OP_SHA1) {
	            bufHash = Hash.sha1(buf);
	          } else if (opcodenum === Opcode.OP_SHA256) {
	            bufHash = Hash.sha256(buf);
	          } else if (opcodenum === Opcode.OP_HASH160) {
	            bufHash = Hash.sha256ripemd160(buf);
	          } else if (opcodenum === Opcode.OP_HASH256) {
	            bufHash = Hash.sha256sha256(buf);
	          }
	          this.stack.pop();
	          this.stack.push(bufHash);
	        }
	        break;

	      case Opcode.OP_CODESEPARATOR:
	        {
	          // Hash starts after the code separator
	          this.pbegincodehash = this.pc;
	        }
	        break;

	      case Opcode.OP_CHECKSIG:
	      case Opcode.OP_CHECKSIGVERIFY:
	        {
	          // (sig pubkey -- bool)
	          if (this.stack.length < 2) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }

	          bufSig = this.stack[this.stack.length - 2];
	          bufPubkey = this.stack[this.stack.length - 1];

	          // Subset of script starting at the most recent codeseparator
	          // CScript scriptCode(pbegincodehash, pend);
	          subscript = new Script().set({
	            chunks: this.script.chunks.slice(this.pbegincodehash)
	          });

	          // Drop the signature, since there's no way for a signature to sign itself
	          var tmpScript = new Script().add(bufSig);
	          subscript.findAndDelete(tmpScript);

	          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
	            return false;
	          }

	          try {
	            sig = Signature.fromTxFormat(bufSig);
	            pubkey = PublicKey.fromBuffer(bufPubkey, false);
	            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript);
	          } catch (e) {
	            //invalid sig or pubkey
	            fSuccess = false;
	          }

	          this.stack.pop();
	          this.stack.pop();
	          // stack.push_back(fSuccess ? vchTrue : vchFalse);
	          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
	          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {
	            if (fSuccess) {
	              this.stack.pop();
	            } else {
	              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';
	              return false;
	            }
	          }
	        }
	        break;

	      case Opcode.OP_CHECKMULTISIG:
	      case Opcode.OP_CHECKMULTISIGVERIFY:
	        {
	          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)

	          var i = 1;
	          if (this.stack.length < i) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }

	          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();
	          if (nKeysCount < 0 || nKeysCount > 20) {
	            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';
	            return false;
	          }
	          this.nOpCount += nKeysCount;
	          if (this.nOpCount > 201) {
	            this.errstr = 'SCRIPT_ERR_OP_COUNT';
	            return false;
	          }
	          // int ikey = ++i;
	          var ikey = ++i;
	          i += nKeysCount;
	          if (this.stack.length < i) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }

	          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();
	          if (nSigsCount < 0 || nSigsCount > nKeysCount) {
	            this.errstr = 'SCRIPT_ERR_SIG_COUNT';
	            return false;
	          }
	          // int isig = ++i;
	          var isig = ++i;
	          i += nSigsCount;
	          if (this.stack.length < i) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }

	          // Subset of script starting at the most recent codeseparator
	          subscript = new Script().set({
	            chunks: this.script.chunks.slice(this.pbegincodehash)
	          });

	          // Drop the signatures, since there's no way for a signature to sign itself
	          for (var k = 0; k < nSigsCount; k++) {
	            bufSig = this.stack[this.stack.length - isig - k];
	            subscript.findAndDelete(new Script().add(bufSig));
	          }

	          fSuccess = true;
	          while (fSuccess && nSigsCount > 0) {
	            // valtype& vchSig  = stacktop(-isig);
	            bufSig = this.stack[this.stack.length - isig];
	            // valtype& vchPubKey = stacktop(-ikey);
	            bufPubkey = this.stack[this.stack.length - ikey];

	            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
	              return false;
	            }

	            var fOk;
	            try {
	              sig = Signature.fromTxFormat(bufSig);
	              pubkey = PublicKey.fromBuffer(bufPubkey, false);
	              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript);
	            } catch (e) {
	              //invalid sig or pubkey
	              fOk = false;
	            }

	            if (fOk) {
	              isig++;
	              nSigsCount--;
	            }
	            ikey++;
	            nKeysCount--;

	            // If there are more signatures left than keys left,
	            // then too many signatures have failed
	            if (nSigsCount > nKeysCount) {
	              fSuccess = false;
	            }
	          }

	          // Clean up stack of actual arguments
	          while (i-- > 1) {
	            this.stack.pop();
	          }

	          // A bug causes CHECKMULTISIG to consume one extra argument
	          // whose contents were not checked in any way.
	          //
	          // Unfortunately this is a potential source of mutability,
	          // so optionally verify it is exactly equal to zero prior
	          // to removing it from the stack.
	          if (this.stack.length < 1) {
	            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';
	            return false;
	          }
	          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {
	            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';
	            return false;
	          }
	          this.stack.pop();

	          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);

	          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {
	            if (fSuccess) {
	              this.stack.pop();
	            } else {
	              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';
	              return false;
	            }
	          }
	        }
	        break;

	      default:
	        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';
	        return false;
	    }
	  }

	  return true;
	};

	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);
	var inherits = __webpack_require__(25);
	var Input = __webpack_require__(43);
	var Output = __webpack_require__(24);
	var $ = __webpack_require__(5);

	var Script = __webpack_require__(9);
	var Signature = __webpack_require__(14);
	var Sighash = __webpack_require__(28);
	var PublicKey = __webpack_require__(13);
	var BufferUtil = __webpack_require__(3);

	/**
	 * @constructor
	 */
	function MultiSigScriptHashInput(input, pubkeys, threshold, signatures) {
	  Input.apply(this, arguments);
	  var self = this;
	  this.publicKeys = _.sortBy(pubkeys, function(publicKey) { return publicKey.toString('hex'); });
	  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold);
	  $.checkState(Script.buildScriptHashOut(this.redeemScript).equals(this.output.script),
	               'Provided public keys don\'t hash to the provided output');
	  this.publicKeyIndex = {};
	  _.each(this.publicKeys, function(publicKey, index) {
	    self.publicKeyIndex[publicKey.toString()] = index;
	  });
	  this.threshold = threshold;
	  // Empty array of signatures
	  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
	}
	inherits(MultiSigScriptHashInput, Input);

	MultiSigScriptHashInput.prototype.toObject = function() {
	  var obj = Input.prototype.toObject.apply(this, arguments);
	  obj.threshold = this.threshold;
	  obj.publicKeys = _.map(this.publicKeys, function(publicKey) { return publicKey.toString(); });
	  obj.signatures = this._serializeSignatures();
	  return obj;
	};

	MultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {
	  return _.map(signatures, function(signature) {
	    if (!signature) {
	      return undefined;
	    }
	    return {
	      publicKey: new PublicKey(signature.publicKey),
	      prevTxId: signature.txId,
	      outputIndex: signature.outputIndex,
	      inputIndex: signature.inputIndex,
	      signature: Signature.fromString(signature.signature),
	      sigtype: signature.sigtype
	    };
	  });
	};

	MultiSigScriptHashInput.prototype._serializeSignatures = function() {
	  return _.map(this.signatures, function(signature) {
	    if (!signature) {
	      return undefined;
	    }
	    return {
	      publicKey: signature.publicKey.toString(),
	      prevTxId: signature.txId,
	      outputIndex: signature.outputIndex,
	      inputIndex: signature.inputIndex,
	      signature: signature.signature.toString(),
	      sigtype: signature.sigtype
	    };
	  });
	};

	MultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype) {
	  $.checkState(this.output instanceof Output);
	  sigtype = sigtype || Signature.SIGHASH_ALL;

	  var self = this;
	  var results = [];
	  _.each(this.publicKeys, function(publicKey) {
	    if (publicKey.toString() === privateKey.publicKey.toString()) {
	      results.push({
	        publicKey: privateKey.publicKey,
	        prevTxId: self.txId,
	        outputIndex: self.outputIndex,
	        inputIndex: index,
	        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.redeemScript),
	        sigtype: sigtype
	      });
	    }
	  });
	  return results;
	};

	MultiSigScriptHashInput.prototype.addSignature = function(transaction, signature) {
	  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');
	  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),
	                  'Signature has no matching public key');
	  $.checkState(this.isValidSignature(transaction, signature));
	  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
	  this._updateScript();
	  return this;
	};

	MultiSigScriptHashInput.prototype._updateScript = function() {
	  this.setScript(Script.buildP2SHMultisigIn(
	    this.publicKeys,
	    this.threshold,
	    this._createSignatures(),
	    { cachedMultisig: this.redeemScript }
	  ));
	  return this;
	};

	MultiSigScriptHashInput.prototype._createSignatures = function() {
	  return _.map(
	    _.filter(this.signatures, function(signature) { return !_.isUndefined(signature); }),
	    function(signature) {
	      return BufferUtil.concat([
	        signature.signature.toDER(),
	        BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
	      ]);
	    }
	  );
	};

	MultiSigScriptHashInput.prototype.clearSignatures = function() {
	  this.signatures = new Array(this.publicKeys.length);
	  this._updateScript();
	};

	MultiSigScriptHashInput.prototype.isFullySigned = function() {
	  return this.countSignatures() === this.threshold;
	};

	MultiSigScriptHashInput.prototype.countMissingSignatures = function() {
	  return this.threshold - this.countSignatures();
	};

	MultiSigScriptHashInput.prototype.countSignatures = function() {
	  return _.reduce(this.signatures, function(sum, signature) {
	    return sum + (!!signature);
	  }, 0);
	};

	MultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {
	  var self = this;
	  return _.filter(this.publicKeys, function(publicKey) {
	    return !(self.signatures[self.publicKeyIndex[publicKey.toString()]]);
	  });
	};

	MultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature) {
	  // FIXME: Refactor signature so this is not necessary
	  signature.signature.nhashtype = signature.sigtype;
	  return Sighash.verify(
	      transaction,
	      signature.signature,
	      signature.publicKey,
	      signature.inputIndex,
	      this.redeemScript
	  );
	};

	MultiSigScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG
	MultiSigScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)
	MultiSigScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)

	MultiSigScriptHashInput.prototype._estimateSize = function() {
	  return MultiSigScriptHashInput.OPCODES_SIZE +
	    this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE +
	    this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;
	};

	module.exports = MultiSigScriptHashInput;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var inherits = __webpack_require__(25);

	var $ = __webpack_require__(5);
	var BufferUtil = __webpack_require__(3);

	var Hash = __webpack_require__(7);
	var Input = __webpack_require__(43);
	var Output = __webpack_require__(24);
	var Sighash = __webpack_require__(28);
	var Script = __webpack_require__(9);
	var Signature = __webpack_require__(14);

	/**
	 * Represents a special kind of input of PayToPublicKeyHash kind.
	 * @constructor
	 */
	function PublicKeyHashInput() {
	  Input.apply(this, arguments);
	}
	inherits(PublicKeyHashInput, Input);

	/* jshint maxparams: 5 */
	/**
	 * @param {Transaction} transaction - the transaction to be signed
	 * @param {PrivateKey} privateKey - the private key with which to sign the transaction
	 * @param {number} index - the index of the input in the transaction input vector
	 * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL
	 * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided
	 * @return {Array} of objects that can be
	 */
	PublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData) {
	  $.checkState(this.output instanceof Output);
	  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());
	  sigtype = sigtype || Signature.SIGHASH_ALL;

	  if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {
	    return [{
	      publicKey: privateKey.publicKey,
	      prevTxId: this.txId,
	      outputIndex: this.outputIndex,
	      inputIndex: index,
	      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),
	      sigtype: sigtype
	    }];
	  }
	  return [];
	};
	/* jshint maxparams: 3 */

	/**
	 * Add the provided signature
	 *
	 * @param {Object} signature
	 * @param {PublicKey} signature.publicKey
	 * @param {Signature} signature.signature
	 * @param {number=} signature.sigtype
	 * @return {PublicKeyHashInput} this, for chaining
	 */
	PublicKeyHashInput.prototype.addSignature = function(transaction, signature) {
	  $.checkState(this.isValidSignature(transaction, signature), 'Signature is invalid');
	  this.setScript(Script.buildPublicKeyHashIn(
	    signature.publicKey,
	    signature.signature.toDER(),
	    signature.sigtype
	  ));
	  return this;
	};

	/**
	 * Clear the input's signature
	 * @return {PublicKeyHashInput} this, for chaining
	 */
	PublicKeyHashInput.prototype.clearSignatures = function() {
	  this.setScript(Script.empty());
	  return this;
	};

	/**
	 * Query whether the input is signed
	 * @return {boolean}
	 */
	PublicKeyHashInput.prototype.isFullySigned = function() {
	  return this.script.isPublicKeyHashIn();
	};

	PublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)

	PublicKeyHashInput.prototype._estimateSize = function() {
	  return PublicKeyHashInput.SCRIPT_MAX_SIZE;
	};

	module.exports = PublicKeyHashInput;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(2);
	var URL = __webpack_require__(150);

	var Address = __webpack_require__(17);
	var Unit = __webpack_require__(44);
	var JSUtil = __webpack_require__(4);

	/**
	 * Bitcore URI
	 *
	 * Instantiate an URI from a bitcoin URI String or an Object. An URI instance
	 * can be created with a bitcoin uri string or an object. All instances of
	 * URI are valid, the static method isValid allows checking before instanciation.
	 *
	 * All standard parameters can be found as members of the class, the address
	 * is represented using an {Address} instance and the amount is represented in
	 * satoshis. Any other non-standard parameters can be found under the extra member.
	 *
	 * @example
	 * ```javascript
	 *
	 * var uri = new URI('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu?amount=1.2');
	 * console.log(uri.address, uri.amount);
	 * ```
	 *
	 * @param {string|Object} data - A bitcoin URI string or an Object
	 * @param {Array.<string>} [knownParams] - Required non-standard params
	 * @throws {TypeError} Invalid bitcoin address
	 * @throws {TypeError} Invalid amount
	 * @throws {Error} Unknown required argument
	 * @returns {URI} A new valid and frozen instance of URI
	 * @constructor
	 */
	var URI = function(data, knownParams) {
	  if (!(this instanceof URI)) {
	    return new URI(data, knownParams);
	  }

	  this.extras = {};
	  this.knownParams = knownParams || [];
	  this.address = this.network = this.amount = this.message = null;

	  if (typeof(data) === 'string') {
	    var params = URI.parse(data);
	    if (params.amount) {
	      params.amount = this._parseAmount(params.amount);
	    }
	    this._fromObject(params);
	  } else if (typeof(data) === 'object') {
	    this._fromObject(data);
	  } else {
	    throw new TypeError('Unrecognized data format.');
	  }
	};

	/**
	 * Instantiate a URI from a String
	 *
	 * @param {String} str - JSON string or object of the URI
	 * @returns {URI} A new instance of a URI
	 */
	URI.fromString = function fromString(str) {
	  if (typeof(str) !== 'string') {
	    throw new TypeError('Expected a string');
	  }
	  return new URI(str);
	};

	/**
	 * Instantiate a URI from JSON
	 *
	 * @param {String|Object} json - JSON string or object of the URI
	 * @returns {URI} A new instance of a URI
	 */
	URI.fromJSON = function fromJSON(json) {
	  if (JSUtil.isValidJSON(json)) {
	    json = JSON.parse(json);
	  }
	  return new URI(json);
	};

	/**
	 * Check if an bitcoin URI string is valid
	 *
	 * @example
	 * ```javascript
	 *
	 * var valid = URI.isValid('bitcoin:12A1MyfXbW6RhdRAZEqofac5jCQQjwEPBu');
	 * // true
	 * ```
	 *
	 * @param {string|Object} data - A bitcoin URI string or an Object
	 * @param {Array.<string>} [knownParams] - Required non-standard params
	 * @returns {boolean} Result of uri validation
	 */
	URI.isValid = function(arg, knownParams) {
	  try {
	    new URI(arg, knownParams);
	  } catch (err) {
	    return false;
	  }
	  return true;
	};

	/**
	 * Convert a bitcoin URI string into a simple object.
	 *
	 * @param {string} uri - A bitcoin URI string
	 * @throws {TypeError} Invalid bitcoin URI
	 * @returns {Object} An object with the parsed params
	 */
	URI.parse = function(uri) {
	  var info = URL.parse(uri, true);

	  if (info.protocol !== 'bitcoin:') {
	    throw new TypeError('Invalid bitcoin URI');
	  }

	  // workaround to host insensitiveness
	  var group = /[^:]*:\/?\/?([^?]*)/.exec(uri);
	  info.query.address = group && group[1] || undefined;

	  return info.query;
	};

	URI.Members = ['address', 'amount', 'message', 'label', 'r'];

	/**
	 * Internal function to load the URI instance with an object.
	 *
	 * @param {Object} obj - Object with the information
	 * @throws {TypeError} Invalid bitcoin address
	 * @throws {TypeError} Invalid amount
	 * @throws {Error} Unknown required argument
	 */
	URI.prototype._fromObject = function(obj) {
	  /* jshint maxcomplexity: 10 */

	  if (!Address.isValid(obj.address)) {
	    throw new TypeError('Invalid bitcoin address');
	  }

	  this.address = new Address(obj.address);
	  this.network = this.address.network;
	  this.amount = obj.amount;

	  for (var key in obj) {
	    if (key === 'address' || key === 'amount') {
	      continue;
	    }

	    if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {
	      throw Error('Unknown required argument ' + key);
	    }

	    var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;
	    destination[key] = obj[key];
	  }
	};

	/**
	 * Internal function to transform a BTC string amount into satoshis
	 *
	 * @param {String} amount - Amount BTC string
	 * @throws {TypeError} Invalid amount
	 * @returns {Object} Amount represented in satoshis
	 */
	URI.prototype._parseAmount = function(amount) {
	  amount = Number(amount);
	  if (isNaN(amount)) {
	    throw new TypeError('Invalid amount');
	  }
	  return Unit.fromBTC(amount).toSatoshis();
	};

	URI.prototype.toObject = function toObject() {
	  var json = {};
	  for (var i = 0; i < URI.Members.length; i++) {
	    var m = URI.Members[i];
	    if (this.hasOwnProperty(m) && typeof(this[m]) !== 'undefined') {
	      json[m] = this[m].toString();
	    }
	  }
	  _.extend(json, this.extras);
	  return json;
	};

	URI.prototype.toJSON = function toJSON() {
	  return JSON.stringify(this.toObject());
	};

	/**
	 * Will return a the string representation of the URI
	 *
	 * @returns {String} Bitcoin URI string
	 */
	URI.prototype.toString = function() {
	  var query = {};
	  if (this.amount) {
	    query.amount = Unit.fromSatoshis(this.amount).toBTC();
	  }
	  if (this.message) {
	    query.message = this.message;
	  }
	  if (this.label) {
	    query.label = this.label;
	  }
	  if (this.r) {
	    query.r = this.r;
	  }
	  _.extend(query, this.extras);

	  return URL.format({
	    protocol: 'bitcoin:',
	    host: this.address,
	    query: query
	  });
	};

	/**
	 * Will return a string formatted for the console
	 *
	 * @returns {String} Bitcoin URI
	 */
	URI.prototype.inspect = function() {
	  return '<URI: ' + this.toString() + '>';
	};

	module.exports = URI;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(8);
	var bn = __webpack_require__(10);
	var elliptic = __webpack_require__(11);

	var getNAF = elliptic.utils.getNAF;
	var getJSF = elliptic.utils.getJSF;

	function BaseCurve(type, conf) {
	  this.type = type;
	  this.p = new bn(conf.p, 16);

	  // Use Montgomery, when there is no fast reduction for the prime
	  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);

	  // Useful for many curves
	  this.zero = new bn(0).toRed(this.red);
	  this.one = new bn(1).toRed(this.red);
	  this.two = new bn(2).toRed(this.red);

	  // Curve configuration, optional
	  this.n = conf.n && new bn(conf.n, 16);
	  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

	  // Temporary arrays
	  this._wnafT1 = new Array(4);
	  this._wnafT2 = new Array(4);
	  this._wnafT3 = new Array(4);
	  this._wnafT4 = new Array(4);
	}
	module.exports = BaseCurve;

	BaseCurve.prototype.point = function point() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype.validate = function validate(point) {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
	  var doubles = p._getDoubles();

	  var naf = getNAF(k, 1);
	  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
	  I /= 3;

	  // Translate into more windowed form
	  var repr = [];
	  for (var j = 0; j < naf.length; j += doubles.step) {
	    var nafW = 0;
	    for (var k = j + doubles.step - 1; k >= j; k--)
	      nafW = (nafW << 1) + naf[k];
	    repr.push(nafW);
	  }

	  var a = this.jpoint(null, null, null);
	  var b = this.jpoint(null, null, null);
	  for (var i = I; i > 0; i--) {
	    for (var j = 0; j < repr.length; j++) {
	      var nafW = repr[j];
	      if (nafW === i)
	        b = b.mixedAdd(doubles.points[j]);
	      else if (nafW === -i)
	        b = b.mixedAdd(doubles.points[j].neg());
	    }
	    a = a.add(b);
	  }
	  return a.toP();
	};

	BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
	  var w = 4;

	  // Precompute window
	  var nafPoints = p._getNAFPoints(w);
	  w = nafPoints.wnd;
	  var wnd = nafPoints.points;

	  // Get NAF form
	  var naf = getNAF(k, w);

	  // Add `this`*(N+1) for every w-NAF index
	  var acc = this.jpoint(null, null, null);
	  for (var i = naf.length - 1; i >= 0; i--) {
	    // Count zeroes
	    for (var k = 0; i >= 0 && naf[i] === 0; i--)
	      k++;
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);

	    if (i < 0)
	      break;
	    var z = naf[i];
	    assert(z !== 0);
	    if (p.type === 'affine') {
	      // J +- P
	      if (z > 0)
	        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
	    } else {
	      // J +- J
	      if (z > 0)
	        acc = acc.add(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.add(wnd[(-z - 1) >> 1].neg());
	    }
	  }
	  return p.type === 'affine' ? acc.toP() : acc;
	};

	BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
	                                                       points,
	                                                       coeffs,
	                                                       len) {
	  var wndWidth = this._wnafT1;
	  var wnd = this._wnafT2;
	  var naf = this._wnafT3;

	  // Fill all arrays
	  var max = 0;
	  for (var i = 0; i < len; i++) {
	    var p = points[i];
	    var nafPoints = p._getNAFPoints(defW);
	    wndWidth[i] = nafPoints.wnd;
	    wnd[i] = nafPoints.points;
	  }

	  // Comb small window NAFs
	  for (var i = len - 1; i >= 1; i -= 2) {
	    var a = i - 1;
	    var b = i;
	    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
	      naf[a] = getNAF(coeffs[a], wndWidth[a]);
	      naf[b] = getNAF(coeffs[b], wndWidth[b]);
	      max = Math.max(naf[a].length, max);
	      max = Math.max(naf[b].length, max);
	      continue;
	    }

	    var comb = [
	      points[a], /* 1 */
	      null, /* 3 */
	      null, /* 5 */
	      points[b] /* 7 */
	    ];

	    // Try to avoid Projective points, if possible
	    if (points[a].y.cmp(points[b].y) === 0) {
	      comb[1] = points[a].add(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].add(points[b].neg());
	    } else {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    }

	    var index = [
	      -3, /* -1 -1 */
	      -1, /* -1 0 */
	      -5, /* -1 1 */
	      -7, /* 0 -1 */
	      0, /* 0 0 */
	      7, /* 0 1 */
	      5, /* 1 -1 */
	      1, /* 1 0 */
	      3  /* 1 1 */
	    ];

	    var jsf = getJSF(coeffs[a], coeffs[b]);
	    max = Math.max(jsf[0].length, max);
	    naf[a] = new Array(max);
	    naf[b] = new Array(max);
	    for (var j = 0; j < max; j++) {
	      var ja = jsf[0][j] | 0;
	      var jb = jsf[1][j] | 0;

	      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
	      naf[b][j] = 0;
	      wnd[a] = comb;
	    }
	  }

	  var acc = this.jpoint(null, null, null);
	  var tmp = this._wnafT4;
	  for (var i = max; i >= 0; i--) {
	    var k = 0;

	    while (i >= 0) {
	      var zero = true;
	      for (var j = 0; j < len; j++) {
	        tmp[j] = naf[j][i] | 0;
	        if (tmp[j] !== 0)
	          zero = false;
	      }
	      if (!zero)
	        break;
	      k++;
	      i--;
	    }
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);
	    if (i < 0)
	      break;

	    for (var j = 0; j < len; j++) {
	      var z = tmp[j];
	      var p;
	      if (z === 0)
	        continue;
	      else if (z > 0)
	        p = wnd[j][(z - 1) >> 1];
	      else if (z < 0)
	        p = wnd[j][(-z - 1) >> 1].neg();

	      if (p.type === 'affine')
	        acc = acc.mixedAdd(p);
	      else
	        acc = acc.add(p);
	    }
	  }
	  // Zeroify references
	  for (var i = 0; i < len; i++)
	    wnd[i] = null;
	  return acc.toP();
	};

	BaseCurve.BasePoint = BasePoint;

	function BasePoint(curve, type) {
	  this.curve = curve;
	  this.type = type;
	  this.precomputed = null;
	}

	BasePoint.prototype.validate = function validate() {
	  return this.curve.validate(this);
	};

	BasePoint.prototype.precompute = function precompute(power, _beta) {
	  if (this.precomputed)
	    return this;

	  var precomputed = {
	    doubles: null,
	    naf: null,
	    beta: null
	  };
	  precomputed.naf = this._getNAFPoints(8);
	  precomputed.doubles = this._getDoubles(4, power);
	  precomputed.beta = this._getBeta();
	  this.precomputed = precomputed;

	  return this;
	};

	BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
	  if (this.precomputed && this.precomputed.doubles)
	    return this.precomputed.doubles;

	  var doubles = [ this ];
	  var acc = this;
	  for (var i = 0; i < power; i += step) {
	    for (var j = 0; j < step; j++)
	      acc = acc.dbl();
	    doubles.push(acc);
	  }
	  return {
	    step: step,
	    points: doubles
	  };
	};

	BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
	  if (this.precomputed && this.precomputed.naf)
	    return this.precomputed.naf;

	  var res = [ this ];
	  var max = (1 << wnd) - 1;
	  var dbl = max === 1 ? null : this.dbl();
	  for (var i = 1; i < max; i++)
	    res[i] = res[i - 1].add(dbl);
	  return {
	    wnd: wnd,
	    points: res
	  };
	};

	BasePoint.prototype._getBeta = function _getBeta() {
	  return null;
	};

	BasePoint.prototype.dblp = function dblp(k) {
	  var r = this;
	  for (var i = 0; i < k; i++)
	    r = r.dbl();
	  return r;
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(8);
	var curve = __webpack_require__(36);
	var elliptic = __webpack_require__(11);
	var bn = __webpack_require__(10);
	var inherits = __webpack_require__(25);
	var Base = curve.base;

	var getNAF = elliptic.utils.getNAF;

	function EdwardsCurve(conf) {
	  // NOTE: Important as we are creating point in Base.call()
	  this.twisted = conf.a != 1;
	  this.mOneA = this.twisted && conf.a == -1;
	  this.extended = this.mOneA;

	  Base.call(this, 'mont', conf);

	  this.a = new bn(conf.a, 16).mod(this.red.m).toRed(this.red);
	  this.c = new bn(conf.c, 16).toRed(this.red);
	  this.c2 = this.c.redSqr();
	  this.d = new bn(conf.d, 16).toRed(this.red);
	  this.dd = this.d.redAdd(this.d);

	  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
	  this.oneC = conf.c == 1;
	}
	inherits(EdwardsCurve, Base);
	module.exports = EdwardsCurve;

	EdwardsCurve.prototype._mulA = function _mulA(num) {
	  if (this.mOneA)
	    return num.redNeg();
	  else
	    return this.a.redMul(num);
	};

	EdwardsCurve.prototype._mulC = function _mulC(num) {
	  if (this.oneC)
	    return num;
	  else
	    return this.c.redMul(num);
	};

	EdwardsCurve.prototype.point = function point(x, y, z, t) {
	  return new Point(this, x, y, z, t);
	};

	// Just for compatibility with Short curve
	EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
	  return this.point(x, y, z, t);
	};

	EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	EdwardsCurve.prototype.pointFromX = function pointFromX(odd, x) {
	  x = new bn(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var x2 = x.redSqr();
	  var rhs = this.c2.redSub(this.a.redMul(x2));
	  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

	  var y = rhs.redMul(lhs.redInvm()).redSqrt();
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y, curve.one);
	};

	EdwardsCurve.prototype.validate = function validate(point) {
	  if (point.isInfinity())
	    return true;

	  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
	  point.normalize();

	  var x2 = point.x.redSqr();
	  var y2 = point.y.redSqr();
	  var lhs = x2.redMul(this.a).redAdd(y2);
	  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

	  return lhs.cmp(rhs) === 0;
	};

	function Point(curve, x, y, z, t) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;
	  } else {
	    this.x = new bn(x, 16);
	    this.y = new bn(y, 16);
	    this.z = z ? new bn(z, 16) : this.curve.one;
	    this.t = t && new bn(t, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	    if (this.t && !this.t.red)
	      this.t = this.t.toRed(this.curve.red);
	    this.zOne = this.z === this.curve.one;

	    // Use extended coordinates
	    if (this.curve.extended && !this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne)
	        this.t = this.t.redMul(this.z.redInvm());
	    }
	  }
	}
	inherits(Point, Base.BasePoint);

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1], obj[2]);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.x.cmpn(0) === 0 &&
	         this.y.cmp(this.z) === 0;
	};

	Point.prototype._extDbl = function _extDbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#doubling-dbl-2008-hwcd
	  // 4M + 4S

	  // A = X1^2
	  var a = this.x.redSqr();
	  // B = Y1^2
	  var b = this.y.redSqr();
	  // C = 2 * Z1^2
	  var c = this.z.redSqr();
	  c = c.redIAdd(c);
	  // D = a * A
	  var d = this.curve._mulA(a);
	  // E = (X1 + Y1)^2 - A - B
	  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
	  // G = D + B
	  var g = d.redAdd(b);
	  // F = G - C
	  var f = g.redSub(c);
	  // H = D - B
	  var h = d.redSub(b);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projDbl = function _projDbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-twisted-projective.html#doubling-dbl-2008-bbjlp
	  // http://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#doubling-dbl-2007-bl
	  // and others
	  // Generally 3M + 4S or 2M + 4S

	  // B = (X1 + Y1)^2
	  var b = this.x.redAdd(this.y).redSqr();
	  // C = X1^2
	  var c = this.x.redSqr();
	  // D = Y1^2
	  var d = this.y.redSqr();

	  if (this.curve.twisted) {
	    // E = a * C
	    var e = this.curve._mulA(c);
	    // F = E + D
	    var f = e.redAdd(d);
	    if (this.zOne) {
	      // X3 = (B - C - D) * (F - 2)
	      var nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
	      // Y3 = F * (E - D)
	      var ny = f.redMul(e.redSub(d));
	      // Z3 = F^2 - 2 * F
	      var nz = f.redSqr().redSub(f).redSub(f);
	    } else {
	      // H = Z1^2
	      var h = this.z.redSqr();
	      // J = F - 2 * H
	      var j = f.redSub(h).redISub(h);
	      // X3 = (B-C-D)*J
	      var nx = b.redSub(c).redISub(d).redMul(j);
	      // Y3 = F * (E - D)
	      var ny = f.redMul(e.redSub(d));
	      // Z3 = F * J
	      var nz = f.redMul(j);
	    }
	  } else {
	    // E = C + D
	    var e = c.redAdd(d);
	    // H = (c * Z1)^2
	    var h = this.curve._mulC(redMul(this.z)).redSqr();
	    // J = E - 2 * H
	    var j = e.redSub(h).redSub(h);
	    // X3 = c * (B - E) * J
	    var nx = this.curve._mulC(b.redISub(e)).redMul(j);
	    // Y3 = c * E * (C - D)
	    var ny = this.curve._mulC(e).redMul(c.redISub(d));
	    // Z3 = E * J
	    var nz = e.redMul(j);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  // Double in extended coordinates
	  if (this.curve.extended)
	    return this._extDbl();
	  else
	    return this._projDbl();
	};

	Point.prototype._extAdd = function _extAdd(p) {
	  // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3
	  // 8M

	  // A = (Y1 - X1) * (Y2 - X2)
	  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
	  // B = (Y1 + X1) * (Y2 + X2)
	  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
	  // C = T1 * k * T2
	  var c = this.t.redMul(this.curve.dd).redMul(p.t);
	  // D = Z1 * 2 * Z2
	  var d = this.z.redMul(p.z.redAdd(p.z));
	  // E = B - A
	  var e = b.redSub(a);
	  // F = D - C
	  var f = d.redSub(c);
	  // G = D + C
	  var g = d.redAdd(c);
	  // H = B + A
	  var h = b.redAdd(a);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projAdd = function _projAdd(p) {
	  // http://hyperelliptic.org/EFD/g1p/auto-twisted-projective.html#addition-add-2008-bbjlp
	  // http://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#addition-add-2007-bl
	  // 10M + 1S

	  // A = Z1 * Z2
	  var a = this.z.redMul(p.z);
	  // B = A^2
	  var b = a.redSqr();
	  // C = X1 * X2
	  var c = this.x.redMul(p.x);
	  // D = Y1 * Y2
	  var d = this.y.redMul(p.y);
	  // E = d * C * D
	  var e = this.curve.d.redMul(c).redMul(d);
	  // F = B - E
	  var f = b.redSub(e);
	  // G = B + E
	  var g = b.redAdd(e);
	  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
	  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
	  var nx = a.redMul(f).redMul(tmp);
	  if (this.curve.twisted) {
	    // Y3 = A * G * (D - a * C)
	    var ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
	    // Z3 = F * G
	    var nz = f.redMul(g);
	  } else {
	    // Y3 = A * G * (D - C)
	    var ny = a.redMul(g).redMul(d.redSub(c));
	    // Z3 = c * F * G
	    var nz = this.curve._mulC(f).redMul(g);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.add = function add(p) {
	  if (this.isInfinity())
	    return p;
	  if (p.isInfinity())
	    return this;

	  if (this.curve.extended)
	    return this._extAdd(p);
	  else
	    return this._projAdd(p);
	};

	Point.prototype.mul = function mul(k) {
	  if (this.precomputed && this.precomputed.doubles)
	    return this.curve._fixedNafMul(this, k);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);
	};

	Point.prototype.normalize = function normalize() {
	  if (this.zOne)
	    return this;

	  // Normalize coordinates
	  var zi = this.z.redInvm();
	  this.x = this.x.redMul(zi);
	  this.y = this.y.redMul(zi);
	  if (this.t)
	    this.t = this.t.redMul(zi);
	  this.z = this.curve.one;
	  this.zOne = true;
	  return this;
	};

	Point.prototype.neg = function neg() {
	  return this.curve.point(this.x.redNeg(),
	                          this.y,
	                          this.z,
	                          this.t && this.t.redNeg());
	};

	Point.prototype.getX = function getX() {
	  this.normalize();
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  this.normalize();
	  return this.y.fromRed();
	};

	// Compatibility with BaseCurve
	Point.prototype.toP = Point.prototype.normalize;
	Point.prototype.mixedAdd = Point.prototype.add;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(8);
	var curve = __webpack_require__(36);
	var elliptic = __webpack_require__(11);
	var bn = __webpack_require__(10);
	var inherits = __webpack_require__(25);
	var Base = curve.base;

	var getNAF = elliptic.utils.getNAF;

	function MontCurve(conf) {
	  Base.call(this, 'mont', conf);

	  this.a = new bn(conf.a, 16).toRed(this.red);
	  this.b = new bn(conf.b, 16).toRed(this.red);
	  this.i4 = new bn(4).toRed(this.red).redInvm();
	  this.two = new bn(2).toRed(this.red);
	  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
	}
	inherits(MontCurve, Base);
	module.exports = MontCurve;

	MontCurve.prototype.point = function point(x, z) {
	  return new Point(this, x, z);
	};

	MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	}

	MontCurve.prototype.validate = function validate(point) {
	  var x = point.normalize().x;
	  var x2 = x.redSqr();
	  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
	  var y = rhs.redSqrt();

	  return y.redSqr().cmp(rhs) === 0;
	};

	function Point(curve, x, z) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && z === null) {
	    this.x = this.curve.one;
	    this.z = this.curve.zero;
	  } else {
	    this.x = new bn(x, 16);
	    this.z = new bn(z, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	  }
	}
	inherits(Point, Base.BasePoint);

	Point.prototype.precompute = function precompute() {
	  // No-op
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1] || curve.one);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	Point.prototype.dbl = function dbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	  // 2M + 2S + 4A

	  // A = X1 + Z1
	  var a = this.x.redAdd(this.z);
	  // AA = A^2
	  var aa = a.redSqr();
	  // B = X1 - Z1
	  var b = this.x.redSub(this.z);
	  // BB = B^2
	  var bb = b.redSqr();
	  // C = AA - BB
	  var c = aa.redSub(bb);
	  // X3 = AA * BB
	  var nx = aa.redMul(bb);
	  // Z3 = C * (BB + A24 * C)
	  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
	  return this.curve.point(nx, nz);
	};

	Point.prototype.add = function add(p) {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.diffAdd = function diffAdd(p, diff) {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
	  // 4M + 2S + 6A

	  // A = X2 + Z2
	  var a = this.x.redAdd(this.z);
	  // B = X2 - Z2
	  var b = this.x.redSub(this.z);
	  // C = X3 + Z3
	  var c = p.x.redAdd(p.z);
	  // D = X3 - Z3
	  var d = p.x.redSub(p.z);
	  // DA = D * A
	  var da = d.redMul(a);
	  // CB = C * B
	  var cb = c.redMul(b);
	  // X5 = Z1 * (DA + CB)^2
	  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
	  // Z5 = X1 * (DA - CB)^2
	  var nz = diff.x.redMul(da.redISub(cb).redSqr());
	  return this.curve.point(nx, nz);
	};

	Point.prototype.mul = function mul(k) {
	  var t = k.clone();
	  var a = this; // (N / 2) * Q + Q
	  var b = this.curve.point(null, null); // (N / 2) * Q
	  var c = this; // Q

	  for (var bits = []; t.cmpn(0) !== 0; t.ishrn(1))
	    bits.push(t.andln(1));

	  for (var i = bits.length - 1; i >= 0; i--) {
	    if (bits[i] === 0) {
	      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
	      a = a.diffAdd(b, c);
	      // N * Q = 2 * ((N / 2) * Q + Q))
	      b = b.dbl();
	    } else {
	      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
	      b = a.diffAdd(b, c);
	      // N * Q + Q = 2 * ((N / 2) * Q + Q)
	      a = a.dbl();
	    }
	  }
	  return b;
	};

	Point.prototype.mulAdd = function mulAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.normalize = function normalize() {
	  this.x = this.x.redMul(this.z.redInvm());
	  this.z = this.curve.one;
	  return this;
	};

	Point.prototype.getX = function getX() {
	  // Normalize coordinates
	  this.normalize();

	  return this.x.fromRed();
	};


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(8);
	var curve = __webpack_require__(36);
	var elliptic = __webpack_require__(11);
	var bn = __webpack_require__(10);
	var inherits = __webpack_require__(25);
	var Base = curve.base;

	var getNAF = elliptic.utils.getNAF;

	function ShortCurve(conf) {
	  Base.call(this, 'short', conf);

	  this.a = new bn(conf.a, 16).toRed(this.red);
	  this.b = new bn(conf.b, 16).toRed(this.red);
	  this.tinv = this.two.redInvm();

	  this.zeroA = this.a.fromRed().cmpn(0) === 0;
	  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

	  // If the curve is endomorphic, precalculate beta and lambda
	  this.endo = this._getEndomorphism(conf);
	  this._endoWnafT1 = new Array(4);
	  this._endoWnafT2 = new Array(4);
	}
	inherits(ShortCurve, Base);
	module.exports = ShortCurve;

	ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
	  // No efficient endomorphism
	  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
	    return;

	  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
	  var beta;
	  var lambda;
	  if (conf.beta) {
	    beta = new bn(conf.beta, 16).toRed(this.red);
	  } else {
	    var betas = this._getEndoRoots(this.p);
	    // Choose the smallest beta
	    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
	    beta = beta.toRed(this.red);
	  }
	  if (conf.lambda) {
	    lambda = new bn(conf.lambda, 16);
	  } else {
	    // Choose the lambda that is matching selected beta
	    var lambdas = this._getEndoRoots(this.n);
	    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
	      lambda = lambdas[0];
	    } else {
	      lambda = lambdas[1];
	      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
	    }
	  }

	  // Get basis vectors, used for balanced length-two representation
	  var basis;
	  if (conf.basis) {
	    basis = conf.basis.map(function(vec) {
	      return {
	        a: new bn(vec.a, 16),
	        b: new bn(vec.b, 16),
	      };
	    });
	  } else {
	    basis = this._getEndoBasis(lambda);
	  }

	  return {
	    beta: beta,
	    lambda: lambda,
	    basis: basis
	  };
	};

	ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
	  // Find roots of for x^2 + x + 1 in F
	  // Root = (-1 +- Sqrt(-3)) / 2
	  //
	  var red = num === this.p ? this.red : bn.mont(num);
	  var tinv = new bn(2).toRed(red).redInvm();
	  var ntinv = tinv.redNeg();
	  var one = new bn(1).toRed(red);

	  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);

	  var l1 = ntinv.redAdd(s).fromRed();
	  var l2 = ntinv.redSub(s).fromRed();
	  return [ l1, l2 ];
	};

	ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
	  // aprxSqrt >= sqrt(this.n)
	  var aprxSqrt = this.n.shrn(Math.floor(this.n.bitLength() / 2));

	  // 3.74
	  // Run EGCD, until r(L + 1) < aprxSqrt
	  var u = lambda;
	  var v = this.n.clone();
	  var x1 = new bn(1);
	  var y1 = new bn(0);
	  var x2 = new bn(0);
	  var y2 = new bn(1);

	  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
	  var a0;
	  var b0;
	  // First vector
	  var a1;
	  var b1;
	  // Second vector
	  var a2;
	  var b2;

	  var prevR;
	  var i = 0;
	  while (u.cmpn(0) !== 0) {
	    var q = v.div(u);
	    var r = v.sub(q.mul(u));
	    var x = x2.sub(q.mul(x1));
	    var y = y2.sub(q.mul(y1));

	    if (!a1 && r.cmp(aprxSqrt) < 0) {
	      a0 = prevR.neg();
	      b0 = x1;
	      a1 = r.neg();
	      b1 = x;
	    } else if (a1 && ++i === 2) {
	      break;
	    }
	    prevR = r;

	    v = u;
	    u = r;
	    x2 = x1;
	    x1 = x;
	    y2 = y1;
	    y1 = y;
	  }
	  a2 = r.neg();
	  b2 = x;

	  var len1 = a1.sqr().add(b1.sqr());
	  var len2 = a2.sqr().add(b2.sqr());
	  if (len2.cmp(len1) >= 0) {
	    a2 = a0;
	    b2 = b0;
	  }

	  // Normalize signs
	  if (a1.sign) {
	    a1 = a1.neg();
	    b1 = b1.neg();
	  }
	  if (a2.sign) {
	    a2 = a2.neg();
	    b2 = b2.neg();
	  }

	  return [
	    { a: a1, b: b1 },
	    { a: a2, b: b2 }
	  ];
	};

	ShortCurve.prototype._endoSplit = function _endoSplit(k) {
	  var basis = this.endo.basis;
	  var v1 = basis[0];
	  var v2 = basis[1];

	  var c1 = v2.b.mul(k).divRound(this.n);
	  var c2 = v1.b.neg().mul(k).divRound(this.n);

	  var p1 = c1.mul(v1.a);
	  var p2 = c2.mul(v2.a);
	  var q1 = c1.mul(v1.b);
	  var q2 = c2.mul(v2.b);

	  // Calculate answer
	  var k1 = k.sub(p1).sub(p2);
	  var k2 = q1.add(q2).neg();
	  return { k1: k1, k2: k2 };
	};

	ShortCurve.prototype.point = function point(x, y, isRed) {
	  return new Point(this, x, y, isRed);
	};

	ShortCurve.prototype.pointFromX = function pointFromX(odd, x) {
	  x = new bn(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
	  var y = y2.redSqrt();

	  // XXX Is there any way to tell if the number is odd without converting it
	  // to non-red form?
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
	  return new JPoint(this, x, y, z);
	};

	ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
	  return Point.fromJSON(this, obj, red);
	};

	ShortCurve.prototype.validate = function validate(point) {
	  if (point.inf)
	    return true;

	  var x = point.x;
	  var y = point.y;

	  var ax = this.a.redMul(x);
	  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
	  return y.redSqr().redISub(rhs).cmpn(0) === 0;
	};

	ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs) {
	  var npoints = this._endoWnafT1;
	  var ncoeffs = this._endoWnafT2;
	  for (var i = 0; i < points.length; i++) {
	    var split = this._endoSplit(coeffs[i]);
	    var p = points[i];
	    var beta = p._getBeta();

	    if (split.k1.sign) {
	      split.k1.sign = !split.k1.sign;
	      p = p.neg(true);
	    }
	    if (split.k2.sign) {
	      split.k2.sign = !split.k2.sign;
	      beta = beta.neg(true);
	    }

	    npoints[i * 2] = p;
	    npoints[i * 2 + 1] = beta;
	    ncoeffs[i * 2] = split.k1;
	    ncoeffs[i * 2 + 1] = split.k2;
	  }
	  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);

	  // Clean-up references to points and coefficients
	  for (var j = 0; j < i * 2; j++) {
	    npoints[j] = null;
	    ncoeffs[j] = null;
	  }
	  return res;
	};

	function Point(curve, x, y, isRed) {
	  Base.BasePoint.call(this, curve, 'affine');
	  if (x === null && y === null) {
	    this.x = null;
	    this.y = null;
	    this.inf = true;
	  } else {
	    this.x = new bn(x, 16);
	    this.y = new bn(y, 16);
	    // Force redgomery representation when loading from JSON
	    if (isRed) {
	      this.x.forceRed(this.curve.red);
	      this.y.forceRed(this.curve.red);
	    }
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	}
	inherits(Point, Base.BasePoint);

	Point.prototype._getBeta = function _getBeta() {
	  if (!this.curve.endo)
	    return;

	  var pre = this.precomputed;
	  if (pre && pre.beta)
	    return pre.beta;

	  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
	  if (pre) {
	    var curve = this.curve;
	    function endoMul(p) {
	      return curve.point(p.x.redMul(curve.endo.beta), p.y);
	    }
	    pre.beta = beta;
	    beta.precomputed = {
	      beta: null,
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(endoMul)
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(endoMul)
	      }
	    };
	  }
	  return beta;
	};

	Point.prototype.toJSON = function toJSON() {
	  if (!this.precomputed)
	    return [ this.x, this.y ];

	  return [ this.x, this.y, this.precomputed && {
	    doubles: this.precomputed.doubles && {
	      step: this.precomputed.doubles.step,
	      points: this.precomputed.doubles.points.slice(1)
	    },
	    naf: this.precomputed.naf && {
	      wnd: this.precomputed.naf.wnd,
	      points: this.precomputed.naf.points.slice(1)
	    }
	  }];
	};

	Point.fromJSON = function fromJSON(curve, obj, red) {
	  if (typeof obj === 'string')
	    obj = JSON.parse(obj);
	  var res = curve.point(obj[0], obj[1], red);
	  if (!obj[2])
	    return res;

	  function obj2point(obj) {
	    return curve.point(obj[0], obj[1], red);
	  }

	  var pre = obj[2];
	  res.precomputed = {
	    beta: null,
	    doubles: pre.doubles && {
	      step: pre.doubles.step,
	      points: [ res ].concat(pre.doubles.points.map(obj2point))
	    },
	    naf: pre.naf && {
	      wnd: pre.naf.wnd,
	      points: [ res ].concat(pre.naf.points.map(obj2point))
	    }
	  };
	  return res;
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16 ,2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  return this.inf;
	};

	Point.prototype.add = function add(p) {
	  // O + P = P
	  if (this.inf)
	    return p;

	  // P + O = P
	  if (p.inf)
	    return this;

	  // P + P = 2P
	  if (this.eq(p))
	    return this.dbl();

	  // P + (-P) = O
	  if (this.neg().eq(p))
	    return this.curve.point(null, null);

	  // P + Q = O
	  if (this.x.cmp(p.x) === 0)
	    return this.curve.point(null, null);

	  var c = this.y.redSub(p.y);
	  if (c.cmpn(0) !== 0)
	    c = c.redMul(this.x.redSub(p.x).redInvm());
	  var nx = c.redSqr().redISub(this.x).redISub(p.x);
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.inf)
	    return this;

	  // 2P = O
	  var ys1 = this.y.redAdd(this.y);
	  if (ys1.cmpn(0) === 0)
	    return this.curve.point(null, null);

	  var a = this.curve.a;

	  var x2 = this.x.redSqr();
	  var dyinv = ys1.redInvm();
	  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

	  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.getX = function getX() {
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  return this.y.fromRed();
	};

	Point.prototype.mul = function mul(k) {
	  k = new bn(k, 16);

	  if (this.precomputed && this.precomputed.doubles)
	    return this.curve._fixedNafMul(this, k);
	  else if (this.curve.endo)
	    return this.curve._endoWnafMulAdd([ this ], [ k ]);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2);
	};

	Point.prototype.eq = function eq(p) {
	  return this === p ||
	         this.inf === p.inf &&
	             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
	};

	Point.prototype.neg = function neg(_precompute) {
	  if (this.inf)
	    return this;

	  var res = this.curve.point(this.x, this.y.redNeg());
	  if (_precompute && this.precomputed) {
	    var pre = this.precomputed;
	    function negate(p) {
	      return p.neg();
	    }
	    res.precomputed = {
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(negate)
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(negate)
	      }
	    };
	  }
	  return res;
	};

	Point.prototype.toJ = function toJ() {
	  if (this.inf)
	    return this.curve.jpoint(null, null, null);

	  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
	  return res;
	};

	function JPoint(curve, x, y, z) {
	  Base.BasePoint.call(this, curve, 'jacobian');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = new bn(0);
	  } else {
	    this.x = new bn(x, 16);
	    this.y = new bn(y, 16);
	    this.z = new bn(z, 16);
	  }
	  if (!this.x.red)
	    this.x = this.x.toRed(this.curve.red);
	  if (!this.y.red)
	    this.y = this.y.toRed(this.curve.red);
	  if (!this.z.red)
	    this.z = this.z.toRed(this.curve.red);

	  this.zOne = this.z === this.curve.one;
	}
	inherits(JPoint, Base.BasePoint);

	JPoint.prototype.toP = function toP() {
	  if (this.isInfinity())
	    return this.curve.point(null, null);

	  var zinv = this.z.redInvm();
	  var zinv2 = zinv.redSqr();
	  var ax = this.x.redMul(zinv2);
	  var ay = this.y.redMul(zinv2).redMul(zinv);

	  return this.curve.point(ax, ay);
	};

	JPoint.prototype.neg = function neg() {
	  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	};

	JPoint.prototype.add = function add(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p;

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 12M + 4S + 7A
	  var pz2 = p.z.redSqr();
	  var z2 = this.z.redSqr();
	  var u1 = this.x.redMul(pz2);
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y.redMul(pz2.redMul(p.z));
	  var s2 = p.y.redMul(z2.redMul(this.z));

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(p.z).redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mixedAdd = function mixedAdd(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p.toJ();

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 8M + 3S + 7A
	  var z2 = this.z.redSqr();
	  var u1 = this.x;
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y;
	  var s2 = p.y.redMul(z2).redMul(this.z);

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.dblp = function dblp(pow) {
	  if (pow === 0)
	    return this;
	  if (this.isInfinity())
	    return this;
	  if (!pow)
	    return this.dbl();

	  if (this.curve.zeroA || this.curve.threeA) {
	    var r = this;
	    for (var i = 0; i < pow; i++)
	      r = r.dbl();
	    return r;
	  }

	  // 1M + 2S + 1A + N * (4S + 5M + 8A)
	  // N = 1 => 6M + 6S + 9A
	  var a = this.curve.a;
	  var tinv = this.curve.tinv;

	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  // Reuse results
	  var jyd = jy.redAdd(jy);
	  for (var i = 0; i < pow; i++) {
	    var jx2 = jx.redSqr();
	    var jyd2 = jyd.redSqr();
	    var jyd4 = jyd2.redSqr();
	    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	    var t1 = jx.redMul(jyd2);
	    var nx = c.redSqr().redISub(t1.redAdd(t1));
	    var t2 = t1.redISub(nx);
	    var dny = c.redMul(t2);
	    dny = dny.redIAdd(dny).redISub(jyd4);
	    var nz = jyd.redMul(jz);
	    if (i + 1 < pow)
	      jz4 = jz4.redMul(jyd4);

	    jx = nx;
	    jz = nz;
	    jyd = dny;
	  }

	  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
	};

	JPoint.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  if (this.curve.zeroA)
	    return this._zeroDbl();
	  else if (this.curve.threeA)
	    return this._threeDbl();
	  else
	    return this._dbl();
	};

	JPoint.prototype._zeroDbl = function _zeroDbl() {
	  // Z = 1
	  if (this.zOne) {
	    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-mdbl-2007-bl
	    // 1M + 5S + 14A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a; a = 0
	    var m = xx.redAdd(xx).redIAdd(xx);
	    // T = M ^ 2 - 2*S
	    var t = m.redSqr().redISub(s).redISub(s);

	    // 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);

	    // X3 = T
	    var nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    var ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2*Y1
	    var nz = this.y.redAdd(this.y);
	  } else {
	    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
	    // 2M + 5S + 13A

	    // A = X1^2
	    var a = this.x.redSqr();
	    // B = Y1^2
	    var b = this.y.redSqr();
	    // C = B^2
	    var c = b.redSqr();
	    // D = 2 * ((X1 + B)^2 - A - C)
	    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
	    d = d.redIAdd(d);
	    // E = 3 * A
	    var e = a.redAdd(a).redIAdd(a);
	    // F = E^2
	    var f = e.redSqr();

	    // 8 * C
	    var c8 = c.redIAdd(c);
	    c8 = c8.redIAdd(c8);
	    c8 = c8.redIAdd(c8);

	    // X3 = F - 2 * D
	    var nx = f.redISub(d).redISub(d);
	    // Y3 = E * (D - X3) - 8 * C
	    var ny = e.redMul(d.redISub(nx)).redISub(c8);
	    // Z3 = 2 * Y1 * Z1
	    var nz = this.y.redMul(this.z);
	    nz = nz.redIAdd(nz);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._threeDbl = function _threeDbl() {
	  // Z = 1
	  if (this.zOne) {
	    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-mdbl-2007-bl
	    // 1M + 5S + 15A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a
	    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
	    // T = M^2 - 2 * S
	    var t = m.redSqr().redISub(s).redISub(s);
	    // X3 = T
	    var nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    var ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2 * Y1
	    var nz = this.y.redAdd(this.y);
	  } else {
	    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S

	    // delta = Z1^2
	    var delta = this.z.redSqr();
	    // gamma = Y1^2
	    var gamma = this.y.redSqr();
	    // beta = X1 * gamma
	    var beta = this.x.redMul(gamma);
	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
	    alpha = alpha.redAdd(alpha).redIAdd(alpha);
	    // X3 = alpha^2 - 8 * beta
	    var beta4 = beta.redIAdd(beta);
	    beta4 = beta4.redIAdd(beta4);
	    var beta8 = beta4.redAdd(beta4);
	    var nx = alpha.redSqr().redISub(beta8);
	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    var nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    var ggamma8 = gamma.redSqr();
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    var ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._dbl = function _dbl() {
	  var a = this.curve.a;
	  var tinv = this.curve.tinv;

	  // 4M + 6S + 10A
	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  var jx2 = jx.redSqr();
	  var jy2 = jy.redSqr();

	  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	  var jxd4 = jx.redAdd(jx);
	  jxd4 = jxd4.redIAdd(jxd4);
	  var t1 = jxd4.redMul(jy2);
	  var nx = c.redSqr().redISub(t1.redAdd(t1));
	  var t2 = t1.redISub(nx);

	  var jyd8 = jy2.redSqr();
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  var ny = c.redMul(t2).redISub(jyd8);
	  var nz = jy.redAdd(jy).redMul(jz);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.trpl = function trpl() {
	  if (!this.curve.zeroA)
	    return this.dbl().add(this);

	  // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
	  // 5M + 10S + ...

	  // XX = X1^2
	  var xx = this.x.redSqr();
	  // YY = Y1^2
	  var yy = this.y.redSqr();
	  // ZZ = Z1^2
	  var zz = this.z.redSqr();
	  // YYYY = YY^2
	  var yyyy = yy.redSqr();
	  // M = 3 * XX + a * ZZ2; a = 0
	  var m = xx.redAdd(xx).redIAdd(xx);
	  // MM = M^2
	  var mm = m.redSqr();
	  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
	  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	  e = e.redIAdd(e);
	  e = e.redAdd(e).redIAdd(e);
	  e = e.redISub(mm);
	  // EE = E^2
	  var ee = e.redSqr();
	  // T = 16*YYYY
	  var t = yyyy.redIAdd(yyyy);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  // U = (M + E)^2 - MM - EE - T
	  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
	  // X3 = 4 * (X1 * EE - 4 * YY * U)
	  var yyu4 = yy.redMul(u);
	  yyu4 = yyu4.redIAdd(yyu4);
	  yyu4 = yyu4.redIAdd(yyu4);
	  var nx = this.x.redMul(ee).redISub(yyu4);
	  nx = nx.redIAdd(nx);
	  nx = nx.redIAdd(nx);
	  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
	  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  // Z3 = (Z1 + E)^2 - ZZ - EE
	  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mul = function mul(k, kbase) {
	  k = new bn(k, kbase);

	  return this.curve._wnafMul(this, k);
	};

	JPoint.prototype.eq = function eq(p) {
	  if (p.type === 'affine')
	    return this.eq(p.toJ());

	  if (this === p)
	    return true;

	  // x1 * z2^2 == x2 * z1^2
	  var z2 = this.z.redSqr();
	  var pz2 = p.z.redSqr();
	  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
	    return false;

	  // y1 * z2^3 == y2 * z1^3
	  var z3 = z2.redMul(this.z);
	  var pz3 = pz2.redMul(p.z);
	  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
	};

	JPoint.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC JPoint Infinity>';
	  return '<EC JPoint x: ' + this.x.toString(16, 2) +
	      ' y: ' + this.y.toString(16, 2) +
	      ' z: ' + this.z.toString(16, 2) + '>';
	};

	JPoint.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var curves = exports;

	var assert = __webpack_require__(8);
	var hash = __webpack_require__(20);
	var bn = __webpack_require__(10);
	var elliptic = __webpack_require__(11);

	function PresetCurve(options) {
	  if (options.type === 'short')
	    this.curve = new elliptic.curve.short(options);
	  else if (options.type === 'edwards')
	    this.curve = new elliptic.curve.edwards(options);
	  else
	    this.curve = new elliptic.curve.mont(options);
	  this.g = this.curve.g;
	  this.n = this.curve.n;
	  this.hash = options.hash;

	  assert(this.g.validate(), 'Invalid curve');
	  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
	}
	curves.PresetCurve = PresetCurve;

	function defineCurve(name, options) {
	  Object.defineProperty(curves, name, {
	    configurable: true,
	    enumerable: true,
	    get: function() {
	      var curve = new PresetCurve(options);
	      Object.defineProperty(curves, name, {
	        configurable: true,
	        enumerable: true,
	        value: curve
	      });
	      return curve;
	    }
	  });
	}

	defineCurve('p192', {
	  type: 'short',
	  prime: 'p192',
	  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
	  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
	  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
	    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
	  ],
	});

	defineCurve('p224', {
	  type: 'short',
	  prime: 'p224',
	  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
	  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
	  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
	    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
	  ],
	});

	defineCurve('p256', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
	  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
	  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
	  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
	    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
	  ],
	});

	defineCurve('curve25519', {
	  type: 'mont',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '76d06',
	  b: '0',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '9'
	  ]
	});

	defineCurve('ed25519', {
	  type: 'edwards',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '-1',
	  c: '1',
	  // -121665 * (121666^(-1)) (mod P)
	  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

	    // 4/5
	    '6666666666666666666666666666666666666666666666666666666666666658'
	  ]
	});

	defineCurve('secp256k1', {
	  type: 'short',
	  prime: 'k256',
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
	  a: '0',
	  b: '7',
	  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
	  h: '1',
	  hash: hash.sha256,

	  // Precomputed endomorphism
	  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
	  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
	  basis: [
	    {
	      a: '3086d221a7d46bcde86c90e49284eb15',
	      b: '-e4437ed6010e88286f547fa90abfe4c3'
	    },
	    {
	      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
	      b: '3086d221a7d46bcde86c90e49284eb15'
	    }
	  ],

	  gRed: false,
	  g: [
	    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
	    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	    {
	      'doubles': {
	        'step': 4,
	        'points': [
	          [
	            'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
	            'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
	          ],
	          [
	            '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
	            '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
	          ],
	          [
	            '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
	            'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
	          ],
	          [
	            '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
	            '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
	          ],
	          [
	            '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
	            '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
	          ],
	          [
	            '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
	            '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
	          ],
	          [
	            'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
	            '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
	          ],
	          [
	            '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
	            'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
	          ],
	          [
	            'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
	            '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
	          ],
	          [
	            'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
	            'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
	          ],
	          [
	            'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
	            '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
	          ],
	          [
	            '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
	            '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
	          ],
	          [
	            '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
	            '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
	          ],
	          [
	            '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
	            '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
	          ],
	          [
	            '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
	            '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
	          ],
	          [
	            '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
	            '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
	          ],
	          [
	            '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
	            '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
	          ],
	          [
	            '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
	            '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
	          ],
	          [
	            '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
	            'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
	          ],
	          [
	            'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
	            '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
	          ],
	          [
	            'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
	            '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
	          ],
	          [
	            '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
	            '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
	          ],
	          [
	            '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
	            '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
	          ],
	          [
	            'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
	            '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
	          ],
	          [
	            '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
	            'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
	          ],
	          [
	            'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
	            '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
	          ],
	          [
	            'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
	            'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
	          ],
	          [
	            'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
	            '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
	          ],
	          [
	            'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
	            'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
	          ],
	          [
	            'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
	            '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
	          ],
	          [
	            '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
	            'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
	          ],
	          [
	            '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
	            '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
	          ],
	          [
	            'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
	            '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
	          ],
	          [
	            '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
	            'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
	          ],
	          [
	            'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
	            '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
	          ],
	          [
	            'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
	            '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
	          ],
	          [
	            'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
	            'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
	          ],
	          [
	            '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
	            '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
	          ],
	          [
	            '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
	            '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
	          ],
	          [
	            '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
	            'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
	          ],
	          [
	            '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
	            '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
	          ],
	          [
	            'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
	            '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
	          ],
	          [
	            '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
	            '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
	          ],
	          [
	            '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
	            'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
	          ],
	          [
	            '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
	            '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
	          ],
	          [
	            'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
	            '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
	          ],
	          [
	            '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
	            'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
	          ],
	          [
	            'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
	            'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
	          ],
	          [
	            'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
	            '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
	          ],
	          [
	            '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
	            'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
	          ],
	          [
	            '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
	            'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
	          ],
	          [
	            'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
	            '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
	          ],
	          [
	            'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
	            '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
	          ],
	          [
	            'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
	            '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
	          ],
	          [
	            '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
	            'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
	          ],
	          [
	            '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
	            '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
	          ],
	          [
	            'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
	            'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
	          ],
	          [
	            '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
	            'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
	          ],
	          [
	            '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
	            '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
	          ],
	          [
	            '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
	            '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
	          ],
	          [
	            'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
	            'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
	          ],
	          [
	            '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
	            '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
	          ],
	          [
	            '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
	            '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
	          ],
	          [
	            'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
	            '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
	          ],
	          [
	            'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
	            'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
	          ]
	        ]
	      },
	      'naf': {
	        'wnd': 7,
	        'points': [
	          [
	            'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
	            '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
	          ],
	          [
	            '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
	            'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
	          ],
	          [
	            '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
	            '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
	          ],
	          [
	            'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
	            'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
	          ],
	          [
	            '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
	            'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
	          ],
	          [
	            'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
	            'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
	          ],
	          [
	            'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
	            '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
	          ],
	          [
	            'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
	            '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
	          ],
	          [
	            '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
	            '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
	          ],
	          [
	            '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
	            '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
	          ],
	          [
	            '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
	            '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
	          ],
	          [
	            '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
	            '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
	          ],
	          [
	            'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
	            'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
	          ],
	          [
	            'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
	            '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
	          ],
	          [
	            '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
	            'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
	          ],
	          [
	            '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
	            'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
	          ],
	          [
	            '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
	            '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
	          ],
	          [
	            '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
	            '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
	          ],
	          [
	            '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
	            '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
	          ],
	          [
	            '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
	            'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
	          ],
	          [
	            'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
	            'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
	          ],
	          [
	            '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
	            '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
	          ],
	          [
	            '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
	            '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
	          ],
	          [
	            'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
	            'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
	          ],
	          [
	            '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
	            '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
	          ],
	          [
	            'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
	            'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
	          ],
	          [
	            'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
	            'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
	          ],
	          [
	            '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
	            '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
	          ],
	          [
	            '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
	            '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
	          ],
	          [
	            '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
	            '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
	          ],
	          [
	            'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
	            '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
	          ],
	          [
	            '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
	            '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
	          ],
	          [
	            'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
	            '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
	          ],
	          [
	            '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
	            'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
	          ],
	          [
	            '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
	            'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
	          ],
	          [
	            'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
	            'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
	          ],
	          [
	            '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
	            '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
	          ],
	          [
	            '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
	            'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
	          ],
	          [
	            'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
	            'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
	          ],
	          [
	            '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
	            '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
	          ],
	          [
	            '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
	            'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
	          ],
	          [
	            '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
	            '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
	          ],
	          [
	            '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
	            'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
	          ],
	          [
	            'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
	            '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
	          ],
	          [
	            '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
	            '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
	          ],
	          [
	            '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
	            'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
	          ],
	          [
	            '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
	            'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
	          ],
	          [
	            'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
	            'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
	          ],
	          [
	            'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
	            'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
	          ],
	          [
	            '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
	            '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
	          ],
	          [
	            '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
	            '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
	          ],
	          [
	            'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
	            '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
	          ],
	          [
	            'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
	            'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
	          ],
	          [
	            '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
	            '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
	          ],
	          [
	            '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
	            '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
	          ],
	          [
	            'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
	            '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
	          ],
	          [
	            '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
	            '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
	          ],
	          [
	            'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
	            'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
	          ],
	          [
	            '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
	            'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
	          ],
	          [
	            '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
	            '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
	          ],
	          [
	            'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
	            '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
	          ],
	          [
	            'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
	            '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
	          ],
	          [
	            '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
	            '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
	          ],
	          [
	            '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
	            '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
	          ],
	          [
	            '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
	            'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
	          ],
	          [
	            '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
	            'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
	          ],
	          [
	            '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
	            '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
	          ],
	          [
	            '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
	            '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
	          ],
	          [
	            '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
	            '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
	          ],
	          [
	            '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
	            'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
	          ],
	          [
	            'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
	            'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
	          ],
	          [
	            '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
	            'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
	          ],
	          [
	            'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
	            '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
	          ],
	          [
	            'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
	            '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
	          ],
	          [
	            'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
	            '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
	          ],
	          [
	            'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
	            '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
	          ],
	          [
	            '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
	            'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
	          ],
	          [
	            '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
	            '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
	          ],
	          [
	            '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
	            'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
	          ],
	          [
	            'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
	            'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
	          ],
	          [
	            'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
	            '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
	          ],
	          [
	            'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
	            'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
	          ],
	          [
	            'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
	            '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
	          ],
	          [
	            '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
	            '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
	          ],
	          [
	            'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
	            '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
	          ],
	          [
	            'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
	            '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
	          ],
	          [
	            '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
	            '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
	          ],
	          [
	            '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
	            'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
	          ],
	          [
	            'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
	            '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
	          ],
	          [
	            'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
	            '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
	          ],
	          [
	            'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
	            '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
	          ],
	          [
	            '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
	            '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
	          ],
	          [
	            'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
	            'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
	          ],
	          [
	            '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
	            'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
	          ],
	          [
	            'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
	            'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
	          ],
	          [
	            'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
	            '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
	          ],
	          [
	            '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
	            'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
	          ],
	          [
	            'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
	            '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
	          ],
	          [
	            'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
	            '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
	          ],
	          [
	            'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
	            '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
	          ],
	          [
	            '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
	            'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
	          ],
	          [
	            '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
	            'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
	          ],
	          [
	            'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
	            '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
	          ],
	          [
	            '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
	            'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
	          ],
	          [
	            '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
	            '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
	          ],
	          [
	            '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
	            'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
	          ],
	          [
	            'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
	            'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
	          ],
	          [
	            '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
	            'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
	          ],
	          [
	            '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
	            '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
	          ],
	          [
	            '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
	            'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
	          ],
	          [
	            '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
	            '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
	          ],
	          [
	            'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
	            'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
	          ],
	          [
	            '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
	            '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
	          ],
	          [
	            'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
	            '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
	          ],
	          [
	            '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
	            '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
	          ],
	          [
	            'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
	            'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
	          ],
	          [
	            'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
	            '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
	          ],
	          [
	            'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
	            'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
	          ],
	          [
	            '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
	            'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
	          ],
	          [
	            '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
	            '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
	          ],
	          [
	            '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
	            'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
	          ],
	          [
	            '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
	            '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
	          ],
	          [
	            '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
	            '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
	          ],
	          [
	            '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
	            'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
	          ],
	          [
	            '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
	            '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
	          ],
	          [
	            '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
	            '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
	          ],
	          [
	            '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
	            '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
	          ]
	        ]
	      }
	    }
	  ]
	});


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(8);
	var bn = __webpack_require__(10);
	var elliptic = __webpack_require__(11);
	var utils = elliptic.utils;

	var KeyPair = __webpack_require__(94);
	var Signature = __webpack_require__(95);

	function EC(options) {
	  if (!(this instanceof EC))
	    return new EC(options);

	  // Shortcut `elliptic.ec(curve-name)`
	  if (typeof options === 'string') {
	    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

	    options = elliptic.curves[options];
	  }

	  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
	  if (options instanceof elliptic.curves.PresetCurve)
	    options = { curve: options };

	  this.curve = options.curve.curve;
	  this.n = this.curve.n;
	  this.nh = this.n.shrn(1);
	  this.g = this.curve.g;

	  // Point on curve
	  this.g = options.curve.g;
	  this.g.precompute(options.curve.n.bitLength() + 1);

	  // Hash for function for DRBG
	  this.hash = options.hash || options.curve.hash;
	}
	module.exports = EC;

	EC.prototype.keyPair = function keyPair(priv, pub) {
	  return new KeyPair(this, priv, pub);
	};

	EC.prototype.genKeyPair = function genKeyPair(options) {
	  if (!options)
	    options = {};

	  // Instantiate Hmac_DRBG
	  var drbg = new elliptic.hmacDRBG({
	    hash: this.hash,
	    pers: options.pers,
	    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
	    nonce: this.n.toArray()
	  });

	  var bytes = this.n.byteLength();
	  var ns2 = this.n.sub(new bn(2));
	  do {
	    var priv = new bn(drbg.generate(bytes));
	    if (priv.cmp(ns2) > 0)
	      continue;

	    priv.iaddn(1);
	    return this.keyPair(priv);
	  } while (true);
	};

	EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
	  var delta = msg.byteLength() * 8 - this.n.bitLength();
	  if (delta > 0)
	    msg = msg.shrn(delta);
	  if (!truncOnly && msg.cmp(this.n) >= 0)
	    return msg.sub(this.n);
	  else
	    return msg;
	};

	EC.prototype.sign = function sign(msg, key, options) {
	  key = this.keyPair(key, 'hex');
	  msg = this._truncateToN(new bn(msg, 16));
	  if (!options)
	    options = {};

	  // Zero-extend key to provide enough entropy
	  var bytes = this.n.byteLength();
	  var bkey = key.getPrivate().toArray();
	  for (var i = bkey.length; i < 21; i++)
	    bkey.unshift(0);

	  // Zero-extend nonce to have the same byte size as N
	  var nonce = msg.toArray();
	  for (var i = nonce.length; i < bytes; i++)
	    nonce.unshift(0);

	  // Instantiate Hmac_DRBG
	  var drbg = new elliptic.hmacDRBG({
	    hash: this.hash,
	    entropy: bkey,
	    nonce: nonce
	  });

	  // Number of bytes to generate
	  var ns1 = this.n.sub(new bn(1));
	  do {
	    var k = new bn(drbg.generate(this.n.byteLength()));
	    k = this._truncateToN(k, true);
	    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
	      continue;

	    var kp = this.g.mul(k);
	    if (kp.isInfinity())
	      continue;

	    var r = kp.getX().mod(this.n);
	    if (r.cmpn(0) === 0)
	      continue;

	    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg)).mod(this.n);
	    if (s.cmpn(0) === 0)
	      continue;

	    // Use complement of `s`, if it is > `n / 2`
	    if (options.canonical && s.cmp(this.nh) > 0)
	      s = this.n.sub(s);

	    return new Signature(r, s);
	  } while (true);
	};

	EC.prototype.verify = function verify(msg, signature, key) {
	  msg = this._truncateToN(new bn(msg, 16));
	  key = this.keyPair(key, 'hex');
	  signature = new Signature(signature, 'hex');

	  // Perform primitive values validation
	  var r = signature.r;
	  var s = signature.s;
	  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
	    return false;
	  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
	    return false;

	  // Validate signature
	  var sinv = s.invm(this.n);
	  var u1 = sinv.mul(msg).mod(this.n);
	  var u2 = sinv.mul(r).mod(this.n);

	  var p = this.g.mulAdd(u1, key.getPublic(), u2);
	  if (p.isInfinity())
	    return false;

	  return p.getX().mod(this.n).cmp(r) === 0;
	};


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(8);
	var bn = __webpack_require__(10);

	var elliptic = __webpack_require__(11);
	var utils = elliptic.utils;

	function KeyPair(ec, priv, pub) {
	  if (priv instanceof KeyPair)
	    return priv;
	  if (pub instanceof KeyPair)
	    return pub;

	  if (!priv) {
	    priv = pub;
	    pub = null;
	  }
	  if (priv !== null && typeof priv === 'object') {
	    if (priv.x) {
	      // KeyPair(public)
	      pub = priv;
	      priv = null;
	    } else if (priv.priv || priv.pub) {
	      // KeyPair({ priv: ..., pub: ... })
	      pub = priv.pub;
	      priv = priv.priv;
	    }
	  }

	  this.ec = ec;
	  this.priv = null;
	  this.pub = null;

	  // KeyPair(public, 'hex')
	  if (this._importPublicHex(priv, pub))
	    return;

	  if (pub === 'hex')
	    pub = null;

	  // KeyPair(priv, pub)
	  if (priv)
	    this._importPrivate(priv);
	  if (pub)
	    this._importPublic(pub);
	}
	module.exports = KeyPair;

	KeyPair.prototype.validate = function validate() {
	  var pub = this.getPublic();

	  if (pub.isInfinity())
	    return { result: false, reason: 'Invalid public key' };
	  if (!pub.validate())
	    return { result: false, reason: 'Public key is not a point' };
	  if (!pub.mul(this.ec.curve.n).isInfinity())
	    return { result: false, reason: 'Public key * N != O' };

	  return { result: true, reason: null };
	};

	KeyPair.prototype.getPublic = function getPublic(compact, enc) {
	  if (!this.pub)
	    this.pub = this.ec.g.mul(this.priv);

	  // compact is optional argument
	  if (typeof compact === 'string') {
	    enc = compact;
	    compact = null;
	  }

	  if (!enc)
	    return this.pub;

	  var len = this.ec.curve.p.byteLength();
	  var x = this.pub.getX().toArray();

	  for (var i = x.length; i < len; i++)
	    x.unshift(0);

	  if (compact) {
	    var res = [ this.pub.getY().isEven() ? 0x02 : 0x03 ].concat(x);
	  } else {
	    var y = this.pub.getY().toArray();
	    for (var i = y.length; i < len; i++)
	      y.unshift(0);
	    var res = [ 0x04 ].concat(x, y);
	  }
	  return utils.encode(res, enc);
	};

	KeyPair.prototype.getPrivate = function getPrivate(enc) {
	  if (enc === 'hex')
	    return this.priv.toString(16, 2);
	  else
	    return this.priv;
	};

	KeyPair.prototype._importPrivate = function _importPrivate(key) {
	  this.priv = new bn(key, 16);

	  // Ensure that the priv won't be bigger than n, otherwise we may fail
	  // in fixed multiplication method
	  this.priv = this.priv.mod(this.ec.curve.n);
	};

	KeyPair.prototype._importPublic = function _importPublic(key) {
	  this.pub = this.ec.curve.point(key.x, key.y);
	};

	KeyPair.prototype._importPublicHex = function _importPublic(key, enc) {
	  key = utils.toArray(key, enc);
	  var len = this.ec.curve.p.byteLength();
	  if (key[0] === 0x04 && key.length - 1 === 2 * len) {
	    this.pub = this.ec.curve.point(
	      key.slice(1, 1 + len),
	      key.slice(1 + len, 1 + 2 * len));
	  } else if ((key[0] === 0x02 || key[0] === 0x03) && key.length - 1 === len) {
	    this.pub = this.ec.curve.pointFromX(key[0] === 0x03,
	                                        key.slice(1, 1 +len));
	  } else {
	    return false;
	  }

	  return true;
	};

	// ECDH
	KeyPair.prototype.derive = function derive(pub) {
	  return pub.mul(this.priv).getX();
	};

	// ECDSA
	KeyPair.prototype.sign = function sign(msg) {
	  return this.ec.sign(msg, this);
	};

	KeyPair.prototype.verify = function verify(msg, signature) {
	  return this.ec.verify(msg, signature, this);
	};

	KeyPair.prototype.inspect = function inspect() {
	  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
	         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(8);
	var bn = __webpack_require__(10);

	var elliptic = __webpack_require__(11);
	var utils = elliptic.utils;

	function Signature(r, s) {
	  if (r instanceof Signature)
	    return r;

	  if (this._importDER(r, s))
	    return;

	  assert(r && s, 'Signature without r or s');
	  this.r = new bn(r, 16);
	  this.s = new bn(s, 16);
	}
	module.exports = Signature;

	Signature.prototype._importDER = function _importDER(data, enc) {
	  data = utils.toArray(data, enc);
	  if (data.length < 6 || data[0] !== 0x30 || data[2] !== 0x02)
	    return false;
	  var total = data[1];
	  if (1 + total > data.length)
	    return false;
	  var rlen = data[3];
	  // Short length notation
	  if (rlen >= 0x80)
	    return false;
	  if (4 + rlen + 2 >= data.length)
	    return false;
	  if (data[4 + rlen] !== 0x02)
	    return false;
	  var slen = data[5 + rlen];
	  // Short length notation
	  if (slen >= 0x80)
	    return false;
	  if (4 + rlen + 2 + slen > data.length)
	    return false;

	  this.r = new bn(data.slice(4, 4 + rlen));
	  this.s = new bn(data.slice(4 + rlen + 2, 4 + rlen + 2 + slen));

	  return true;
	};

	Signature.prototype.toDER = function toDER(enc) {
	  var r = this.r.toArray();
	  var s = this.s.toArray();

	  // Pad values
	  if (r[0] & 0x80)
	    r = [ 0 ].concat(r);
	  // Pad values
	  if (s[0] & 0x80)
	    s = [ 0 ].concat(s);

	  var total = r.length + s.length + 4;
	  var res = [ 0x30, total, 0x02, r.length ];
	  res = res.concat(r, [ 0x02, s.length ], s);
	  return utils.encode(res, enc);
	};


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(8);

	var hash = __webpack_require__(20);
	var elliptic = __webpack_require__(11);
	var utils = elliptic.utils;

	function HmacDRBG(options) {
	  if (!(this instanceof HmacDRBG))
	    return new HmacDRBG(options);
	  this.hash = options.hash;
	  this.predResist = !!options.predResist;

	  this.outLen = this.hash.outSize;
	  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

	  this.reseed = null;
	  this.reseedInterval = null;
	  this.K = null;
	  this.V = null;

	  var entropy = utils.toArray(options.entropy, options.entropyEnc);
	  var nonce = utils.toArray(options.nonce, options.nonceEnc);
	  var pers = utils.toArray(options.pers, options.persEnc);
	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
	  this._init(entropy, nonce, pers);
	}
	module.exports = HmacDRBG;

	HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
	  var seed = entropy.concat(nonce).concat(pers);

	  this.K = new Array(this.outLen / 8);
	  this.V = new Array(this.outLen / 8);
	  for (var i = 0; i < this.V.length; i++) {
	    this.K[i] = 0x00;
	    this.V[i] = 0x01;
	  }

	  this._update(seed);
	  this.reseed = 1;
	  this.reseedInterval = 0x1000000000000;  // 2^48
	};

	HmacDRBG.prototype._hmac = function hmac() {
	  return new hash.hmac(this.hash, this.K);
	};

	HmacDRBG.prototype._update = function update(seed) {
	  var kmac = this._hmac()
	                 .update(this.V)
	                 .update([ 0x00 ]);
	  if (seed)
	    kmac = kmac.update(seed);
	  this.K = kmac.digest();
	  this.V = this._hmac().update(this.V).digest();
	  if (!seed)
	    return;

	  this.K = this._hmac()
	               .update(this.V)
	               .update([ 0x01 ])
	               .update(seed)
	               .digest();
	  this.V = this._hmac().update(this.V).digest();
	};

	HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
	  // Optional entropy enc
	  if (typeof entropyEnc !== 'string') {
	    addEnc = add;
	    add = entropyEnc;
	    entropyEnc = null;
	  }

	  entropy = utils.toBuffer(entropy, entropyEnc);
	  add = utils.toBuffer(add, addEnc);

	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

	  this._update(entropy.concat(add || []));
	  this.reseed = 1;
	};

	HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
	  if (this.reseed > this.reseedInterval)
	    throw new Error('Reseed is required');

	  // Optional encoding
	  if (typeof enc !== 'string') {
	    addEnc = add;
	    add = enc;
	    enc = null;
	  }

	  // Optional additional data
	  if (add) {
	    add = utils.toArray(add, addEnc);
	    this._update(add);
	  }

	  var temp = [];
	  while (temp.length < len) {
	    this.V = this._hmac().update(this.V).digest();
	    temp = temp.concat(this.V);
	  }

	  var res = temp.slice(0, len);
	  this._update(add);
	  this.reseed++;
	  return utils.encode(res, enc);
	};


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(8);
	var bn = __webpack_require__(10);

	var utils = exports;

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg === 'string') {
	    if (!enc) {
	      for (var i = 0; i < msg.length; i++) {
	        var c = msg.charCodeAt(i);
	        var hi = c >> 8;
	        var lo = c & 0xff;
	        if (hi)
	          res.push(hi, lo);
	        else
	          res.push(lo);
	      }
	    } else if (enc === 'hex') {
	      msg = msg.replace(/[^a-z0-9]+/ig, '');
	      if (msg.length % 2 !== 0)
	        msg = '0' + msg;
	      for (var i = 0; i < msg.length; i += 2)
	        res.push(parseInt(msg[i] + msg[i + 1], 16));
	    }
	  } else {
	    for (var i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	  }
	  return res;
	}
	utils.toArray = toArray;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils.toHex = toHex;

	utils.encode = function encode(arr, enc) {
	  if (enc === 'hex')
	    return toHex(arr);
	  else
	    return arr;
	};

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils.zero2 = zero2;

	// Represent num in a w-NAF form
	function getNAF(num, w) {
	  var naf = [];
	  var ws = 1 << (w + 1);
	  var k = num.clone();
	  while (k.cmpn(1) >= 0) {
	    var z;
	    if (k.isOdd()) {
	      var mod = k.andln(ws - 1);
	      if (mod > (ws >> 1) - 1)
	        z = (ws >> 1) - mod;
	      else
	        z = mod;
	      k.isubn(z);
	    } else {
	      z = 0;
	    }
	    naf.push(z);

	    // Optimization, shift by word if possible
	    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
	    for (var i = 1; i < shift; i++)
	      naf.push(0);
	    k.ishrn(shift);
	  }

	  return naf;
	}
	utils.getNAF = getNAF;

	// Represent k1, k2 in a Joint Sparse Form
	function getJSF(k1, k2) {
	  var jsf = [
	    [],
	    []
	  ];

	  k1 = k1.clone();
	  k2 = k2.clone();
	  var d1 = 0;
	  var d2 = 0;
	  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

	    // First phase
	    var m14 = (k1.andln(3) + d1) & 3;
	    var m24 = (k2.andln(3) + d2) & 3;
	    if (m14 === 3)
	      m14 = -1;
	    if (m24 === 3)
	      m24 = -1;
	    var u1;
	    if ((m14 & 1) === 0) {
	      u1 = 0;
	    } else {
	      var m8 = (k1.andln(7) + d1) & 7;
	      if ((m8 === 3 || m8 === 5) && m24 === 2)
	        u1 = -m14;
	      else
	        u1 = m14;
	    }
	    jsf[0].push(u1);

	    var u2;
	    if ((m24 & 1) === 0) {
	      u2 = 0;
	    } else {
	      var m8 = (k2.andln(7) + d2) & 7;
	      if ((m8 === 3 || m8 === 5) && m14 === 2)
	        u2 = -m24;
	      else
	        u2 = m24;
	    }
	    jsf[1].push(u2);

	    // Second phase
	    if (2 * d1 === u1 + 1)
	      d1 = 1 - d1;
	    if (2 * d2 === u2 + 1)
	      d2 = 1 - d2;
	    k1.ishrn(1);
	    k2.ishrn(1);
	  }

	  return jsf;
	}
	utils.getJSF = getJSF;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var r;

	module.exports = function rand(len) {
	  if (!r)
	    r = new Rand();

	  return r.generate(len);
	};

	function Rand() {
	}

	Rand.prototype.generate = function generate(len) {
	  return this._rand(len);
	};

	if (typeof window === 'object') {
	  if (window.crypto && window.crypto.getRandomValues) {
	    // Modern browsers
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      window.crypto.getRandomValues(arr);
	      return arr;
	    };
	  } else if (window.msCrypto && window.msCrypto.getRandomValues) {
	    // IE
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      window.msCrypto.getRandomValues(arr);
	      return arr;
	    };
	  } else {
	    // Old junk
	    Rand.prototype._rand = function() {
	      throw new Error('Not implemented yet');
	    };
	  }
	} else {
	  // Node.js
	  var crypto;
	  Rand.prototype._rand = function _rand(n) {
	    if (!crypto)
	      crypto = __webpack_require__(47);
	    return crypto.randomBytes(n);
	  };
	}


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var hash = __webpack_require__(20);
	var utils = hash.utils;
	var assert = utils.assert;

	function BlockHash() {
	  this.pending = null;
	  this.pendingTotal = 0;
	  this.blockSize = this.constructor.blockSize;
	  this.outSize = this.constructor.outSize;
	  this.hmacStrength = this.constructor.hmacStrength;
	  this.endian = 'big';

	  this._delta8 = this.blockSize / 8;
	  this._delta32 = this.blockSize / 32;
	}
	exports.BlockHash = BlockHash;

	BlockHash.prototype.update = function update(msg, enc) {
	  // Convert message to array, pad it, and join into 32bit blocks
	  msg = utils.toArray(msg, enc);
	  if (!this.pending)
	    this.pending = msg;
	  else
	    this.pending = this.pending.concat(msg);
	  this.pendingTotal += msg.length;

	  // Enough data, try updating
	  if (this.pending.length >= this._delta8) {
	    msg = this.pending;

	    // Process pending data in blocks
	    var r = msg.length % this._delta8;
	    this.pending = msg.slice(msg.length - r, msg.length);
	    if (this.pending.length === 0)
	      this.pending = null;

	    msg = utils.join32(msg, 0, msg.length - r, this.endian);
	    for (var i = 0; i < msg.length; i += this._delta32)
	      this._update(msg, i, i + this._delta32);
	  }

	  return this;
	};

	BlockHash.prototype.digest = function digest(enc) {
	  this.update(this._pad());
	  assert(this.pending === null);

	  return this._digest(enc);
	};

	BlockHash.prototype._pad = function pad() {
	  var len = this.pendingTotal;
	  var bytes = this._delta8;
	  var k = bytes - ((len + 8) % bytes);
	  var res = new Array(k + 8);
	  res[0] = 0x80;
	  for (var i = 1; i < k; i++)
	    res[i] = 0;

	  // Append length
	  len <<= 3;
	  if (this.endian === 'big') {
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = len & 0xff;
	  } else {
	    res[i++] = len & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	  }

	  return res;
	}


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var hmac = exports;

	var hash = __webpack_require__(20);
	var utils = hash.utils;
	var assert = utils.assert;

	function Hmac(hash, key, enc) {
	  if (!(this instanceof Hmac))
	    return new Hmac(hash, key, enc);
	  this.Hash = hash;
	  this.blockSize = hash.blockSize / 8;
	  this.outSize = hash.outSize / 8;
	  this.inner = null;
	  this.outer = null;

	  this._init(utils.toArray(key, enc));
	}
	module.exports = Hmac;

	Hmac.prototype._init = function init(key) {
	  // Shorten key, if needed
	  if (key.length > this.blockSize)
	    key = new this.Hash().update(key).digest();
	  assert(key.length <= this.blockSize);

	  // Add padding to key
	  for (var i = key.length; i < this.blockSize; i++)
	    key.push(0);

	  for (var i = 0; i < key.length; i++)
	    key[i] ^= 0x36;
	  this.inner = new this.Hash().update(key);

	  // 0x36 ^ 0x5c = 0x6a
	  for (var i = 0; i < key.length; i++)
	    key[i] ^= 0x6a;
	  this.outer = new this.Hash().update(key);
	};

	Hmac.prototype.update = function update(msg, enc) {
	  this.inner.update(msg, enc);
	  return this;
	};

	Hmac.prototype.digest = function digest(enc) {
	  this.outer.update(this.inner.digest());
	  return this.outer.digest(enc);
	};


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var hash = __webpack_require__(20);
	var utils = hash.utils;

	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_3 = utils.sum32_3;
	var sum32_4 = utils.sum32_4;
	var BlockHash = hash.common.BlockHash;

	function RIPEMD160() {
	  if (!(this instanceof RIPEMD160))
	    return new RIPEMD160();

	  BlockHash.call(this);

	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
	  this.endian = 'little';
	}
	utils.inherits(RIPEMD160, BlockHash);
	exports.ripemd160 = RIPEMD160;

	RIPEMD160.blockSize = 512;
	RIPEMD160.outSize = 160;
	RIPEMD160.hmacStrength = 192;

	RIPEMD160.prototype._update = function update(msg, start) {
	  var A = this.h[0];
	  var B = this.h[1];
	  var C = this.h[2];
	  var D = this.h[3];
	  var E = this.h[4];
	  var Ah = A;
	  var Bh = B;
	  var Ch = C;
	  var Dh = D;
	  var Eh = E;
	  for (var j = 0; j < 80; j++) {
	    var T = sum32(
	      rotl32(
	        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
	        s[j]),
	      E);
	    A = E;
	    E = D;
	    D = rotl32(C, 10);
	    C = B;
	    B = T;
	    T = sum32(
	      rotl32(
	        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
	        sh[j]),
	      Eh);
	    Ah = Eh;
	    Eh = Dh;
	    Dh = rotl32(Ch, 10);
	    Ch = Bh;
	    Bh = T;
	  }
	  T = sum32_3(this.h[1], C, Dh);
	  this.h[1] = sum32_3(this.h[2], D, Eh);
	  this.h[2] = sum32_3(this.h[3], E, Ah);
	  this.h[3] = sum32_3(this.h[4], A, Bh);
	  this.h[4] = sum32_3(this.h[0], B, Ch);
	  this.h[0] = T;
	};

	RIPEMD160.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'little');
	  else
	    return utils.split32(this.h, 'little');
	};

	function f(j, x, y, z) {
	  if (j <= 15)
	    return x ^ y ^ z;
	  else if (j <= 31)
	    return (x & y) | ((~x) & z);
	  else if (j <= 47)
	    return (x | (~y)) ^ z;
	  else if (j <= 63)
	    return (x & z) | (y & (~z));
	  else
	    return x ^ (y | (~z));
	}

	function K(j) {
	  if (j <= 15)
	    return 0x00000000;
	  else if (j <= 31)
	    return 0x5a827999;
	  else if (j <= 47)
	    return 0x6ed9eba1;
	  else if (j <= 63)
	    return 0x8f1bbcdc;
	  else
	    return 0xa953fd4e;
	}

	function Kh(j) {
	  if (j <= 15)
	    return 0x50a28be6;
	  else if (j <= 31)
	    return 0x5c4dd124;
	  else if (j <= 47)
	    return 0x6d703ef3;
	  else if (j <= 63)
	    return 0x7a6d76e9;
	  else
	    return 0x00000000;
	}

	var r = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
	];

	var rh = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var s = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
	];

	var sh = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var hash = __webpack_require__(20);
	var utils = hash.utils;
	var assert = utils.assert;

	var rotr32 = utils.rotr32;
	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_4 = utils.sum32_4;
	var sum32_5 = utils.sum32_5;
	var BlockHash = hash.common.BlockHash;

	var sha256_K = [
	  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	];

	var sha1_K = [
	  0x5A827999, 0x6ED9EBA1,
	  0x8F1BBCDC, 0xCA62C1D6
	];

	function SHA256() {
	  if (!(this instanceof SHA256))
	    return new SHA256();

	  BlockHash.call(this);
	  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
	  this.k = sha256_K;
	  this.W = new Array(64);
	}
	utils.inherits(SHA256, BlockHash);
	exports.sha256 = SHA256;

	SHA256.blockSize = 512;
	SHA256.outSize = 256;
	SHA256.hmacStrength = 192;

	SHA256.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i++)
	    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];
	  var f = this.h[5];
	  var g = this.h[6];
	  var h = this.h[7];

	  assert(this.k.length === W.length);
	  for (var i = 0; i < W.length; i++) {
	    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
	    var T2 = sum32(s0_256(a), maj32(a, b, c));
	    h = g;
	    g = f;
	    f = e;
	    e = sum32(d, T1);
	    d = c;
	    c = b;
	    b = a;
	    a = sum32(T1, T2);
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	  this.h[5] = sum32(this.h[5], f);
	  this.h[6] = sum32(this.h[6], g);
	  this.h[7] = sum32(this.h[7], h);
	};

	SHA256.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function SHA224() {
	  if (!(this instanceof SHA224))
	    return new SHA224();

	  SHA256.call(this);
	  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
	}
	utils.inherits(SHA224, SHA256);
	exports.sha224 = SHA224;

	SHA224.blockSize = 512;
	SHA224.outSize = 224;
	SHA224.hmacStrength = 192;

	SHA224.prototype._digest = function digest(enc) {
	  // Just truncate output
	  if (enc === 'hex')
	    return utils.toHex32(this.h.slice(0, 7), 'big');
	  else
	    return utils.split32(this.h.slice(0, 7), 'big');
	};

	function SHA1() {
	  if (!(this instanceof SHA1))
	    return new SHA1();

	  BlockHash.call(this);
	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
	             0x10325476, 0xc3d2e1f0 ];
	  this.W = new Array(80);
	}

	utils.inherits(SHA1, BlockHash);
	exports.sha1 = SHA1;

	SHA1.blockSize = 512;
	SHA1.outSize = 160;
	SHA1.hmacStrength = 80;

	SHA1.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];

	  for(; i < W.length; i++)
	    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];

	  for (var i = 0; i < W.length; i++) {
	    var s = ~~(i / 20);
	    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
	    e = d;
	    d = c;
	    c = rotl32(b, 30);
	    b = a;
	    a = t;
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	};

	SHA1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function ch32(x, y, z) {
	  return (x & y) ^ ((~x) & z);
	}

	function maj32(x, y, z) {
	  return (x & y) ^ (x & z) ^ (y & z);
	}

	function p32(x, y, z) {
	  return x ^ y ^ z;
	}

	function s0_256(x) {
	  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
	}

	function s1_256(x) {
	  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
	}

	function g0_256(x) {
	  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
	}

	function g1_256(x) {
	  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
	}

	function ft_1(s, x, y, z) {
	  if (s === 0)
	    return ch32(x, y, z);
	  if (s === 1 || s === 3)
	    return p32(x, y, z)
	  if (s === 2)
	    return maj32(x, y, z)
	}


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var utils = exports;
	var inherits = __webpack_require__(25);

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg === 'string') {
	    if (!enc) {
	      for (var i = 0; i < msg.length; i++) {
	        var c = msg.charCodeAt(i);
	        var hi = c >> 8;
	        var lo = c & 0xff;
	        if (hi)
	          res.push(hi, lo);
	        else
	          res.push(lo);
	      }
	    } else if (enc === 'hex') {
	      msg = msg.replace(/[^a-z0-9]+/ig, '');
	      if (msg.length % 2 != 0)
	        msg = '0' + msg;
	      for (var i = 0; i < msg.length; i += 2)
	        res.push(parseInt(msg[i] + msg[i + 1], 16));
	    }
	  } else {
	    for (var i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	  }
	  return res;
	}
	utils.toArray = toArray;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils.toHex = toHex;

	function toHex32(msg, endian) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++) {
	    var w = msg[i];
	    if (endian === 'little') {
	      w = (w >>> 24) |
	          ((w >>> 8) & 0xff00) |
	          ((w << 8) & 0xff0000) |
	          ((w & 0xff) << 24);
	      if (w < 0)
	        w += 0x100000000;
	    }
	    res += zero8(w.toString(16));
	  }
	  return res;
	}
	utils.toHex32 = toHex32;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils.zero2 = zero2;

	function zero8(word) {
	  if (word.length === 7)
	    return '0' + word;
	  else if (word.length === 6)
	    return '00' + word;
	  else if (word.length === 5)
	    return '000' + word;
	  else if (word.length === 4)
	    return '0000' + word;
	  else if (word.length === 3)
	    return '00000' + word;
	  else if (word.length === 2)
	    return '000000' + word;
	  else if (word.length === 1)
	    return '0000000' + word;
	  else
	    return word;
	}
	utils.zero8 = zero8;

	function join32(msg, start, end, endian) {
	  var len = end - start;
	  assert(len % 4 === 0);
	  var res = new Array(len / 4);
	  for (var i = 0, k = start; i < res.length; i++, k += 4) {
	    var w;
	    if (endian === 'big')
	      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
	    else
	      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
	    if (w < 0)
	      w += 0x100000000;
	    res[i] = w;
	  }
	  return res;
	}
	utils.join32 = join32;

	function split32(msg, endian) {
	  var res = new Array(msg.length * 4);
	  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
	    var m = msg[i];
	    if (endian === 'big') {
	      res[k] = m >>> 24;
	      res[k + 1] = (m >>> 16) & 0xff;
	      res[k + 2] = (m >>> 8) & 0xff;
	      res[k + 3] = m & 0xff;
	    } else {
	      res[k + 3] = m >>> 24;
	      res[k + 2] = (m >>> 16) & 0xff;
	      res[k + 1] = (m >>> 8) & 0xff;
	      res[k] = m & 0xff;
	    }
	  }
	  return res;
	}
	utils.split32 = split32;

	function rotr32(w, b) {
	  return (w >>> b) | (w << (32 - b));
	}
	utils.rotr32 = rotr32;

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}
	utils.rotl32 = rotl32;

	function sum32(a, b) {
	  var r = (a + b) & 0xffffffff;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}
	utils.sum32 = sum32;

	function sum32_3(a, b, c) {
	  var r = (a + b + c) & 0xffffffff;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}
	utils.sum32_3 = sum32_3;

	function sum32_4(a, b, c, d) {
	  var r = (a + b + c + d) & 0xffffffff;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}
	utils.sum32_4 = sum32_4;

	function sum32_5(a, b, c, d, e) {
	  var r = (a + b + c + d + e) & 0xffffffff;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}
	utils.sum32_5 = sum32_5;

	function assert(cond, msg) {
	  if (!cond)
	    throw new Error(msg || 'Assertion failed');
	}
	utils.assert = assert;

	utils.inherits = inherits;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var WordArray = __webpack_require__(45)

	var Base = (function () {
	  function F() {}

	  return {
	    /**
	     * Creates a new object that inherits from this object.
	     *
	     * @param {Object} overrides Properties to copy into the new object.
	     *
	     * @return {Object} The new object.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var MyType = CryptoJS.lib.Base.extend({
	     *         field: 'value',
	     *
	     *         method: function () {
	     *         }
	     *     });
	     */
	    extend: function (overrides) {
	      // Spawn
	      F.prototype = this;
	      var subtype = new F();

	      // Augment
	      if (overrides) {
	        subtype.mixIn(overrides);
	      }

	      // Create default initializer
	      if (!subtype.hasOwnProperty('init')) {
	        subtype.init = function () {
	          subtype.$super.init.apply(this, arguments);
	        };
	      }

	      // Initializer's prototype is the subtype object
	      subtype.init.prototype = subtype;

	      // Reference supertype
	      subtype.$super = this;

	      return subtype;
	    },

	    /**
	     * Extends this object and runs the init method.
	     * Arguments to create() will be passed to init().
	     *
	     * @return {Object} The new object.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var instance = MyType.create();
	     */
	    create: function () {
	      var instance = this.extend();
	      instance.init.apply(instance, arguments);

	      return instance;
	    },

	    /**
	     * Initializes a newly created object.
	     * Override this method to add some logic when your objects are created.
	     *
	     * @example
	     *
	     *     var MyType = CryptoJS.lib.Base.extend({
	     *         init: function () {
	     *             // ...
	     *         }
	     *     });
	     */
	      init: function () {
	    },


	    mixIn: function (properties) {
	      for (var propertyName in properties) {
	        if (properties.hasOwnProperty(propertyName)) {
	          this[propertyName] = properties[propertyName];
	        }
	      }

	      // IE won't copy toString using the loop above
	      if (properties.hasOwnProperty('toString')) {
	        this.toString = properties.toString;
	      }
	    },


	    clone: function () {
	      return this.init.prototype.extend(this);
	    }
	  };
	}());


	/**
	 * Abstract buffered block algorithm template.
	 *
	 * The property blockSize must be implemented in a concrete subtype.
	 *
	 * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	 */
	var BufferedBlockAlgorithm = Base.extend({
	  /**
	   * Resets this block algorithm's data buffer to its initial state.
	   *
	   * @example
	   *
	   *     bufferedBlockAlgorithm.reset();
	   */
	    reset: function () {
	      // Initial values
	      this._data = new WordArray();
	      this._nDataBytes = 0;
	    },

	    /**
	     * Adds new data to this block algorithm's buffer.
	     *
	     * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	     *
	     * @example
	     *
	     *     bufferedBlockAlgorithm._append('data');
	     *     bufferedBlockAlgorithm._append(wordArray);
	     */
	    _append: function (data) {
	      //console.dir(data)

	      if (Buffer.isBuffer(data)) {
	        data = WordArray.fromBuffer(data)
	      }

	      // Append
	      this._data.concat(data);
	      this._nDataBytes += data.sigBytes;
	    },

	    /**
	     * Processes available data blocks.
	     *
	     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	     *
	     * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	     *
	     * @return {WordArray} The processed data.
	     *
	     * @example
	     *
	     *     var processedData = bufferedBlockAlgorithm._process();
	     *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	     */
	    _process: function (doFlush) {
	      // Shortcuts
	      var data = this._data;
	      var dataWords = data.words;
	      var dataSigBytes = data.sigBytes;
	      var blockSize = this.blockSize;
	      var blockSizeBytes = blockSize * 4;

	      // Count blocks ready
	      var nBlocksReady = dataSigBytes / blockSizeBytes;
	      if (doFlush) {
	          // Round up to include partial blocks
	          nBlocksReady = Math.ceil(nBlocksReady);
	      } else {
	          // Round down to include only full blocks,
	          // less the number of blocks that must remain in the buffer
	          nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	      }

	      // Count words ready
	      var nWordsReady = nBlocksReady * blockSize;

	      // Count bytes ready
	      var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	      // Process blocks
	      if (nWordsReady) {
	        for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	          // Perform concrete-algorithm logic
	          this._doProcessBlock(dataWords, offset);
	        }

	        // Remove processed words
	        var processedWords = dataWords.splice(0, nWordsReady);
	        data.sigBytes -= nBytesReady;
	      }

	      // Return processed words
	      return new WordArray(processedWords, nBytesReady);
	    },

	    /**
	     * Creates a copy of this object.
	     * @example
	     *
	     *     var clone = bufferedBlockAlgorithm.clone();
	     */
	    clone: function () {
	      var clone = Base.clone.call(this);
	      clone._data = this._data.clone();

	      return clone;
	    },

	      _minBufferSize: 0
	    });

	/**
	 * Abstract hasher template.
	 *
	 * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	 */
	var Hasher = BufferedBlockAlgorithm.extend({
	  /**
	   * Configuration options.
	   */
	  cfg: Base.extend(),

	  /**
	   * Initializes a newly created hasher.
	   * @example
	   *
	   *     var hasher = CryptoJS.algo.SHA256.create();
	   */
	  init: function (cfg) {
	    // Apply config defaults
	    this.cfg = this.cfg.extend(cfg);

	    // Set initial values
	    this.reset();
	  },

	  reset: function () {
	    // Reset data buffer
	    BufferedBlockAlgorithm.reset.call(this);

	    // Perform concrete-hasher logic
	    this._doReset();
	  },

	  update: function (messageUpdate) {
	    if (typeof messageUpdate == 'string')
	      messageUpdate = WordArray.fromBuffer(new Buffer(messageUpdate, 'utf8'))

	    if (Buffer.isBuffer(messageUpdate))
	      messageUpdate = WordArray.fromBuffer(messageUpdate)

	    // Append
	    this._append(messageUpdate);

	    // Update the hash
	    this._process();

	    // Chainable
	    return this;
	  },

	  finalize: function (messageUpdate) {
	    if (typeof messageUpdate == 'string')
	      messageUpdate = WordArray.fromBuffer(new Buffer(messageUpdate, 'utf8'))

	    if (Buffer.isBuffer(messageUpdate))
	      messageUpdate = WordArray.fromBuffer(messageUpdate)


	    // Final message update
	    if (messageUpdate) {
	      this._append(messageUpdate);
	    }

	    // Perform concrete-hasher logic
	    var hash = this._doFinalize();

	    return hash.toBuffer()
	  },

	  blockSize: 512/32,

	  /** TODO: DELETE
	   * Creates a shortcut function to a hasher's object interface.
	   * @example
	   *
	   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	   */
	  _createHelper: function (hasher) {
	    return function (message, cfg) {
	      return new hasher.init(cfg).finalize(message);
	    };
	  }

	});

	module.exports.Hasher = Hasher


	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var sha512 = __webpack_require__(64).sha512
	var WordArray = __webpack_require__(45)

	function HMAC(key) {
	  if (!(this instanceof HMAC))
	    return new HMAC(key)

	  // Init hasher
	  var hasher = this._hasher = new sha512.init()//new hasher.init();

	  // Convert string to WordArray, else assume WordArray already
	  if (typeof key == 'string') {
	    key = WordArray.fromBuffer(new Buffer(key, 'utf8'));
	  }

	  if (Buffer.isBuffer(key)) {
	    key = WordArray.fromBuffer(key)
	  }

	  // Shortcuts
	  var hasherBlockSize = hasher.blockSize;
	  var hasherBlockSizeBytes = hasherBlockSize * 4;

	  // Allow arbitrary length keys
	  if (key.sigBytes > hasherBlockSizeBytes) {
	      key = hasher.finalize(key);
	  }

	  // Clamp excess bits
	  key.clamp();

	  // Clone key for inner and outer pads
	  var oKey = this._oKey = key.clone();
	  var iKey = this._iKey = key.clone();

	  // Shortcuts
	  var oKeyWords = oKey.words;
	  var iKeyWords = iKey.words;

	  // XOR keys with pad constants
	  for (var i = 0; i < hasherBlockSize; i++) {
	    oKeyWords[i] ^= 0x5c5c5c5c;
	    iKeyWords[i] ^= 0x36363636;
	  }
	  oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	  // Set initial values
	  this.reset();
	}

	HMAC.prototype.reset = function () {
	  // Shortcut
	  var hasher = this._hasher;

	  // Reset
	  hasher.reset();
	  hasher.update(this._iKey);
	}

	HMAC.prototype.update = function (messageUpdate) {
	  if (typeof messageUpdate == 'string')
	    messageUpdate = WordArray.fromBuffer(new Buffer(messageUpdate, 'utf8'))

	  if (Buffer.isBuffer(messageUpdate))
	    messageUpdate = WordArray.fromBuffer(messageUpdate)

	  this._hasher.update(messageUpdate);

	  // Chainable
	  return this;
	}

	HMAC.prototype.finalize = function (messageUpdate) {
	   if (typeof messageUpdate == 'string')
	    messageUpdate = WordArray.fromBuffer(new Buffer(messageUpdate, 'utf8'))

	  if (Buffer.isBuffer(messageUpdate))
	    messageUpdate = WordArray.fromBuffer(messageUpdate)

	  // Shortcut
	  var hasher = this._hasher;

	  // Compute HMAC
	  var innerHash = hasher.finalize(messageUpdate);
	  hasher.reset();
	  var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	  return hmac;
	}
	  

	module.exports = HMAC
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(64)
	module.exports.hmac = __webpack_require__(105)

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var X32WordArray = __webpack_require__(45)


	function X64Word(high, low) {
	  if (!(this instanceof X64Word)) return new X64Word(high, low)
	  this.high = high
	  this.low = low
	}

	function X64WordArray (words) {
	  this.words = words || [];
	}

	/**
	 * Converts this 64-bit word array to a 32-bit word array.
	 */
	X64WordArray.prototype.toX32 = function () {
	  // Shortcuts
	  var x64Words = this.words;
	  var x64WordsLength = x64Words.length;

	  // Convert
	  var x32Words = [];
	  for (var i = 0; i < x64WordsLength; i++) {
	      var x64Word = x64Words[i];
	      x32Words.push(x64Word.high);
	      x32Words.push(x64Word.low);
	  }

	  return new X32WordArray(x32Words, this.sigBytes);
	}


	module.exports.Word = X64Word
	module.exports.WordArray = X64WordArray



/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {function BufferPut () {
	  this.words = [];
	  this.len = 0;
	};
	module.exports = BufferPut;

	BufferPut.prototype.put = function(buf) {
	  this.words.push({buffer: buf});
	  this.len += buf.length;
	  return this;
	};

	BufferPut.prototype.word8 = function(x) {
	  this.words.push({bytes: 1, value: x});
	  this.len += 1;
	  return this;
	};

	BufferPut.prototype.floatle = function(x) {
	  this.words.push({bytes: 'float', endian: 'little', value: x});
	  this.len += 4;
	  return this;
	};

	BufferPut.prototype.varint = function(i) {
	  if(i < 0xFD) {
	    this.word8(i);
	  } else if(i <= 1<<16) {
	    this.word8(0xFD);
	    this.word16le(i);
	  } else if(i <= 1<<32) {
	    this.word8(0xFE);
	    this.word32le(i);
	  } else {
	    this.word8(0xFF);
	    this.word64le(i);
	  }
	};

	[8, 16, 24, 32, 64].forEach(function(bits) {
	  BufferPut.prototype['word'+bits+'be'] = function(x) {
	    this.words.push({endian: 'big', bytes: bits / 8, value: x});
	    this.len += bits / 8;
	    return this;
	  };

	  BufferPut.prototype['word'+bits+'le'] = function(x) {
	    this.words.push({endian: 'little', bytes: bits / 8, value: x});
	    this.len += bits / 8;
	    return this;
	  };
	});

	BufferPut.prototype.pad = function(bytes) {
	  this.words.push({endian: 'big', bytes: bytes, value: 0});
	  this.len += bytes;
	  return this;
	};

	BufferPut.prototype.length = function() {
	  return this.len;
	};

	BufferPut.prototype.buffer = function () {
	  var buf = new Buffer(this.len);
	  var offset = 0;
	  this.words.forEach(function(word) {
	    if(word.buffer) {
	      word.buffer.copy(buf, offset, 0);
	      offset += word.buffer.length;
	    } else if(word.bytes == 'float') {
	      // s * f * 2^e
	      var v = Math.abs(word.value);
	      var s = (word.value >= 0) * 1;
	      var e = Math.ceil(Math.log(v) / Math.LN2);
	      var f = v / (1 << e);

	      // s:1, e:7, f:23
	      // [seeeeeee][efffffff][ffffffff][ffffffff]
	      buf[offset++] = (s << 7) & ~~(e / 2);
	      buf[offset++] = ((e & 1) << 7) & ~~(f / (1 << 16));
	      buf[offset++] = 0;
	      buf[offset++] = 0;
	      offset += 4;
	    } else {
	      var big = word.endian === 'big';
	      var ix = big ? [ (word.bytes - 1) * 8, -8 ] : [ 0, 8 ];
	      for(var i=ix[0]; big ? i >= 0 : i < word.bytes * 8; i += ix[1]) {
	        if(i >= 32) {
	          buf[offset++] = Math.floor(word.value / Math.pow(2, i)) & 0xff;
	        } else {
	          buf[offset++] = (word.value >> i) & 0xff;
	        }
	      }
	    }
	  });
	  return buf;
	};

	BufferPut.prototype.write = function(stream) {
	  stream.write(this.buffer());
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/**
	 * @author Matthew Caruana Galizia <m@m.cg>
	 * @license MIT
	 * @copyright Copyright (c) 2013, Matthew Caruana Galizia
	 * @preserve
	 *
	 * Portions of this code are copyright (c) 2011 Valentin Háloiu, redistributed and modified under the following license (MIT).
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */

	'use strict';

	/*jshint node:true*/

	var net = __webpack_require__(66);
	var EventEmitter = __webpack_require__(26).EventEmitter;
	var inherits = __webpack_require__(16).inherits;

	var htons = __webpack_require__(114).htons;
	var ipv6 = __webpack_require__(110).v6;

	module.exports = exports = Socks5ClientSocket;

	exports.createConnection = function(options) {
		var socksSocket, socksHost, socksPort;

		socksHost = options.socksHost || 'localhost';
		socksPort = options.socksPort || 1080;
		socksSocket = new Socks5ClientSocket(socksHost, socksPort);

		return socksSocket.connect(options.port, options.host);
	};

	function Socks5ClientSocket(socksHost, socksPort) {
		var self = this;

		EventEmitter.call(self);

		self.socket = new net.Socket();
		self.socksHost = socksHost;
		self.socksPort = socksPort;

		self.socket.on('error', function(err) {
			self.emit('error', err);
		});

		self.on('error', function(err) {
			if (!self.socket.destroyed) {
				self.socket.destroy();
			}
		});
	}

	inherits(Socks5ClientSocket, EventEmitter);

	Socks5ClientSocket.prototype.setTimeout = function(msecs, callback) {
		return this.socket.setTimeout(msecs, callback);
	};

	Socks5ClientSocket.prototype.setNoDelay = function() {
		return this.socket.setNoDelay();
	};

	Socks5ClientSocket.prototype.setKeepAlive = function(setting, msecs) {
		return this.socket.setKeepAlive(setting, msecs);
	};

	Socks5ClientSocket.prototype.address = function() {
		return this.socket.address();
	};

	Socks5ClientSocket.prototype.pause = function() {
		return this.socket.pause();
	};

	Socks5ClientSocket.prototype.resume = function() {
		return this.socket.resume();
	};

	Socks5ClientSocket.prototype.end = function(data, encoding) {
		return this.socket.end(data, encoding);
	};

	Socks5ClientSocket.prototype.destroy = function(exception) {
		return this.socket.destroy(exception);
	};

	Socks5ClientSocket.prototype.destroySoon = function() {
		var ret = this.socket.destroySoon();

		this.writable = false; // node's http library asserts writable to be false after destroySoon

		return ret;
	};

	Socks5ClientSocket.prototype.setEncoding = function(encoding) {
		return this.socket.setEncoding(encoding);
	};

	Socks5ClientSocket.prototype.write = function(data, arg1, arg2) {
		return this.socket.write(data, arg1, arg2);
	};

	Socks5ClientSocket.prototype.connect = function(port, host) {
		var self = this;

		self.socket.connect(self.socksPort, self.socksHost, function() {
			self.establishSocksConnection(host, port);
		});

		return self;
	};

	Socks5ClientSocket.prototype.handleSocksConnectToHost = function() {
		var self = this;

		self.socket.on('close', function(hadError) {
			self.emit('close', hadError);
		});

		self.socket.on('end', function() {
			self.emit('end');
		});

		self.socket.on('data', function(data) {
			self.emit('data', data);
		});

		self.socket._httpMessage = self._httpMessage;
		self.socket.parser = self.parser;
		self.socket.ondata = self.ondata;
		self.writable = true;
		self.readable = true;
		self.emit('connect');
	};

	Socks5ClientSocket.prototype.establishSocksConnection = function(host, port) {
		var self = this;

		self.authenticateWithSocks(function() {
			self.connectSocksToHost(host, port, function() {
				self.handleSocksConnectToHost();
			});
		});
	};

	Socks5ClientSocket.prototype.authenticateWithSocks = function(cb) {
		var request, self = this;

		self.socket.ondata = function(d, start, end) {
			var error;

			if (end - start !== 2) {
				error = new Error('SOCKS authentication failed. Unexpected number of bytes received.');
			} else if (d[start] !== 0x05) {
				error = new Error('SOCKS authentication failed. Unexpected SOCKS version number: ' + d[start] + '.');
			} else if (d[start + 1] !== 0x00) {
				error = new Error('SOCKS authentication failed. Unexpected SOCKS authentication method: ' + d[start+1] + '.');
			}

			if (error) {
				self.emit('error', error);
				return;
			}

			if (cb) {
				cb();
			}
		};

		request = new Buffer(3);
		request[0] = 0x05;  // SOCKS version
		request[1] = 0x01;  // number of authentication methods
		request[2] = 0x00;  // no authentication
		self.socket.write(request);
	};

	Socks5ClientSocket.prototype.connectSocksToHost = function(host, port, cb) {
		var buffer, request, self = this;

		this.socket.ondata = function(d, start, end) {
			var i, address, addressLength, error;

			if (d[start] !== 0x05) {
				error = new Error('SOCKS connection failed. Unexpected SOCKS version number: ' + d[start] + '.');
			} else if (d[start + 1] !== 0x00) {
				error = new Error('SOCKS connection failed. ' + getErrorMessage(d[start + 1]) + '.');
			} else if (d[start + 2] !== 0x00) {
				error = new Error('SOCKS connection failed. The reserved byte must be 0x00.');
			}

			if (error) {
				self.emit('error', error);
				return;
			}

			address = '';
			addressLength = 0;

			switch (d[start + 3]) {
				case 1:
					address = d[start + 4] + '.' + d[start + 5] + '.' + d[start + 6] + '.' + d[start + 7];
					addressLength = 4;
					break;
				case 3:
					addressLength = d[start + 4] + 1;
					for (i = start + 5; i < start + addressLength; i++) {
						address += String.fromCharCode(d[i]);
					}
					break;
				case 4:
					addressLength = 16;
					break;
				default:
					self.emit('error', new Error('SOCKS connection failed. Unknown addres type: ' + d[start + 3] + '.'));
					return;
			}

			if (cb) {
				cb();
			}
		};

		buffer = [];
		buffer.push(0x05); // SOCKS version
		buffer.push(0x01); // Command code: establish a TCP/IP stream connection
		buffer.push(0x00); // Reserved - myst be 0x00

		switch (net.isIP(host)) {
			case 0:
				buffer.push(0x03);
				parseDomainName(host, buffer);
				break;
			case 4:
				buffer.push(0x01);
				parseIPv4(host, buffer);
				break;
			case 6:
				buffer.push(0x04);
				if (parseIPv6(host, buffer) === false) {
					self.emit('error', new Error('IPv6 host parsing failed. Invalid address.'));
					return;
				}
				break;
		}

		parsePort(port, buffer);

		request = new Buffer(buffer);
		this.socket.write(request);
	};

	function parseIPv4(host, buffer) {
		var i, ip, groups = host.split('.');

		for (i = 0; i < groups.length; i++) {
			ip = parseInt(groups[i], 10);
			buffer.push(ip);
		}
	}

	function parseIPv6(host, buffer) {
		var i, b1, b2, part1, part2, address, groups;

		address = new ipv6.Address(host).canonicalForm();
		if (!address) {
			return false;
		}

		groups = address.split(':');

		for (i = 0; i < groups.length; i++) {
			part1 = groups[i].substr(0,2);
			part2 = groups[i].substr(2,2);

			b1 = parseInt(part1, 16);
			b2 = parseInt(part2, 16);

			buffer.push(b1);
			buffer.push(b2);
		}

		return true;
	}

	function parseDomainName(host, buffer) {
		var i, c;

		buffer.push(host.length);
		for (i = 0; i < host.length; i++) {
			c = host.charCodeAt(i);
			buffer.push(c);
		}
	}

	function parsePort(port, buffer) {
		htons(buffer, buffer.length, port);
	}

	function getErrorMessage(code) {
		switch (code) {
			case 1:
				return 'General SOCKS server failure';
			case 2:
				return 'Connection not allowed by ruleset';
			case 3:
				return 'Network unreachable';
			case 4:
				return 'Host unreachable';
			case 5:
				return 'Connection refused';
			case 6:
				return 'TTL expired';
			case 7:
				return 'Command not supported';
			case 8:
				return 'Address type not supported';
			default:
				return 'Unknown status code ' + code;
		}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(111);

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	if (true) {
	  var sprintf = __webpack_require__(113).sprintf;
	  var BigInteger = __webpack_require__(112).BigInteger;
	}

	var v4 = this.v4 = {};
	var v6 = this.v6 = {};

	v4.GROUPS = 4;
	v6.GROUPS = 8;

	v4.BITS = 32;
	v6.BITS = 128;

	v6.SCOPES = {
	  0: 'Reserved',
	  1: 'Interface local',
	  2: 'Link local',
	  4: 'Admin local',
	  5: 'Site local',
	  8: 'Organization local',
	  15: 'Global',
	  16: 'Reserved'
	};

	v4.RE_ADDRESS = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
	v4.RE_SUBNET_STRING = /\/\d{1,2}$/;

	v6.RE_BAD_CHARACTERS = /([^0-9a-f:\/%])/ig;
	v6.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/ig;

	v6.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
	v6.RE_ZONE_STRING = /%.*$/;

	v6.RE_URL = new RegExp(/([0-9a-f:]+)/);
	v6.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);

	// Convenience functions
	function map(array, fn) {
	  var results = [];
	  var i;

	  for (i = 0; i < array.length; i++) {
	    results.push(fn(array[i], i));
	  }

	  return results;
	}

	function repeatString(s, n) {
	  var result = '';
	  var i;

	  for (i = 0; i < n; i++) {
	    result += s;
	  }

	  return result;
	}

	function addCommas(number) {
	  var r = /(\d+)(\d{3})/;

	  while (r.test(number)) {
	    number = number.replace(r, '$1,$2');
	  }

	  return number;
	}

	function spanLeadingZeroesSimple(group) {
	  return group.replace(/^(0+)/, '<span class="zero">$1</span>');
	}

	function spanLeadingZeroes4(n) {
	  n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
	  n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');

	  return n;
	}

	function simpleRegularExpression(addressArray) {
	  var output = [];
	  var i;

	  for (i = 0; i < addressArray.length; i++) {
	    var segment = addressArray[i];

	    if (segment.length < 4) {
	      output.push(sprintf('0{0,%d}%s', 4 - segment.length, segment));
	    } else {
	      output.push(segment);
	    }
	  }

	  return output.join(':');
	}

	function zeroPad(s, n) {
	  return String(repeatString(0, n) + s).slice(n * -1);
	}

	function isInSubnet(address) {
	  // XXX: This is a hunch
	  if (this.subnetMask < address.subnetMask) {
	    return false;
	  }

	  if (this.mask(address.subnetMask) === address.mask()) {
	    return true;
	  }

	  return false;
	}

	/*
	 * Instantiates an IPv4 address
	 */
	v4.Address = function (address) {
	  this.valid = false;
	  this.address = address;
	  this.groups = v4.GROUPS;

	  this.v4 = true;

	  this.subnet = '/32';
	  this.subnetMask = 32;

	  var subnet = v4.RE_SUBNET_STRING.exec(address);

	  if (subnet) {
	    this.parsedSubnet = subnet[0].replace('/', '');
	    this.subnetMask = parseInt(this.parsedSubnet, 10);
	    this.subnet = '/' + this.subnetMask;

	    if (this.subnetMask < 0 || this.subnetMask > v4.BITS) {
	      this.valid = false;
	      this.error = "Invalid subnet mask.";

	      return;
	    }

	    address = address.replace(v4.RE_SUBNET_STRING, '');
	  }

	  this.addressMinusSuffix = address;

	  this.parsedAddress = this.parse(address);
	};

	/*
	 * Parses a v4 address
	 */
	v4.Address.prototype.parse = function (address) {
	  var groups = address.split('.');

	  if (address.match(v4.RE_ADDRESS)) {
	    this.valid = true;
	  } else {
	    this.error = 'Invalid IPv4 address.';
	  }

	  return groups;
	};

	/*
	 * Returns true if the address is valid
	 */
	v4.Address.prototype.isValid = function () {
	  return this.valid;
	};

	/*
	 * Returns the correct form of an address
	 */
	v4.Address.prototype.correctForm = function () {
	  return this.parsedAddress.map(function (part) {
	    return parseInt(part, 10);
	  }).join('.');
	};

	/*
	 * Returns true if the address is correct, false otherwise
	 */
	v4.Address.prototype.isCorrect = function () {
	  return this.addressMinusSuffix === this.correctForm() &&
	    (this.subnetMask === 32 ||
	      this.parsedSubnet === String(this.subnet.replace('/')));
	};

	/*
	 * Converts a hex string to an IPv4 address object
	 */
	v4.Address.fromHex = function (hex) {
	  var padded = zeroPad(hex.replace(/:/g, ''), 8);
	  var groups = [];
	  var i;

	  for (i = 0; i < 8; i += 2) {
	    var h = padded.slice(i, i + 2);

	    groups.push(parseInt(h, 16));
	  }

	  return new v4.Address(groups.join('.'));
	};

	/*
	 * Converts an integer into a IPv4 address object
	 */
	v4.Address.fromInteger = function (integer) {
	  return v4.Address.fromHex(integer.toString(16));
	};

	/*
	 * Converts an IPv4 address object to a hex string
	 */
	v4.Address.prototype.toHex = function () {
	  return this.parsedAddress.map(function (part) {
	    return sprintf('%02x', parseInt(part, 10));
	  }).join(':');
	};

	/*
	 * Converts an IPv4 address object to an array of bytes
	 */
	v4.Address.prototype.toArray = function () {
	  return this.parsedAddress.map(function (part) {
	    return parseInt(part, 10);
	  });
	};

	/*
	 * Converts an IPv4 address object to an IPv6 address group
	 */
	v4.Address.prototype.toV6Group = function () {
	  var output = [];
	  var i;

	  for (i = 0; i < v4.GROUPS; i += 2) {
	    var hex = sprintf('%02x%02x',
	      parseInt(this.parsedAddress[i], 10),
	      parseInt(this.parsedAddress[i + 1], 10));

	    output.push(sprintf('%x', parseInt(hex, 16)));
	  }

	  return output.join(':');
	};

	/*
	 * Returns the address as a BigInteger
	 */
	v4.Address.prototype.bigInteger = function () {
	  if (!this.valid) {
	    return;
	  }

	  return new BigInteger(map(this.parsedAddress, function (n) {
	    return sprintf("%02x", parseInt(n, 10));
	  }).join(''), 16);
	};

	/*
	 * The first address in the range given by this address' subnet.
	 * Often referred to as the Network Address.
	 */
	v4.Address.prototype.startAddress = function () {
	  var startAddress = new BigInteger(this.mask() + repeatString(0,
	    v4.BITS - this.subnetMask), 2);

	  return v4.Address.fromBigInteger(startAddress);
	};

	/*
	 * The last address in the range given by this address' subnet
	 * Often referred to as the Broadcast
	 */
	v4.Address.prototype.endAddress = function () {
	  var endAddress = new BigInteger(this.mask() + repeatString(1,
	    v4.BITS - this.subnetMask), 2);

	  return v4.Address.fromBigInteger(endAddress);
	};

	/*
	 * Converts a BigInteger to a v4 address object
	 */
	v4.Address.fromBigInteger = function (bigInteger) {
	  return v4.Address.fromInteger(parseInt(bigInteger.toString(), 10));
	};

	/*
	 * Returns the first n bits of the address, defaulting to the
	 * subnet mask
	 */
	v4.Address.prototype.mask = function (opt_mask) {
	  if (opt_mask === undefined) {
	    opt_mask = this.subnetMask;
	  }

	  return this.getBitsBase2(0, opt_mask);
	};

	/*
	 * Returns the bits in the given range as a base-2 string
	 */
	v4.Address.prototype.getBitsBase2 = function (start, end) {
	  return this.binaryZeroPad().slice(start, end);
	};

	/*
	 * Returns true if the given address is in the subnet of the current address
	 */
	v4.Address.prototype.isInSubnet = isInSubnet;

	/*
	 * Returns a zero-padded base-2 string representation of the address
	 */
	v4.Address.prototype.binaryZeroPad = function () {
	  return zeroPad(this.bigInteger().toString(2), v4.BITS);
	};

	/*
	 * Instantiates an IPv6 address
	 */
	v6.Address = function (address, opt_groups) {
	  if (opt_groups === undefined) {
	    this.groups = v6.GROUPS;
	  } else {
	    this.groups = opt_groups;
	  }

	  this.v4 = false;

	  this.subnet = '/128';
	  this.subnetMask = 128;

	  this.zone = '';

	  this.address = address;

	  var subnet = v6.RE_SUBNET_STRING.exec(address);

	  if (subnet) {
	    this.parsedSubnet = subnet[0].replace('/', '');
	    this.subnetMask = parseInt(this.parsedSubnet, 10);
	    this.subnet = '/' + this.subnetMask;

	    if (isNaN(this.subnetMask) ||
	      this.subnetMask < 0 ||
	      this.subnetMask > v6.BITS) {
	      this.valid = false;
	      this.error = "Invalid subnet mask.";

	      return;
	    }

	    address = address.replace(v6.RE_SUBNET_STRING, '');
	  } else if (/\//.test(address)) {
	    this.valid = false;
	    this.error = "Invalid subnet mask.";

	    return;
	  }

	  var zone = v6.RE_ZONE_STRING.exec(address);

	  if (zone) {
	    this.zone = zone[0];

	    address = address.replace(v6.RE_ZONE_STRING, '');
	  }

	  this.addressMinusSuffix = address;

	  this.parsedAddress = this.parse(this.addressMinusSuffix);
	};

	/*
	 * Converts a BigInteger to a v6 address object
	 */
	v6.Address.fromBigInteger = function (bigInteger) {
	  var hex = zeroPad(bigInteger.toString(16), 32);
	  var groups = [];
	  var i;

	  for (i = 0; i < 8; i++) {
	    groups.push(hex.slice(i * 4, (i + 1) * 4));
	  }

	  return new v6.Address(groups.join(':'));
	};

	/*
	 * Converts a URL (optional port number) to an address object
	 */
	v6.Address.fromURL = function (url) {
	  var host;
	  var port;
	  var result;

	  // If we have brackets parse them and find a port
	  if (url.indexOf('[') !== -1 && url.indexOf(']') !== -1) {
	    result = v6.RE_URL_WITH_PORT.exec(url);

	    if (result === null) {
	      return {
	        error: 'failed to parse address with port',
	        address: null,
	        port: null
	      };
	    }

	    host = result[1];
	    port = result[2];
	  // If there's a URL extract the address
	  } else if (url.indexOf('/') !== -1) {
	    // Remove the protocol prefix
	    url = url.replace(/^[a-z0-9]+:\/\//, '');

	    // Parse the address
	    result = v6.RE_URL.exec(url);

	    if (result === null) {
	      return {
	        error: 'failed to parse address from URL',
	        address: null,
	        port: null
	      };
	    }

	    host = result[1];
	  // Otherwise just assign the URL to the host and let the library parse it
	  } else {
	    host = url;
	  }

	  // If there's a port convert it to an integer
	  if (port) {
	    port = parseInt(port, 10);

	    //squelch out of range ports
	    if (port < 0 || port > 65536) {
	      port = null;
	    }
	  } else {
	    // Standardize `undefined` to `null`
	    port = null;
	  }

	  return {
	    address: new v6.Address(host),
	    port: port
	  };
	};

	/*
	 * A helper function to compact an array
	 */
	v6.Address.compact = function (address, slice) {
	  var s1 = [];
	  var s2 = [];
	  var i;

	  for (i = 0; i < address.length; i++) {
	    if (i < slice[0]) {
	      s1.push(address[i]);
	    } else if (i > slice[1]) {
	      s2.push(address[i]);
	    }
	  }

	  return s1.concat(['compact']).concat(s2);
	};

	/*
	 * Returns true if the address is valid, false otherwise
	 */
	v6.Address.prototype.isValid = function () {
	  return this.valid;
	};

	/*
	 * Returns true if the address is correct, false otherwise
	 */
	v6.Address.prototype.isCorrect = function () {
	  return this.addressMinusSuffix === this.correctForm() &&
	    (this.subnetMask === 128 ||
	      this.parsedSubnet === String(this.subnet.replace('/')));
	};

	/*
	 * Returns true if the address is a link local address, false otherwise
	 */
	v6.Address.prototype.isLinkLocal = function () {
	  // Zeroes are required, i.e. we can't check isInSubnet with 'fe80::/10'
	  if (this.getBitsBase2(0, 64) ===
	    "1111111010000000000000000000000000000000000000000000000000000000") {
	    return true;
	  }

	  return false;
	};

	/*
	 * Returns true if the address is in the canonical form, false otherwise
	 */
	v6.Address.prototype.isCanonical = function () {
	  return this.addressMinusSuffix === this.canonicalForm();
	};

	/*
	 * Returns true if the address is a multicast address, false otherwise
	 */
	v6.Address.prototype.isMulticast = function () {
	  return this.getType() === 'Multicast';
	};

	/*
	 * Returns true if the address is a v4-in-v6 address, false otherwise
	 */
	v6.Address.prototype.is4 = function () {
	  return this.v4;
	};

	/*
	 * Returns true if the address is a Teredo address, false otherwise
	 */
	v6.Address.prototype.isTeredo = function () {
	  if (this.isInSubnet(new v6.Address('2001::/32'))) {
	    return true;
	  }

	  return false;
	};

	/*
	 * Returns true if the address is a 6to4 address, false otherwise
	 */
	v6.Address.prototype.is6to4 = function () {
	  if (this.isInSubnet(new v6.Address('2002::/16'))) {
	    return true;
	  }

	  return false;
	};

	/*
	 * Returns true if the address is a loopback address, false otherwise
	 */
	v6.Address.prototype.isLoopback = function () {
	  return this.getType() === 'Loopback';
	};

	/*
	 * Returns the Microsoft UNC transcription of the address
	 */
	v6.Address.prototype.microsoftTranscription = function () {
	  return sprintf('%s.ipv6-literal.net',
	    this.correctForm().replace(/:/g, '-'));
	};

	/*
	 * Returns the address in link form with a default port of 80
	 */
	v6.Address.prototype.href = function (opt_port) {
	  if (opt_port === undefined) {
	    opt_port = '';
	  } else {
	    opt_port = sprintf(':%s', opt_port);
	  }

	  return sprintf('http://[%s]%s/', this.correctForm(), opt_port);
	};

	/*
	 * Returns the first n bits of the address, defaulting to the
	 * subnet mask
	 */
	v6.Address.prototype.mask = function (opt_mask) {
	  if (opt_mask === undefined) {
	    opt_mask = this.subnetMask;
	  }

	  return this.getBitsBase2(0, opt_mask);
	};

	/*
	 * Returns a link suitable for conveying the address via a URL hash
	 */
	v6.Address.prototype.link = function (options) {
	  if (!options) {
	    options = {};
	  }

	  if (options.className === undefined) {
	    options.className = '';
	  }

	  if (options.prefix === undefined) {
	    options.prefix = '/#address=';
	  }

	  if (options.v4 === undefined) {
	    options.v4 = false;
	  }

	  var formFunction = this.correctForm;

	  if (options.v4) {
	    formFunction = this.v4inv6;
	  }

	  if (options.className) {
	    return sprintf('<a href="%1$s%2$s" class="%3$s">%2$s</a>',
	      options.prefix, formFunction.call(this), options.className);
	  }

	  return sprintf('<a href="%1$s%2$s">%2$s</a>', options.prefix,
	    formFunction.call(this));
	};

	/*
	 * Returns the number of possible subnets of a given size in the address
	 */
	v6.Address.prototype.possibleAddresses = function (opt_subnetSize) {
	  if (opt_subnetSize === undefined) {
	    opt_subnetSize = 0;
	  }

	  return addCommas(new BigInteger('2', 10).pow((v6.BITS - this.subnetMask) -
	    (v6.BITS - opt_subnetSize)).toString(10));
	};

	/*
	 * Returns true if the given address is in the subnet of the current address
	 */
	v6.Address.prototype.isInSubnet = isInSubnet;

	/*
	 * Create an IPv6-mapped address given an IPv4 address
	 */
	v6.Address.fromAddress4 = function (address4) {
	  return new v6.Address('::ffff:' + address4);
	};

	/*
	 * The first address in the range given by this address' subnet
	 */
	v6.Address.prototype.startAddress = function () {
	  var startAddress = new BigInteger(this.mask() + repeatString(0,
	    v6.BITS - this.subnetMask), 2);

	  return v6.Address.fromBigInteger(startAddress);
	};

	/*
	 * The last address in the range given by this address' subnet
	 */
	v6.Address.prototype.endAddress = function () {
	  var endAddress = new BigInteger(this.mask() + repeatString(1,
	    v6.BITS - this.subnetMask), 2);

	  return v6.Address.fromBigInteger(endAddress);
	};

	/*
	 * Returns the scope of the address
	 */
	v6.Address.prototype.getScope = function () {
	  var scope = v6.SCOPES[this.getBits(12, 16)];

	  if (this.getType() === "Global unicast") {
	    if (scope !== "Link local") {
	      scope = "Global";
	    }
	  }

	  return scope;
	};

	/*
	 * Returns the type of the address
	 */
	v6.Address.prototype.getType = function () {
	  // TODO: Refactor this
	  // TODO: Add ff0x::fb, etc. for multicast DNS
	  var TYPES = {
	    'ff01::1/128': 'Multicast (All nodes on this interface)',
	    'ff01::2/128': 'Multicast (All routers on this interface)',
	    'ff02::1/128': 'Multicast (All nodes on this link)',
	    'ff02::2/128': 'Multicast (All routers on this link)',
	    'ff05::2/128': 'Multicast (All routers in this site)',
	    'ff02::5/128': 'Multicast (OSPFv3 AllSPF routers)',
	    'ff02::6/128': 'Multicast (OSPFv3 AllDR routers)',
	    'ff02::9/128': 'Multicast (RIP routers)',
	    'ff02::a/128': 'Multicast (EIGRP routers)',
	    'ff02::d/128': 'Multicast (PIM routers)',
	    'ff02::16/128': 'Multicast (MLDv2 reports)',
	    'ff01::fb/128': 'Multicast (mDNSv6)',
	    'ff02::fb/128': 'Multicast (mDNSv6)',
	    'ff05::fb/128': 'Multicast (mDNSv6)',
	    'ff02::1:2/128': 'Multicast (All DHCP servers and relay agents on this link)',
	    'ff05::1:2/128': 'Multicast (All DHCP servers and relay agents in this site)',
	    'ff02::1:3/128': 'Multicast (All DHCP servers on this link)',
	    'ff05::1:3/128': 'Multicast (All DHCP servers in this site)',
	    '::/128': 'Unspecified',
	    '::1/128': 'Loopback',
	    'ff00::/8': 'Multicast',
	    'fe80::/10': 'Link-local unicast'
	  };

	  var type = 'Global unicast';
	  var p;

	  for (p in TYPES) {
	    if (TYPES.hasOwnProperty(p)) {
	      if (this.isInSubnet(new v6.Address(p))) {
	        type = TYPES[p];

	        break;
	      }
	    }
	  }

	  return type;
	};

	/*
	 * Returns the bits in the given range as a BigInteger
	 */
	v6.Address.prototype.getBits = function (start, end) {
	  return new BigInteger(this.getBitsBase2(start, end), 2);
	};

	/*
	 * Returns the bits in the given range as a base-2 string
	 */
	v6.Address.prototype.getBitsBase2 = function (start, end) {
	  return this.binaryZeroPad().slice(start, end);
	};

	/*
	 * Returns the bits in the given range as a base-16 string
	 */
	v6.Address.prototype.getBitsBase16 = function (start, end) {
	  var length = end - start;

	  if (length % 4 !== 0) {
	    return;
	  }

	  return zeroPad(this.getBits(start, end).toString(16), length / 4);
	};

	/*
	 * Returns the bits that are set past the subnet mask length
	 */
	v6.Address.prototype.getBitsPastSubnet = function () {
	  return this.getBitsBase2(this.subnetMask, v6.BITS);
	};

	/*
	 * Returns the string with each character contained in a <span>
	 */
	v6.Address.spanAll = function (s, opt_offset) {
	  if (opt_offset === undefined) {
	    opt_offset = 0;
	  }

	  var letters = s.split('');

	  return map(letters, function (n, i) {
	    return sprintf('<span class="digit value-%s position-%d">%s</span>', n,
	      i + opt_offset,
	      v6.Address.spanAllZeroes(n)); // XXX Use #base-2 .value-0 instead?
	  }).join('');
	};

	/*
	 * Returns the string with all zeroes contained in a <span>
	 */
	v6.Address.spanAllZeroes = function (s) {
	  return s.replace(/(0+)/g, '<span class="zero">$1</span>');
	};

	/*
	 * Returns the string with leading zeroes contained in a <span>
	 */
	v6.Address.spanLeadingZeroes = function (address) {
	  var groups = address.split(':');

	  groups = map(groups, function (g) {
	    return spanLeadingZeroesSimple(g);
	  });

	  return groups.join(':');
	};

	/*
	 * Groups an address
	 */
	v6.Address.simpleGroup = function (addressString, offset) {
	  var groups = addressString.split(':');

	  if (!offset) {
	    offset = 0;
	  }

	  groups = map(groups, function (g, i) {
	    if (/group-v4/.test(g)) {
	      return g;
	    }

	    return sprintf('<span class="hover-group group-%d">%s</span>',
	      i + offset,
	      spanLeadingZeroesSimple(g));
	  });

	  return groups.join(':');
	};

	/*
	 * Groups an address
	 */
	v6.Address.group = function (addressString) {
	  var address6 = new v6.Address(addressString);
	  var address4 = address6.address.match(v4.RE_ADDRESS);
	  var i;

	  if (address4) {
	    // The IPv4 case
	    var segments = address4[0].split('.');

	    address6.address = address6.address.replace(v4.RE_ADDRESS,
	      sprintf('<span class="hover-group group-v4 group-6">%s</span>' +
	        '.' +
	        '<span class="hover-group group-v4 group-7">%s</span>',
	        segments.slice(0, 2).join('.'),
	        segments.slice(2, 4).join('.')));
	  }

	  if (address6.elidedGroups === 0) {
	    // The simple case
	    return v6.Address.simpleGroup(address6.address);
	  }

	  // The elided case
	  var output = [];

	  var halves = address6.address.split('::');

	  if (halves[0].length) {
	    output.push(v6.Address.simpleGroup(halves[0]));
	  } else {
	    output.push('');
	  }

	  var classes = ['hover-group'];

	  for (i = address6.elisionBegin; i < address6.elisionBegin +
	    address6.elidedGroups; i++) {
	    classes.push(sprintf('group-%d', i));
	  }

	  output.push(sprintf('<span class="%s"></span>', classes.join(' ')));

	  if (halves[1].length) {
	    output.push(v6.Address.simpleGroup(halves[1], address6.elisionEnd));
	  } else {
	    output.push('');
	  }

	  return output.join(':');
	};

	/*
	 * Returns the reversed ip6.arpa form of the address
	 */
	v6.Address.prototype.reverseForm = function () {
	  var characters = Math.floor(this.subnetMask / 4);

	  var reversed = this.canonicalForm()
	    .replace(/:/g, '')
	    .split('')
	    .slice(0, characters)
	    .reverse()
	    .join('.');

	  if (characters > 0) {
	    return sprintf("%s.ip6.arpa.", reversed);
	  }

	  return 'ip6.arpa.';
	};

	/*
	 * Returns the correct form of the address
	 */
	v6.Address.prototype.correctForm = function () {
	  if (!this.parsedAddress) {
	    return;
	  }

	  var i;
	  var groups = [];

	  var zeroCounter = 0;
	  var zeroes = [];

	  for (i = 0; i < this.parsedAddress.length; i++) {
	    var value = parseInt(this.parsedAddress[i], 16);

	    if (value === 0) {
	      zeroCounter++;
	    }

	    if (value !== 0 && zeroCounter > 0) {
	      if (zeroCounter > 1) {
	        zeroes.push([i - zeroCounter, i - 1]);
	      }

	      zeroCounter = 0;
	    }
	  }

	  // Do we end with a string of zeroes?
	  if (zeroCounter > 1) {
	    zeroes.push([this.parsedAddress.length - zeroCounter,
	      this.parsedAddress.length - 1]);
	  }

	  var zeroLengths = map(zeroes, function (n) {
	    return (n[1] - n[0]) + 1;
	  });

	  if (zeroes.length > 0) {
	    var max = Math.max.apply(Math, zeroLengths);
	    var index = zeroLengths.indexOf(max);

	    groups = v6.Address.compact(this.parsedAddress, zeroes[index]);
	  } else {
	    groups = this.parsedAddress;
	  }

	  for (i = 0; i < groups.length; i++) {
	    if (groups[i] !== 'compact') {
	      groups[i] = parseInt(groups[i], 16).toString(16);
	    }
	  }

	  var correct = groups.join(':');

	  correct = correct.replace(/^compact$/, '::');
	  correct = correct.replace(/^compact|compact$/, ':');
	  correct = correct.replace(/compact/, '');

	  return correct;
	};

	/*
	 * Returns a zero-padded base-2 string representation of the address
	 */
	v6.Address.prototype.binaryZeroPad = function () {
	  return zeroPad(this.bigInteger().toString(2), v6.BITS);
	};

	// TODO: Improve the semantics of this helper function
	v6.Address.prototype.parse4in6 = function (address) {
	  var groups = address.split(':');
	  var lastGroup = groups.slice(-1)[0];

	  var address4 = lastGroup.match(v4.RE_ADDRESS);

	  if (address4) {
	    var temp4 = new v4.Address(address4[0]);

	    for (var i = 0; i < temp4.groups; i++) {
	      if (/^0[0-9]+/.test(temp4.parsedAddress[i])) {
	        this.valid = false;
	        this.error = 'IPv4 addresses can not have leading zeroes.';

	        this.parseError = address.replace(v4.RE_ADDRESS,
	          map(temp4.parsedAddress, spanLeadingZeroes4).join('.'));

	        return;
	      }
	    }

	    this.v4 = true;

	    groups[groups.length - 1] = temp4.toV6Group();

	    address = groups.join(':');
	  }

	  return address;
	};

	// TODO: Make private?
	v6.Address.prototype.parse = function (address) {
	  address = this.parse4in6(address);

	  if (this.error) {
	    return;
	  }

	  var badCharacters = address.match(v6.RE_BAD_CHARACTERS);

	  if (badCharacters) {
	    this.valid = false;
	    this.error = sprintf("Bad character%s detected in address: %s",
	      badCharacters.length > 1 ? 's' : '', badCharacters.join(''));

	    this.parseError = address.replace(v6.RE_BAD_CHARACTERS,
	      '<span class="parse-error">$1</span>');

	    return;
	  }

	  var badAddress = address.match(v6.RE_BAD_ADDRESS);

	  if (badAddress) {
	    this.valid = false;
	    this.error = sprintf("Address failed regex: %s", badAddress.join(''));

	    this.parseError = address.replace(v6.RE_BAD_ADDRESS,
	      '<span class="parse-error">$1</span>');

	    return;
	  }

	  var groups = [];

	  var halves = address.split('::');

	  if (halves.length === 2) {
	    var first = halves[0].split(':');
	    var last = halves[1].split(':');

	    if (first.length === 1 &&
	      first[0] === '') {
	      first = [];
	    }

	    if (last.length === 1 &&
	      last[0] === '') {
	      last = [];
	    }

	    var remaining = this.groups - (first.length + last.length);

	    if (!remaining) {
	      this.valid = false;
	      this.error = "Error parsing groups";

	      return;
	    }

	    this.elidedGroups = remaining;

	    this.elisionBegin = first.length;
	    this.elisionEnd = first.length + this.elidedGroups;

	    first.forEach(function (group) {
	      groups.push(group);
	    });

	    for (var i = 0; i < remaining; i++) {
	      groups.push(0);
	    }

	    last.forEach(function (group) {
	      groups.push(group);
	    });
	  } else if (halves.length === 1) {
	    groups = address.split(':');

	    this.elidedGroups = 0;
	  } else {
	    this.valid = false;
	    this.error = "Too many :: groups found";

	    return;
	  }

	  groups = map(groups, function (g) {
	    return sprintf('%x', parseInt(g, 16));
	  });

	  if (groups.length !== this.groups) {
	    this.valid = false;
	    this.error = "Incorrect number of groups found";

	    return;
	  }

	  groups.forEach(function (group, i) {
	    if (groups.length > 4 && !this.v4) {
	      this.valid = false;
	      this.error = sprintf("Group %d is too long", i + 1);

	      return;
	    }
	  });

	  this.valid = true;

	  return groups;
	};

	/*
	 * Generate a regular expression string that can be used to find or validate all
	 * variations of this address.
	 */
	v6.Address.prototype.regularExpressionString = function (opt_subString) {
	  if (opt_subString === undefined) {
	    opt_subString = false;
	  }

	  var i;
	  var output = [];

	  var address6 = new v6.Address(this.correctForm());

	  if (address6.elidedGroups === 0) {
	    // The simple case
	    output = simpleRegularExpression(address6.parsedAddress);
	  } else if (address6.elidedGroups === 8) {
	    output.push('::|');

	    // TODO: Validate this
	    for (i = 0; i < address6.elidedGroups; i++) {
	      var pipe = '|';

	      if (i === address6.elidedGroups - 1) {
	        pipe = '';
	      }

	      output.push(sprintf('(0{1,4}:){%d}:%s', address6.elidedGroups, pipe));
	    }
	  } else {
	    // The elided case

	    // TODO: Allow sloppy elision
	    // TODO: Compute all possible elisions
	    var halves = address6.address.split('::');

	    if (halves[0].length) {
	      output = output.concat(simpleRegularExpression(halves[0].split(':')));
	      output.push(':');
	    }

	    output.push(sprintf('((0{1,4}:){%d}|:)', address6.elidedGroups));

	    if (halves[1].length) {
	      output = output.concat(simpleRegularExpression(halves[1].split(':')));
	    }
	  }

	  if (!opt_subString) {
	    output = [].concat('\\b', output, '\\b');
	  }

	  return output.join('');
	};

	/*
	 * Generate a regular expression that can be used to find or validate all
	 * variations of this address.
	 */
	v6.Address.prototype.regularExpression = function () {
	  return new RegExp(this.regularExpressionString(), 'i');
	};

	/*
	 * Returns the canonical form of the address
	 */
	v6.Address.prototype.canonicalForm = function () {
	  if (!this.valid) {
	    return;
	  }

	  return map(this.parsedAddress, function (n) {
	    return sprintf("%04x", parseInt(n, 16));
	  }).join(':');
	};

	/*
	 * Returns the decimal form of the address
	 */
	v6.Address.prototype.decimal = function () {
	  if (!this.valid) {
	    return;
	  }

	  return map(this.parsedAddress, function (n) {
	    return sprintf("%05d", parseInt(n, 16));
	  }).join(':');
	};

	/*
	 * Returns the address as a BigInteger
	 */
	v6.Address.prototype.bigInteger = function () {
	  if (!this.valid) {
	    return;
	  }

	  return new BigInteger(map(this.parsedAddress, function (n) {
	    return sprintf("%04x", parseInt(n, 16));
	  }).join(''), 16);
	};

	/*
	 * Returns the v4-in-v6 form of the address
	 */
	v6.Address.prototype.v4inv6 = function () {
	  var binary = this.binaryZeroPad().split('');

	  var address4 = v4.Address.fromHex(new BigInteger(binary.slice(96, 128)
	    .join(''), 2).toString(16));
	  var address6 = new v6.Address(this.parsedAddress.slice(0, 6).join(':'), 6);

	  var correct = address6.correctForm();

	  var infix = '';

	  if (!/:$/.test(correct)) {
	    infix = ':';
	  }

	  return address6.correctForm() + infix + address4.address;
	};

	/*
	 * Returns an object containing the Teredo properties of the address
	 */
	v6.Address.prototype.teredo = function () {
	  /*
	  - Bits 0 to 31 are set to the Teredo prefix (normally 2001:0000::/32).
	  - Bits 32 to 63 embed the primary IPv4 address of the Teredo server that
	  is used.
	  - Bits 64 to 79 can be used to define some flags. Currently only the
	  higher order bit is used; it is set to 1 if the Teredo client is
	  located behind a cone NAT, 0 otherwise. For Microsoft's Windows Vista
	  and Windows Server 2008 implementations, more bits are used. In those
	  implementations, the format for these 16 bits is "CRAAAAUG AAAAAAAA",
	  where "C" remains the "Cone" flag. The "R" bit is reserved for future
	  use. The "U" bit is for the Universal/Local flag (set to 0). The "G" bit
	  is Individual/Group flag (set to 0). The A bits are set to a 12-bit
	  randomly generated number chosen by the Teredo client to introduce
	  additional protection for the Teredo node against IPv6-based scanning
	  attacks.
	  - Bits 80 to 95 contains the obfuscated UDP port number. This is the
	  port number that is mapped by the NAT to the Teredo client with all
	  bits inverted.
	  - Bits 96 to 127 contains the obfuscated IPv4 address. This is the
	  public IPv4 address of the NAT with all bits inverted.
	  */

	  var prefix = this.getBitsBase16(0, 32);

	  var udpPort = this.getBits(80, 96).xor(new BigInteger('ffff', 16)).toString();

	  var server4 = v4.Address.fromHex(this.getBitsBase16(32, 64));
	  var client4 = v4.Address.fromHex(this.getBits(96, 128)
	    .xor(new BigInteger('ffffffff', 16)).toString(16));

	  var flags = this.getBits(64, 80);
	  var flagsBase2 = this.getBitsBase2(64, 80);

	  var coneNat = flags.testBit(15);
	  var reserved = flags.testBit(14);
	  var groupIndividual = flags.testBit(8);
	  var universalLocal = flags.testBit(9);
	  var nonce = new BigInteger(flagsBase2.slice(2, 6) +
	    flagsBase2.slice(8, 16), 2).toString(10);

	  return {
	    prefix: sprintf('%s:%s', prefix.slice(0, 4), prefix.slice(4, 8)),
	    server4: server4.address,
	    client4: client4.address,
	    flags: flagsBase2,
	    coneNat: coneNat,
	    microsoft: {
	      reserved: reserved,
	      universalLocal: universalLocal,
	      groupIndividual: groupIndividual,
	      nonce: nonce
	    },
	    udpPort: udpPort
	  };
	};

	/*
	 * Returns an object containing the 6to4 properties of the address
	 */
	v6.Address.prototype.six2four = function () {
	  /*
	  - Bits 0 to 15 are set to the 6to4 prefix (2002::/16).
	  - Bits 16 to 48 embed the IPv4 address of the 6to4 gateway that is used.
	  */

	  var prefix = this.getBitsBase16(0, 16);

	  var gateway = v4.Address.fromHex(this.getBitsBase16(16, 48));

	  return {
	    prefix: sprintf('%s', prefix.slice(0, 4)),
	    gateway: gateway.address
	  };
	};


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * copped from https://github.com/joyent/node/blob/master/deps/v8/benchmarks/crypto.js (under same license).
	 * 
	 * Copyright (c) 2003-2005  Tom Wu
	 * All Rights Reserved.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
	 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
	 *
	 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
	 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
	 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
	 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
	 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	 *
	 * In addition, the following condition applies:
	 *
	 * All redistributions must retain an intact copy of this copyright notice
	 * and disclaimer.
	 */

	// V8 optimized constants.
	var dbits = 26
	var BI_DB = dbits;
	var BI_DM = ((1<<dbits)-1);
	var BI_DV = (1<<dbits);

	var BI_FP = 52;
	var BI_FV = Math.pow(2,BI_FP);
	var BI_F1 = BI_FP-dbits;
	var BI_F2 = 2*dbits-BI_FP;

	BigInteger = module.exports.BigInteger = function(a,b,c) {
	  this.array = new Array();
	  if(a != null)
	    if("number" == typeof a) this.fromNumber(a,b,c);
	    else if(b == null && "string" != typeof a) this.fromString(a,256);
	    else this.fromString(a,b);
	}

	// return new, unset BigInteger
	function nbi() { return new BigInteger(null); }

	// am: Compute w_j += (x*this_i), propagate carries,
	// c is initial carry, returns final carry.
	// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
	// We need to select the fastest one that works in this environment.

	// This is tailored to VMs with 2-bit tagging. It makes sure
	// that all the computations stay within the 29 bits available.
	function am4(i,x,w,j,c,n) {
	  var this_array = this.array;
	  var w_array    = w.array;

	  var xl = x&0x1fff, xh = x>>13;
	  while(--n >= 0) {
	    var l = this_array[i]&0x1fff;
	    var h = this_array[i++]>>13;
	    var m = xh*l+h*xl;
	    l = xl*l+((m&0x1fff)<<13)+w_array[j]+c;
	    c = (l>>26)+(m>>13)+xh*h;
	    w_array[j++] = l&0x3ffffff;
	  }
	  return c;
	}

	// Digit conversions
	var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	var BI_RC = new Array();
	var rr,vv;
	rr = "0".charCodeAt(0);
	for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
	rr = "a".charCodeAt(0);
	for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	rr = "A".charCodeAt(0);
	for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

	function int2char(n) { return BI_RM.charAt(n); }
	function intAt(s,i) {
	  var c = BI_RC[s.charCodeAt(i)];
	  return (c==null)?-1:c;
	}

	// (protected) copy this to r
	function bnpCopyTo(r) {
	  var this_array = this.array;
	  var r_array    = r.array;

	  for(var i = this.t-1; i >= 0; --i) r_array[i] = this_array[i];
	  r.t = this.t;
	  r.s = this.s;
	}

	// (protected) set from integer value x, -DV <= x < DV
	function bnpFromInt(x) {
	  var this_array = this.array;
	  this.t = 1;
	  this.s = (x<0)?-1:0;
	  if(x > 0) this_array[0] = x;
	  else if(x < -1) this_array[0] = x+DV; // WTH is DV?  BI_DV maybe?
	  else this.t = 0;
	}

	// return bigint initialized to value
	function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

	// (protected) set from string and radix
	function bnpFromString(s,b) {
	  var this_array = this.array;
	  var k;
	  if(b == 16) k = 4;
	  else if(b == 8) k = 3;
	  else if(b == 256) k = 8; // byte array
	  else if(b == 2) k = 1;
	  else if(b == 32) k = 5;
	  else if(b == 4) k = 2;
	  else { this.fromRadix(s,b); return; }
	  this.t = 0;
	  this.s = 0;
	  var i = s.length, mi = false, sh = 0;
	  while(--i >= 0) {
	    var x = (k==8)?s[i]&0xff:intAt(s,i);
	    if(x < 0) {
	      if(s.charAt(i) == "-") mi = true;
	      continue;
	    }
	    mi = false;
	    if(sh == 0)
	      this_array[this.t++] = x;
	    else if(sh+k > BI_DB) {
	      this_array[this.t-1] |= (x&((1<<(BI_DB-sh))-1))<<sh;
	      this_array[this.t++] = (x>>(BI_DB-sh));
	    }
	    else
	      this_array[this.t-1] |= x<<sh;
	    sh += k;
	    if(sh >= BI_DB) sh -= BI_DB;
	  }
	  if(k == 8 && (s[0]&0x80) != 0) {
	    this.s = -1;
	    if(sh > 0) this_array[this.t-1] |= ((1<<(BI_DB-sh))-1)<<sh;
	  }
	  this.clamp();
	  if(mi) BigInteger.ZERO.subTo(this,this);
	}

	// (protected) clamp off excess high words
	function bnpClamp() {
	  var this_array = this.array;
	  var c = this.s&BI_DM;
	  while(this.t > 0 && this_array[this.t-1] == c) --this.t;
	}

	// (public) return string representation in given radix
	function bnToString(b) {
	  var this_array = this.array;
	  if(this.s < 0) return "-"+this.negate().toString(b);
	  var k;
	  if(b == 16) k = 4;
	  else if(b == 8) k = 3;
	  else if(b == 2) k = 1;
	  else if(b == 32) k = 5;
	  else if(b == 4) k = 2;
	  else return this.toRadix(b);
	  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
	  var p = BI_DB-(i*BI_DB)%k;
	  if(i-- > 0) {
	    if(p < BI_DB && (d = this_array[i]>>p) > 0) { m = true; r = int2char(d); }
	    while(i >= 0) {
	      if(p < k) {
	        d = (this_array[i]&((1<<p)-1))<<(k-p);
	        d |= this_array[--i]>>(p+=BI_DB-k);
	      }
	      else {
	        d = (this_array[i]>>(p-=k))&km;
	        if(p <= 0) { p += BI_DB; --i; }
	      }
	      if(d > 0) m = true;
	      if(m) r += int2char(d);
	    }
	  }
	  return m?r:"0";
	}

	// (public) -this
	function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

	// (public) |this|
	function bnAbs() { return (this.s<0)?this.negate():this; }

	// (public) return + if this > a, - if this < a, 0 if equal
	function bnCompareTo(a) {
	  var this_array = this.array;
	  var a_array = a.array;

	  var r = this.s-a.s;
	  if(r != 0) return r;
	  var i = this.t;
	  r = i-a.t;
	  if(r != 0) return r;
	  while(--i >= 0) if((r=this_array[i]-a_array[i]) != 0) return r;
	  return 0;
	}

	// returns bit length of the integer x
	function nbits(x) {
	  var r = 1, t;
	  if((t=x>>>16) != 0) { x = t; r += 16; }
	  if((t=x>>8) != 0) { x = t; r += 8; }
	  if((t=x>>4) != 0) { x = t; r += 4; }
	  if((t=x>>2) != 0) { x = t; r += 2; }
	  if((t=x>>1) != 0) { x = t; r += 1; }
	  return r;
	}

	// (public) return the number of bits in "this"
	function bnBitLength() {
	  var this_array = this.array;
	  if(this.t <= 0) return 0;
	  return BI_DB*(this.t-1)+nbits(this_array[this.t-1]^(this.s&BI_DM));
	}

	// (protected) r = this << n*DB
	function bnpDLShiftTo(n,r) {
	  var this_array = this.array;
	  var r_array = r.array;
	  var i;
	  for(i = this.t-1; i >= 0; --i) r_array[i+n] = this_array[i];
	  for(i = n-1; i >= 0; --i) r_array[i] = 0;
	  r.t = this.t+n;
	  r.s = this.s;
	}

	// (protected) r = this >> n*DB
	function bnpDRShiftTo(n,r) {
	  var this_array = this.array;
	  var r_array = r.array;
	  for(var i = n; i < this.t; ++i) r_array[i-n] = this_array[i];
	  r.t = Math.max(this.t-n,0);
	  r.s = this.s;
	}

	// (protected) r = this << n
	function bnpLShiftTo(n,r) {
	  var this_array = this.array;
	  var r_array = r.array;
	  var bs = n%BI_DB;
	  var cbs = BI_DB-bs;
	  var bm = (1<<cbs)-1;
	  var ds = Math.floor(n/BI_DB), c = (this.s<<bs)&BI_DM, i;
	  for(i = this.t-1; i >= 0; --i) {
	    r_array[i+ds+1] = (this_array[i]>>cbs)|c;
	    c = (this_array[i]&bm)<<bs;
	  }
	  for(i = ds-1; i >= 0; --i) r_array[i] = 0;
	  r_array[ds] = c;
	  r.t = this.t+ds+1;
	  r.s = this.s;
	  r.clamp();
	}

	// (protected) r = this >> n
	function bnpRShiftTo(n,r) {
	  var this_array = this.array;
	  var r_array = r.array;
	  r.s = this.s;
	  var ds = Math.floor(n/BI_DB);
	  if(ds >= this.t) { r.t = 0; return; }
	  var bs = n%BI_DB;
	  var cbs = BI_DB-bs;
	  var bm = (1<<bs)-1;
	  r_array[0] = this_array[ds]>>bs;
	  for(var i = ds+1; i < this.t; ++i) {
	    r_array[i-ds-1] |= (this_array[i]&bm)<<cbs;
	    r_array[i-ds] = this_array[i]>>bs;
	  }
	  if(bs > 0) r_array[this.t-ds-1] |= (this.s&bm)<<cbs;
	  r.t = this.t-ds;
	  r.clamp();
	}

	// (protected) r = this - a
	function bnpSubTo(a,r) {
	  var this_array = this.array;
	  var r_array = r.array;
	  var a_array = a.array;
	  var i = 0, c = 0, m = Math.min(a.t,this.t);
	  while(i < m) {
	    c += this_array[i]-a_array[i];
	    r_array[i++] = c&BI_DM;
	    c >>= BI_DB;
	  }
	  if(a.t < this.t) {
	    c -= a.s;
	    while(i < this.t) {
	      c += this_array[i];
	      r_array[i++] = c&BI_DM;
	      c >>= BI_DB;
	    }
	    c += this.s;
	  }
	  else {
	    c += this.s;
	    while(i < a.t) {
	      c -= a_array[i];
	      r_array[i++] = c&BI_DM;
	      c >>= BI_DB;
	    }
	    c -= a.s;
	  }
	  r.s = (c<0)?-1:0;
	  if(c < -1) r_array[i++] = BI_DV+c;
	  else if(c > 0) r_array[i++] = c;
	  r.t = i;
	  r.clamp();
	}

	// (protected) r = this * a, r != this,a (HAC 14.12)
	// "this" should be the larger one if appropriate.
	function bnpMultiplyTo(a,r) {
	  var this_array = this.array; // Unused local var?
	  var r_array = r.array;
	  var x = this.abs(), y = a.abs();
	  var y_array = y.array;

	  var i = x.t;
	  r.t = i+y.t;
	  while(--i >= 0) r_array[i] = 0;
	  for(i = 0; i < y.t; ++i) r_array[i+x.t] = x.am(0,y_array[i],r,i,0,x.t);
	  r.s = 0;
	  r.clamp();
	  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
	}

	// (protected) r = this^2, r != this (HAC 14.16)
	function bnpSquareTo(r) {
	  var x = this.abs();
	  var x_array = x.array;
	  var r_array = r.array;

	  var i = r.t = 2*x.t;
	  while(--i >= 0) r_array[i] = 0;
	  for(i = 0; i < x.t-1; ++i) {
	    var c = x.am(i,x_array[i],r,2*i,0,1);
	    if((r_array[i+x.t]+=x.am(i+1,2*x_array[i],r,2*i+1,c,x.t-i-1)) >= BI_DV) {
	      r_array[i+x.t] -= BI_DV;
	      r_array[i+x.t+1] = 1;
	    }
	  }
	  if(r.t > 0) r_array[r.t-1] += x.am(i,x_array[i],r,2*i,0,1);
	  r.s = 0;
	  r.clamp();
	}

	// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
	// r != q, this != m.  q or r may be null.
	function bnpDivRemTo(m,q,r) {
	  var pm = m.abs();
	  if(pm.t <= 0) return;
	  var pt = this.abs();
	  if(pt.t < pm.t) {
	    if(q != null) q.fromInt(0);
	    if(r != null) this.copyTo(r);
	    return;
	  }
	  if(r == null) r = nbi();
	  var y = nbi(), ts = this.s, ms = m.s;
	  var pm_array = pm.array;
	  var nsh = BI_DB-nbits(pm_array[pm.t-1]);	// normalize modulus
	  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
	  else { pm.copyTo(y); pt.copyTo(r); }
	  var ys = y.t;

	  var y_array = y.array;
	  var y0 = y_array[ys-1];
	  if(y0 == 0) return;
	  var yt = y0*(1<<BI_F1)+((ys>1)?y_array[ys-2]>>BI_F2:0);
	  var d1 = BI_FV/yt, d2 = (1<<BI_F1)/yt, e = 1<<BI_F2;
	  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
	  y.dlShiftTo(j,t);

	  var r_array = r.array;
	  if(r.compareTo(t) >= 0) {
	    r_array[r.t++] = 1;
	    r.subTo(t,r);
	  }
	  BigInteger.ONE.dlShiftTo(ys,t);
	  t.subTo(y,y);	// "negative" y so we can replace sub with am later
	  while(y.t < ys) y_array[y.t++] = 0;
	  while(--j >= 0) {
	    // Estimate quotient digit
	    var qd = (r_array[--i]==y0)?BI_DM:Math.floor(r_array[i]*d1+(r_array[i-1]+e)*d2);
	    if((r_array[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
	      y.dlShiftTo(j,t);
	      r.subTo(t,r);
	      while(r_array[i] < --qd) r.subTo(t,r);
	    }
	  }
	  if(q != null) {
	    r.drShiftTo(ys,q);
	    if(ts != ms) BigInteger.ZERO.subTo(q,q);
	  }
	  r.t = ys;
	  r.clamp();
	  if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
	  if(ts < 0) BigInteger.ZERO.subTo(r,r);
	}

	// (public) this mod a
	function bnMod(a) {
	  var r = nbi();
	  this.abs().divRemTo(a,null,r);
	  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
	  return r;
	}

	// Modular reduction using "classic" algorithm
	function Classic(m) { this.m = m; }
	function cConvert(x) {
	  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
	  else return x;
	}
	function cRevert(x) { return x; }
	function cReduce(x) { x.divRemTo(this.m,null,x); }
	function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
	function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

	Classic.prototype.convert = cConvert;
	Classic.prototype.revert = cRevert;
	Classic.prototype.reduce = cReduce;
	Classic.prototype.mulTo = cMulTo;
	Classic.prototype.sqrTo = cSqrTo;

	// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
	// justification:
	//         xy == 1 (mod m)
	//         xy =  1+km
	//   xy(2-xy) = (1+km)(1-km)
	// x[y(2-xy)] = 1-k^2m^2
	// x[y(2-xy)] == 1 (mod m^2)
	// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
	// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
	// JS multiply "overflows" differently from C/C++, so care is needed here.
	function bnpInvDigit() {
	  var this_array = this.array;
	  if(this.t < 1) return 0;
	  var x = this_array[0];
	  if((x&1) == 0) return 0;
	  var y = x&3;		// y == 1/x mod 2^2
	  y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
	  y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
	  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
	  // last step - calculate inverse mod DV directly;
	  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
	  y = (y*(2-x*y%BI_DV))%BI_DV;		// y == 1/x mod 2^dbits
	  // we really want the negative inverse, and -DV < y < DV
	  return (y>0)?BI_DV-y:-y;
	}

	// Montgomery reduction
	function Montgomery(m) {
	  this.m = m;
	  this.mp = m.invDigit();
	  this.mpl = this.mp&0x7fff;
	  this.mph = this.mp>>15;
	  this.um = (1<<(BI_DB-15))-1;
	  this.mt2 = 2*m.t;
	}

	// xR mod m
	function montConvert(x) {
	  var r = nbi();
	  x.abs().dlShiftTo(this.m.t,r);
	  r.divRemTo(this.m,null,r);
	  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
	  return r;
	}

	// x/R mod m
	function montRevert(x) {
	  var r = nbi();
	  x.copyTo(r);
	  this.reduce(r);
	  return r;
	}

	// x = x/R mod m (HAC 14.32)
	function montReduce(x) {
	  var x_array = x.array;
	  while(x.t <= this.mt2)	// pad x so am has enough room later
	    x_array[x.t++] = 0;
	  for(var i = 0; i < this.m.t; ++i) {
	    // faster way of calculating u0 = x[i]*mp mod DV
	    var j = x_array[i]&0x7fff;
	    var u0 = (j*this.mpl+(((j*this.mph+(x_array[i]>>15)*this.mpl)&this.um)<<15))&BI_DM;
	    // use am to combine the multiply-shift-add into one call
	    j = i+this.m.t;
	    x_array[j] += this.m.am(0,u0,x,i,0,this.m.t);
	    // propagate carry
	    while(x_array[j] >= BI_DV) { x_array[j] -= BI_DV; x_array[++j]++; }
	  }
	  x.clamp();
	  x.drShiftTo(this.m.t,x);
	  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
	}

	// r = "x^2/R mod m"; x != r
	function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

	// r = "xy/R mod m"; x,y != r
	function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

	Montgomery.prototype.convert = montConvert;
	Montgomery.prototype.revert = montRevert;
	Montgomery.prototype.reduce = montReduce;
	Montgomery.prototype.mulTo = montMulTo;
	Montgomery.prototype.sqrTo = montSqrTo;

	// (protected) true iff this is even
	function bnpIsEven() {
	  var this_array = this.array;
	  return ((this.t>0)?(this_array[0]&1):this.s) == 0;
	}

	// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
	function bnpExp(e,z) {
	  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
	  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
	  g.copyTo(r);
	  while(--i >= 0) {
	    z.sqrTo(r,r2);
	    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
	    else { var t = r; r = r2; r2 = t; }
	  }
	  return z.revert(r);
	}

	// (public) this^e % m, 0 <= e < 2^32
	function bnModPowInt(e,m) {
	  var z;
	  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
	  return this.exp(e,z);
	}

	// protected
	BigInteger.prototype.copyTo = bnpCopyTo;
	BigInteger.prototype.fromInt = bnpFromInt;
	BigInteger.prototype.fromString = bnpFromString;
	BigInteger.prototype.clamp = bnpClamp;
	BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
	BigInteger.prototype.drShiftTo = bnpDRShiftTo;
	BigInteger.prototype.lShiftTo = bnpLShiftTo;
	BigInteger.prototype.rShiftTo = bnpRShiftTo;
	BigInteger.prototype.subTo = bnpSubTo;
	BigInteger.prototype.multiplyTo = bnpMultiplyTo;
	BigInteger.prototype.squareTo = bnpSquareTo;
	BigInteger.prototype.divRemTo = bnpDivRemTo;
	BigInteger.prototype.invDigit = bnpInvDigit;
	BigInteger.prototype.isEven = bnpIsEven;
	BigInteger.prototype.exp = bnpExp;

	// public
	BigInteger.prototype.toString = bnToString;
	BigInteger.prototype.negate = bnNegate;
	BigInteger.prototype.abs = bnAbs;
	BigInteger.prototype.compareTo = bnCompareTo;
	BigInteger.prototype.bitLength = bnBitLength;
	BigInteger.prototype.mod = bnMod;
	BigInteger.prototype.modPowInt = bnModPowInt;

	// "constants"
	BigInteger.ZERO = nbv(0);
	BigInteger.ONE = nbv(1);
	// Copyright (c) 2005  Tom Wu
	// All Rights Reserved.
	// See "LICENSE" for details.

	// Extended JavaScript BN functions, required for RSA private ops.

	// (public)
	function bnClone() { var r = nbi(); this.copyTo(r); return r; }

	// (public) return value as integer
	function bnIntValue() {
	  var this_array = this.array;
	  if(this.s < 0) {
	    if(this.t == 1) return this_array[0]-BI_DV;
	    else if(this.t == 0) return -1;
	  }
	  else if(this.t == 1) return this_array[0];
	  else if(this.t == 0) return 0;
	  // assumes 16 < DB < 32
	  return ((this_array[1]&((1<<(32-BI_DB))-1))<<BI_DB)|this_array[0];
	}

	// (public) return value as byte
	function bnByteValue() {
	  var this_array = this.array;
	  return (this.t==0)?this.s:(this_array[0]<<24)>>24;
	}

	// (public) return value as short (assumes DB>=16)
	function bnShortValue() {
	  var this_array = this.array;
	  return (this.t==0)?this.s:(this_array[0]<<16)>>16;
	}

	// (protected) return x s.t. r^x < DV
	function bnpChunkSize(r) { return Math.floor(Math.LN2*BI_DB/Math.log(r)); }

	// (public) 0 if this == 0, 1 if this > 0
	function bnSigNum() {
	  var this_array = this.array;
	  if(this.s < 0) return -1;
	  else if(this.t <= 0 || (this.t == 1 && this_array[0] <= 0)) return 0;
	  else return 1;
	}

	// (protected) convert to radix string
	function bnpToRadix(b) {
	  if(b == null) b = 10;
	  if(this.signum() == 0 || b < 2 || b > 36) return "0";
	  var cs = this.chunkSize(b);
	  var a = Math.pow(b,cs);
	  var d = nbv(a), y = nbi(), z = nbi(), r = "";
	  this.divRemTo(d,y,z);
	  while(y.signum() > 0) {
	    r = (a+z.intValue()).toString(b).substr(1) + r;
	    y.divRemTo(d,y,z);
	  }
	  return z.intValue().toString(b) + r;
	}

	// (protected) convert from radix string
	function bnpFromRadix(s,b) {
	  this.fromInt(0);
	  if(b == null) b = 10;
	  var cs = this.chunkSize(b);
	  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
	  for(var i = 0; i < s.length; ++i) {
	    var x = intAt(s,i);
	    if(x < 0) {
	      if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
	      continue;
	    }
	    w = b*w+x;
	    if(++j >= cs) {
	      this.dMultiply(d);
	      this.dAddOffset(w,0);
	      j = 0;
	      w = 0;
	    }
	  }
	  if(j > 0) {
	    this.dMultiply(Math.pow(b,j));
	    this.dAddOffset(w,0);
	  }
	  if(mi) BigInteger.ZERO.subTo(this,this);
	}

	// (protected) alternate constructor
	function bnpFromNumber(a,b,c) {
	  if("number" == typeof b) {
	    // new BigInteger(int,int,RNG)
	    if(a < 2) this.fromInt(1);
	    else {
	      this.fromNumber(a,c);
	      if(!this.testBit(a-1))	// force MSB set
	        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
	      if(this.isEven()) this.dAddOffset(1,0); // force odd
	      while(!this.isProbablePrime(b)) {
	        this.dAddOffset(2,0);
	        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
	      }
	    }
	  }
	  else {
	    // todo: we don't need this.
	    // new BigInteger(int,RNG)
	    var x = new Array(), t = a&7;
	    x.length = (a>>3)+1;
	    b.nextBytes(x);
	    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
	    this.fromString(x,256);
	  }
	}

	// (public) convert to bigendian byte array
	function bnToByteArray() {
	  var this_array = this.array;
	  var i = this.t, r = new Array();
	  r[0] = this.s;
	  var p = BI_DB-(i*BI_DB)%8, d, k = 0;
	  if(i-- > 0) {
	    if(p < BI_DB && (d = this_array[i]>>p) != (this.s&BI_DM)>>p)
	      r[k++] = d|(this.s<<(BI_DB-p));
	    while(i >= 0) {
	      if(p < 8) {
	        d = (this_array[i]&((1<<p)-1))<<(8-p);
	        d |= this_array[--i]>>(p+=BI_DB-8);
	      }
	      else {
	        d = (this_array[i]>>(p-=8))&0xff;
	        if(p <= 0) { p += BI_DB; --i; }
	      }
	      if((d&0x80) != 0) d |= -256;
	      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
	      if(k > 0 || d != this.s) r[k++] = d;
	    }
	  }
	  return r;
	}

	function bnEquals(a) { return(this.compareTo(a)==0); }
	function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
	function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

	// (protected) r = this op a (bitwise)
	function bnpBitwiseTo(a,op,r) {
	  var this_array = this.array;
	  var a_array    = a.array;
	  var r_array    = r.array;
	  var i, f, m = Math.min(a.t,this.t);
	  for(i = 0; i < m; ++i) r_array[i] = op(this_array[i],a_array[i]);
	  if(a.t < this.t) {
	    f = a.s&BI_DM;
	    for(i = m; i < this.t; ++i) r_array[i] = op(this_array[i],f);
	    r.t = this.t;
	  }
	  else {
	    f = this.s&BI_DM;
	    for(i = m; i < a.t; ++i) r_array[i] = op(f,a_array[i]);
	    r.t = a.t;
	  }
	  r.s = op(this.s,a.s);
	  r.clamp();
	}

	// (public) this & a
	function op_and(x,y) { return x&y; }
	function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

	// (public) this | a
	function op_or(x,y) { return x|y; }
	function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

	// (public) this ^ a
	function op_xor(x,y) { return x^y; }
	function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

	// (public) this & ~a
	function op_andnot(x,y) { return x&~y; }
	function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

	// (public) ~this
	function bnNot() {
	  var this_array = this.array;
	  var r = nbi();
	  var r_array = r.array;

	  for(var i = 0; i < this.t; ++i) r_array[i] = BI_DM&~this_array[i];
	  r.t = this.t;
	  r.s = ~this.s;
	  return r;
	}

	// (public) this << n
	function bnShiftLeft(n) {
	  var r = nbi();
	  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
	  return r;
	}

	// (public) this >> n
	function bnShiftRight(n) {
	  var r = nbi();
	  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
	  return r;
	}

	// return index of lowest 1-bit in x, x < 2^31
	function lbit(x) {
	  if(x == 0) return -1;
	  var r = 0;
	  if((x&0xffff) == 0) { x >>= 16; r += 16; }
	  if((x&0xff) == 0) { x >>= 8; r += 8; }
	  if((x&0xf) == 0) { x >>= 4; r += 4; }
	  if((x&3) == 0) { x >>= 2; r += 2; }
	  if((x&1) == 0) ++r;
	  return r;
	}

	// (public) returns index of lowest 1-bit (or -1 if none)
	function bnGetLowestSetBit() {
	  var this_array = this.array;
	  for(var i = 0; i < this.t; ++i)
	    if(this_array[i] != 0) return i*BI_DB+lbit(this_array[i]);
	  if(this.s < 0) return this.t*BI_DB;
	  return -1;
	}

	// return number of 1 bits in x
	function cbit(x) {
	  var r = 0;
	  while(x != 0) { x &= x-1; ++r; }
	  return r;
	}

	// (public) return number of set bits
	function bnBitCount() {
	  var this_array = this.array;
	  var r = 0, x = this.s&BI_DM;
	  for(var i = 0; i < this.t; ++i) r += cbit(this_array[i]^x);
	  return r;
	}

	// (public) true iff nth bit is set
	function bnTestBit(n) {
	  var this_array = this.array;
	  var j = Math.floor(n/BI_DB);
	  if(j >= this.t) return(this.s!=0);
	  return((this_array[j]&(1<<(n%BI_DB)))!=0);
	}

	// (protected) this op (1<<n)
	function bnpChangeBit(n,op) {
	  var r = BigInteger.ONE.shiftLeft(n);
	  this.bitwiseTo(r,op,r);
	  return r;
	}

	// (public) this | (1<<n)
	function bnSetBit(n) { return this.changeBit(n,op_or); }

	// (public) this & ~(1<<n)
	function bnClearBit(n) { return this.changeBit(n,op_andnot); }

	// (public) this ^ (1<<n)
	function bnFlipBit(n) { return this.changeBit(n,op_xor); }

	// (protected) r = this + a
	function bnpAddTo(a,r) {
	  var this_array = this.array;
	  var a_array = a.array;
	  var r_array = r.array;
	  var i = 0, c = 0, m = Math.min(a.t,this.t);
	  while(i < m) {
	    c += this_array[i]+a_array[i];
	    r_array[i++] = c&BI_DM;
	    c >>= BI_DB;
	  }
	  if(a.t < this.t) {
	    c += a.s;
	    while(i < this.t) {
	      c += this_array[i];
	      r_array[i++] = c&BI_DM;
	      c >>= BI_DB;
	    }
	    c += this.s;
	  }
	  else {
	    c += this.s;
	    while(i < a.t) {
	      c += a_array[i];
	      r_array[i++] = c&BI_DM;
	      c >>= BI_DB;
	    }
	    c += a.s;
	  }
	  r.s = (c<0)?-1:0;
	  if(c > 0) r_array[i++] = c;
	  else if(c < -1) r_array[i++] = BI_DV+c;
	  r.t = i;
	  r.clamp();
	}

	// (public) this + a
	function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

	// (public) this - a
	function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

	// (public) this * a
	function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

	// (public) this / a
	function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

	// (public) this % a
	function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

	// (public) [this/a,this%a]
	function bnDivideAndRemainder(a) {
	  var q = nbi(), r = nbi();
	  this.divRemTo(a,q,r);
	  return new Array(q,r);
	}

	// (protected) this *= n, this >= 0, 1 < n < DV
	function bnpDMultiply(n) {
	  var this_array = this.array;
	  this_array[this.t] = this.am(0,n-1,this,0,0,this.t);
	  ++this.t;
	  this.clamp();
	}

	// (protected) this += n << w words, this >= 0
	function bnpDAddOffset(n,w) {
	  var this_array = this.array;
	  while(this.t <= w) this_array[this.t++] = 0;
	  this_array[w] += n;
	  while(this_array[w] >= BI_DV) {
	    this_array[w] -= BI_DV;
	    if(++w >= this.t) this_array[this.t++] = 0;
	    ++this_array[w];
	  }
	}

	// A "null" reducer
	function NullExp() {}
	function nNop(x) { return x; }
	function nMulTo(x,y,r) { x.multiplyTo(y,r); }
	function nSqrTo(x,r) { x.squareTo(r); }

	NullExp.prototype.convert = nNop;
	NullExp.prototype.revert = nNop;
	NullExp.prototype.mulTo = nMulTo;
	NullExp.prototype.sqrTo = nSqrTo;

	// (public) this^e
	function bnPow(e) { return this.exp(e,new NullExp()); }

	// (protected) r = lower n words of "this * a", a.t <= n
	// "this" should be the larger one if appropriate.
	function bnpMultiplyLowerTo(a,n,r) {
	  var r_array = r.array;
	  var a_array = a.array;
	  var i = Math.min(this.t+a.t,n);
	  r.s = 0; // assumes a,this >= 0
	  r.t = i;
	  while(i > 0) r_array[--i] = 0;
	  var j;
	  for(j = r.t-this.t; i < j; ++i) r_array[i+this.t] = this.am(0,a_array[i],r,i,0,this.t);
	  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a_array[i],r,i,0,n-i);
	  r.clamp();
	}

	// (protected) r = "this * a" without lower n words, n > 0
	// "this" should be the larger one if appropriate.
	function bnpMultiplyUpperTo(a,n,r) {
	  var r_array = r.array;
	  var a_array = a.array;
	  --n;
	  var i = r.t = this.t+a.t-n;
	  r.s = 0; // assumes a,this >= 0
	  while(--i >= 0) r_array[i] = 0;
	  for(i = Math.max(n-this.t,0); i < a.t; ++i)
	    r_array[this.t+i-n] = this.am(n-i,a_array[i],r,0,0,this.t+i-n);
	  r.clamp();
	  r.drShiftTo(1,r);
	}

	// Barrett modular reduction
	function Barrett(m) {
	  // setup Barrett
	  this.r2 = nbi();
	  this.q3 = nbi();
	  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
	  this.mu = this.r2.divide(m);
	  this.m = m;
	}

	function barrettConvert(x) {
	  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
	  else if(x.compareTo(this.m) < 0) return x;
	  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
	}

	function barrettRevert(x) { return x; }

	// x = x mod m (HAC 14.42)
	function barrettReduce(x) {
	  x.drShiftTo(this.m.t-1,this.r2);
	  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
	  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
	  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
	  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
	  x.subTo(this.r2,x);
	  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
	}

	// r = x^2 mod m; x != r
	function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

	// r = x*y mod m; x,y != r
	function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

	Barrett.prototype.convert = barrettConvert;
	Barrett.prototype.revert = barrettRevert;
	Barrett.prototype.reduce = barrettReduce;
	Barrett.prototype.mulTo = barrettMulTo;
	Barrett.prototype.sqrTo = barrettSqrTo;

	// (public) this^e % m (HAC 14.85)
	function bnModPow(e,m) {
	  var e_array = e.array;
	  var i = e.bitLength(), k, r = nbv(1), z;
	  if(i <= 0) return r;
	  else if(i < 18) k = 1;
	  else if(i < 48) k = 3;
	  else if(i < 144) k = 4;
	  else if(i < 768) k = 5;
	  else k = 6;
	  if(i < 8)
	    z = new Classic(m);
	  else if(m.isEven())
	    z = new Barrett(m);
	  else
	    z = new Montgomery(m);

	  // precomputation
	  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
	  g[1] = z.convert(this);
	  if(k > 1) {
	    var g2 = nbi();
	    z.sqrTo(g[1],g2);
	    while(n <= km) {
	      g[n] = nbi();
	      z.mulTo(g2,g[n-2],g[n]);
	      n += 2;
	    }
	  }

	  var j = e.t-1, w, is1 = true, r2 = nbi(), t;
	  i = nbits(e_array[j])-1;
	  while(j >= 0) {
	    if(i >= k1) w = (e_array[j]>>(i-k1))&km;
	    else {
	      w = (e_array[j]&((1<<(i+1))-1))<<(k1-i);
	      if(j > 0) w |= e_array[j-1]>>(BI_DB+i-k1);
	    }

	    n = k;
	    while((w&1) == 0) { w >>= 1; --n; }
	    if((i -= n) < 0) { i += BI_DB; --j; }
	    if(is1) {	// ret == 1, don't bother squaring or multiplying it
	      g[w].copyTo(r);
	      is1 = false;
	    }
	    else {
	      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
	      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
	      z.mulTo(r2,g[w],r);
	    }

	    while(j >= 0 && (e_array[j]&(1<<i)) == 0) {
	      z.sqrTo(r,r2); t = r; r = r2; r2 = t;
	      if(--i < 0) { i = BI_DB-1; --j; }
	    }
	  }
	  return z.revert(r);
	}

	// (public) gcd(this,a) (HAC 14.54)
	function bnGCD(a) {
	  var x = (this.s<0)?this.negate():this.clone();
	  var y = (a.s<0)?a.negate():a.clone();
	  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
	  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
	  if(g < 0) return x;
	  if(i < g) g = i;
	  if(g > 0) {
	    x.rShiftTo(g,x);
	    y.rShiftTo(g,y);
	  }
	  while(x.signum() > 0) {
	    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
	    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
	    if(x.compareTo(y) >= 0) {
	      x.subTo(y,x);
	      x.rShiftTo(1,x);
	    }
	    else {
	      y.subTo(x,y);
	      y.rShiftTo(1,y);
	    }
	  }
	  if(g > 0) y.lShiftTo(g,y);
	  return y;
	}

	// (protected) this % n, n < 2^26
	function bnpModInt(n) {
	  var this_array = this.array;
	  if(n <= 0) return 0;
	  var d = BI_DV%n, r = (this.s<0)?n-1:0;
	  if(this.t > 0)
	    if(d == 0) r = this_array[0]%n;
	    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this_array[i])%n;
	  return r;
	}

	// (public) 1/this % m (HAC 14.61)
	function bnModInverse(m) {
	  var ac = m.isEven();
	  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
	  var u = m.clone(), v = this.clone();
	  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
	  while(u.signum() != 0) {
	    while(u.isEven()) {
	      u.rShiftTo(1,u);
	      if(ac) {
	        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
	        a.rShiftTo(1,a);
	      }
	      else if(!b.isEven()) b.subTo(m,b);
	      b.rShiftTo(1,b);
	    }
	    while(v.isEven()) {
	      v.rShiftTo(1,v);
	      if(ac) {
	        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
	        c.rShiftTo(1,c);
	      }
	      else if(!d.isEven()) d.subTo(m,d);
	      d.rShiftTo(1,d);
	    }
	    if(u.compareTo(v) >= 0) {
	      u.subTo(v,u);
	      if(ac) a.subTo(c,a);
	      b.subTo(d,b);
	    }
	    else {
	      v.subTo(u,v);
	      if(ac) c.subTo(a,c);
	      d.subTo(b,d);
	    }
	  }
	  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
	  if(d.compareTo(m) >= 0) return d.subtract(m);
	  if(d.signum() < 0) d.addTo(m,d); else return d;
	  if(d.signum() < 0) return d.add(m); else return d;
	}

	var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];
	var lplim = (1<<26)/lowprimes[lowprimes.length-1];

	// (public) test primality with certainty >= 1-.5^t
	function bnIsProbablePrime(t) {
	  var i, x = this.abs();
	  var x_array = x.array;
	  if(x.t == 1 && x_array[0] <= lowprimes[lowprimes.length-1]) {
	    for(i = 0; i < lowprimes.length; ++i)
	      if(x_array[0] == lowprimes[i]) return true;
	    return false;
	  }
	  if(x.isEven()) return false;
	  i = 1;
	  while(i < lowprimes.length) {
	    var m = lowprimes[i], j = i+1;
	    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
	    m = x.modInt(m);
	    while(i < j) if(m%lowprimes[i++] == 0) return false;
	  }
	  return x.millerRabin(t);
	}

	// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
	function bnpMillerRabin(t) {
	  var n1 = this.subtract(BigInteger.ONE);
	  var k = n1.getLowestSetBit();
	  if(k <= 0) return false;
	  var r = n1.shiftRight(k);
	  t = (t+1)>>1;
	  if(t > lowprimes.length) t = lowprimes.length;
	  var a = nbi();
	  for(var i = 0; i < t; ++i) {
	    a.fromInt(lowprimes[i]);
	    var y = a.modPow(r,this);
	    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
	      var j = 1;
	      while(j++ < k && y.compareTo(n1) != 0) {
	        y = y.modPowInt(2,this);
	        if(y.compareTo(BigInteger.ONE) == 0) return false;
	      }
	      if(y.compareTo(n1) != 0) return false;
	    }
	  }
	  return true;
	};

	// protected
	BigInteger.prototype.chunkSize = bnpChunkSize;
	BigInteger.prototype.toRadix = bnpToRadix;
	BigInteger.prototype.fromRadix = bnpFromRadix;
	BigInteger.prototype.fromNumber = bnpFromNumber;
	BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
	BigInteger.prototype.changeBit = bnpChangeBit;
	BigInteger.prototype.addTo = bnpAddTo;
	BigInteger.prototype.dMultiply = bnpDMultiply;
	BigInteger.prototype.dAddOffset = bnpDAddOffset;
	BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
	BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
	BigInteger.prototype.modInt = bnpModInt;
	BigInteger.prototype.millerRabin = bnpMillerRabin;

	// public
	BigInteger.prototype.clone = bnClone;
	BigInteger.prototype.intValue = bnIntValue;
	BigInteger.prototype.byteValue = bnByteValue;
	BigInteger.prototype.shortValue = bnShortValue;
	BigInteger.prototype.signum = bnSigNum;
	BigInteger.prototype.toByteArray = bnToByteArray;
	BigInteger.prototype.equals = bnEquals;
	BigInteger.prototype.min = bnMin;
	BigInteger.prototype.max = bnMax;
	BigInteger.prototype.and = bnAnd;
	BigInteger.prototype.or = bnOr;
	BigInteger.prototype.xor = bnXor;
	BigInteger.prototype.andNot = bnAndNot;
	BigInteger.prototype.not = bnNot;
	BigInteger.prototype.shiftLeft = bnShiftLeft;
	BigInteger.prototype.shiftRight = bnShiftRight;
	BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
	BigInteger.prototype.bitCount = bnBitCount;
	BigInteger.prototype.testBit = bnTestBit;
	BigInteger.prototype.setBit = bnSetBit;
	BigInteger.prototype.clearBit = bnClearBit;
	BigInteger.prototype.flipBit = bnFlipBit;
	BigInteger.prototype.add = bnAdd;
	BigInteger.prototype.subtract = bnSubtract;
	BigInteger.prototype.multiply = bnMultiply;
	BigInteger.prototype.divide = bnDivide;
	BigInteger.prototype.remainder = bnRemainder;
	BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
	BigInteger.prototype.modPow = bnModPow;
	BigInteger.prototype.modInverse = bnModInverse;
	BigInteger.prototype.pow = bnPow;
	BigInteger.prototype.gcd = bnGCD;
	BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
	BigInteger.prototype.am = am4;

	// end of stuff copied from github.

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	sprintf() for JavaScript 0.7-beta1
	http://www.diveintojavascript.com/projects/javascript-sprintf

	Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	    * Neither the name of sprintf() for JavaScript nor the
	      names of its contributors may be used to endorse or promote products
	      derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


	Changelog:
	2010.11.07 - 0.7-beta1-node
	  - converted it to a node.js compatible module

	2010.09.06 - 0.7-beta1
	  - features: vsprintf, support for named placeholders
	  - enhancements: format cache, reduced global namespace pollution

	2010.05.22 - 0.6:
	 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
	 Note:
	 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
	 who warned me about a bug in 0.5, I discovered that the last update was
	 a regress. I appologize for that.

	2010.05.09 - 0.5:
	 - bug fix: 0 is now preceeded with a + sign
	 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
	 - switched from GPL to BSD license

	2007.10.21 - 0.4:
	 - unit test and patch (David Baird)

	2007.09.17 - 0.3:
	 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)

	2007.09.11 - 0.2:
	 - feature: added argument swapping

	2007.04.03 - 0.1:
	 - initial release
	**/

	var sprintf = (function() {
		function get_type(variable) {
			return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
		}
		function str_repeat(input, multiplier) {
			for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
			return output.join('');
		}

		var str_format = function() {
			if (!str_format.cache.hasOwnProperty(arguments[0])) {
				str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
			}
			return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
		};

		// convert object to simple one line string without indentation or
		// newlines. Note that this implementation does not print array
		// values to their actual place for sparse arrays. 
		//
		// For example sparse array like this
		//    l = []
		//    l[4] = 1
		// Would be printed as "[1]" instead of "[, , , , 1]"
		// 
		// If argument 'seen' is not null and array the function will check for 
		// circular object references from argument.
		str_format.object_stringify = function(obj, depth, maxdepth, seen) {
			var str = '';
			if (obj != null) {
				switch( typeof(obj) ) {
				case 'function': 
					return '[Function' + (obj.name ? ': '+obj.name : '') + ']';
				    break;
				case 'object':
					if ( obj instanceof Error) { return '[' + obj.toString() + ']' };
					if (depth >= maxdepth) return '[Object]'
					if (seen) {
						// add object to seen list
						seen = seen.slice(0)
						seen.push(obj);
					}
					if (obj.length != null) { //array
						str += '[';
						var arr = []
						for (var i in obj) {
							if (seen && seen.indexOf(obj[i]) >= 0) arr.push('[Circular]');
							else arr.push(str_format.object_stringify(obj[i], depth+1, maxdepth, seen));
						}
						str += arr.join(', ') + ']';
					} else if ('getMonth' in obj) { // date
						return 'Date(' + obj + ')';
					} else { // object
						str += '{';
						var arr = []
						for (var k in obj) { 
							if(obj.hasOwnProperty(k)) {
								if (seen && seen.indexOf(obj[k]) >= 0) arr.push(k + ': [Circular]');
								else arr.push(k +': ' +str_format.object_stringify(obj[k], depth+1, maxdepth, seen)); 
							}
						}
						str += arr.join(', ') + '}';
					}
					return str;
					break;
				case 'string':				
					return '"' + obj + '"';
					break
				}
			}
			return '' + obj;
		}

		str_format.format = function(parse_tree, argv) {
			var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
			for (i = 0; i < tree_length; i++) {
				node_type = get_type(parse_tree[i]);
				if (node_type === 'string') {
					output.push(parse_tree[i]);
				}
				else if (node_type === 'array') {
					match = parse_tree[i]; // convenience purposes only
					if (match[2]) { // keyword argument
						arg = argv[cursor];
						for (k = 0; k < match[2].length; k++) {
							if (!arg.hasOwnProperty(match[2][k])) {
								throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
							}
							arg = arg[match[2][k]];
						}
					}
					else if (match[1]) { // positional argument (explicit)
						arg = argv[match[1]];
					}
					else { // positional argument (implicit)
						arg = argv[cursor++];
					}

					if (/[^sO]/.test(match[8]) && (get_type(arg) != 'number')) {
						throw new Error(sprintf('[sprintf] expecting number but found %s "' + arg + '"', get_type(arg)));
					}
					switch (match[8]) {
						case 'b': arg = arg.toString(2); break;
						case 'c': arg = String.fromCharCode(arg); break;
						case 'd': arg = parseInt(arg, 10); break;
						case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
						case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
					    case 'O': arg = str_format.object_stringify(arg, 0, parseInt(match[7]) || 5); break;
						case 'o': arg = arg.toString(8); break;
						case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
						case 'u': arg = Math.abs(arg); break;
						case 'x': arg = arg.toString(16); break;
						case 'X': arg = arg.toString(16).toUpperCase(); break;
					}
					arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
					pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
					pad_length = match[6] - String(arg).length;
					pad = match[6] ? str_repeat(pad_character, pad_length) : '';
					output.push(match[5] ? arg + pad : pad + arg);
				}
			}
			return output.join('');
		};

		str_format.cache = {};

		str_format.parse = function(fmt) {
			var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
			while (_fmt) {
				if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
					parse_tree.push(match[0]);
				}
				else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
					parse_tree.push('%');
				}
				else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosOuxX])/.exec(_fmt)) !== null) {
					if (match[2]) {
						arg_names |= 1;
						var field_list = [], replacement_field = match[2], field_match = [];
						if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
							field_list.push(field_match[1]);
							while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
								if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
									field_list.push(field_match[1]);
								}
								else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
									field_list.push(field_match[1]);
								}
								else {
									throw new Error('[sprintf] ' + replacement_field);
								}
							}
						}
						else {
	                        throw new Error('[sprintf] ' + replacement_field);
						}
						match[2] = field_list;
					}
					else {
						arg_names |= 2;
					}
					if (arg_names === 3) {
						throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
					}
					parse_tree.push(match);
				}
				else {
					throw new Error('[sprintf] ' + _fmt);
				}
				_fmt = _fmt.substring(match[0].length);
			}
			return parse_tree;
		};

		return str_format;
	})();

	var vsprintf = function(fmt, argv) {
		var argvClone = argv.slice();
		argvClone.unshift(fmt);
		return sprintf.apply(null, argvClone);
	};

	module.exports = sprintf;
	sprintf.sprintf = sprintf;
	sprintf.vsprintf = vsprintf;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* Copyright 2010 Membase, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	'use strict';

	/*jshint node:true*/


	/**
	 * Convert a 16-bit quantity (short integer) from host byte order to network byte order (Little-Endian to Big-Endian).
	 *
	 * @param {Array|Buffer} b Array of octets or a nodejs Buffer
	 * @param {number} i Zero-based index at which to write into b
	 * @param {number} v Value to convert
	 */
	exports.htons = function(b, i, v) {
		b[i] = (0xff & (v >> 8));
		b[i + 1] = (0xff & (v));
	};


	/**
	 * Convert a 16-bit quantity (short integer) from network byte order to host byte order (Big-Endian to Little-Endian).
	 *
	 * @param {Array|Buffer} b Array of octets or a nodejs Buffer to read value from
	 * @param {number} i Zero-based index at which to read from b
	 * @returns {number}
	 */
	exports.ntohs = function(b, i) {
		return ((0xff & b[i]) << 8) | 
		       ((0xff & b[i + 1]));
	};


	/**
	 * Convert a 16-bit quantity (short integer) from network byte order to host byte order (Big-Endian to Little-Endian).
	 *
	 * @param {string} s String to read value from
	 * @param {number} i Zero-based index at which to read from s
	 * @returns {number}
	 */
	exports.ntohsStr = function(s, i) {
		return ((0xff & s.charCodeAt(i)) << 8) |
		       ((0xff & s.charCodeAt(i + 1)));
	};


	/**
	 * Convert a 32-bit quantity (long integer) from host byte order to network byte order (Little-Endian to Big-Endian).
	 *
	 * @param {Array|Buffer} b Array of octets or a nodejs Buffer
	 * @param {number} i Zero-based index at which to write into b
	 * @param {number} v Value to convert
	 */
	exports.htonl = function(b, i, v) {
		b[i] = (0xff & (v >> 24));
		b[i + 1] = (0xff & (v >> 16));
		b[i + 2] = (0xff & (v >> 8));
		b[i + 3] = (0xff & (v));
	};


	/**
	 * Convert a 32-bit quantity (long integer) from network byte order to host byte order (Big-Endian to Little-Endian).
	 *
	 * @param {Array|Buffer} b Array of octets or a nodejs Buffer to read value from
	 * @param {number} i Zero-based index at which to read from b
	 * @returns {number}
	 */
	exports.ntohl = function(b, i) {
		return ((0xff & b[i]) << 24) |
		       ((0xff & b[i + 1]) << 16) |
		       ((0xff & b[i + 2]) << 8) |
		       ((0xff & b[i + 3]));
	};


	/**
	 * Convert a 32-bit quantity (long integer) from network byte order to host byte order (Big-Endian to Little-Endian).
	 *
	 * @param {string} s String to read value from
	 * @param {number} i Zero-based index at which to read from s
	 * @returns {number}
	 */
	exports.ntohlStr = function(s, i) {
		return ((0xff & s.charCodeAt(i)) << 24) |
		       ((0xff & s.charCodeAt(i + 1)) << 16) |
		       ((0xff & s.charCodeAt(i + 2)) << 8) |
		       ((0xff & s.charCodeAt(i + 3)));
	};


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return Buffer.isBuffer(arg);
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function() {
	  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

	  ipaddr = {};

	  root = this;

	  if ((typeof module !== "undefined" && module !== null) && module.exports) {
	    module.exports = ipaddr;
	  } else {
	    root['ipaddr'] = ipaddr;
	  }

	  matchCIDR = function(first, second, partSize, cidrBits) {
	    var part, shift;
	    if (first.length !== second.length) {
	      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
	    }
	    part = 0;
	    while (cidrBits > 0) {
	      shift = partSize - cidrBits;
	      if (shift < 0) {
	        shift = 0;
	      }
	      if (first[part] >> shift !== second[part] >> shift) {
	        return false;
	      }
	      cidrBits -= partSize;
	      part += 1;
	    }
	    return true;
	  };

	  ipaddr.subnetMatch = function(address, rangeList, defaultName) {
	    var rangeName, rangeSubnets, subnet, _i, _len;
	    if (defaultName == null) {
	      defaultName = 'unicast';
	    }
	    for (rangeName in rangeList) {
	      rangeSubnets = rangeList[rangeName];
	      if (toString.call(rangeSubnets[0]) !== '[object Array]') {
	        rangeSubnets = [rangeSubnets];
	      }
	      for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
	        subnet = rangeSubnets[_i];
	        if (address.match.apply(address, subnet)) {
	          return rangeName;
	        }
	      }
	    }
	    return defaultName;
	  };

	  ipaddr.IPv4 = (function() {
	    function IPv4(octets) {
	      var octet, _i, _len;
	      if (octets.length !== 4) {
	        throw new Error("ipaddr: ipv4 octet count should be 4");
	      }
	      for (_i = 0, _len = octets.length; _i < _len; _i++) {
	        octet = octets[_i];
	        if (!((0 <= octet && octet <= 255))) {
	          throw new Error("ipaddr: ipv4 octet is a byte");
	        }
	      }
	      this.octets = octets;
	    }

	    IPv4.prototype.kind = function() {
	      return 'ipv4';
	    };

	    IPv4.prototype.toString = function() {
	      return this.octets.join(".");
	    };

	    IPv4.prototype.toByteArray = function() {
	      return this.octets.slice(0);
	    };

	    IPv4.prototype.match = function(other, cidrRange) {
	      if (other.kind() !== 'ipv4') {
	        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
	      }
	      return matchCIDR(this.octets, other.octets, 8, cidrRange);
	    };

	    IPv4.prototype.SpecialRanges = {
	      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
	      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
	      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
	      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
	      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
	      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
	      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
	    };

	    IPv4.prototype.range = function() {
	      return ipaddr.subnetMatch(this, this.SpecialRanges);
	    };

	    IPv4.prototype.toIPv4MappedAddress = function() {
	      return ipaddr.IPv6.parse("::ffff:" + (this.toString()));
	    };

	    return IPv4;

	  })();

	  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

	  ipv4Regexes = {
	    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
	    longValue: new RegExp("^" + ipv4Part + "$", 'i')
	  };

	  ipaddr.IPv4.parser = function(string) {
	    var match, parseIntAuto, part, shift, value;
	    parseIntAuto = function(string) {
	      if (string[0] === "0" && string[1] !== "x") {
	        return parseInt(string, 8);
	      } else {
	        return parseInt(string);
	      }
	    };
	    if (match = string.match(ipv4Regexes.fourOctet)) {
	      return (function() {
	        var _i, _len, _ref, _results;
	        _ref = match.slice(1, 6);
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(parseIntAuto(part));
	        }
	        return _results;
	      })();
	    } else if (match = string.match(ipv4Regexes.longValue)) {
	      value = parseIntAuto(match[1]);
	      if (value > 0xffffffff || value < 0) {
	        throw new Error("ipaddr: address outside defined range");
	      }
	      return ((function() {
	        var _i, _results;
	        _results = [];
	        for (shift = _i = 0; _i <= 24; shift = _i += 8) {
	          _results.push((value >> shift) & 0xff);
	        }
	        return _results;
	      })()).reverse();
	    } else {
	      return null;
	    }
	  };

	  ipaddr.IPv6 = (function() {
	    function IPv6(parts) {
	      var part, _i, _len;
	      if (parts.length !== 8) {
	        throw new Error("ipaddr: ipv6 part count should be 8");
	      }
	      for (_i = 0, _len = parts.length; _i < _len; _i++) {
	        part = parts[_i];
	        if (!((0 <= part && part <= 0xffff))) {
	          throw new Error("ipaddr: ipv6 part should fit to two octets");
	        }
	      }
	      this.parts = parts;
	    }

	    IPv6.prototype.kind = function() {
	      return 'ipv6';
	    };

	    IPv6.prototype.toString = function() {
	      var compactStringParts, part, pushPart, state, stringParts, _i, _len;
	      stringParts = (function() {
	        var _i, _len, _ref, _results;
	        _ref = this.parts;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(part.toString(16));
	        }
	        return _results;
	      }).call(this);
	      compactStringParts = [];
	      pushPart = function(part) {
	        return compactStringParts.push(part);
	      };
	      state = 0;
	      for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
	        part = stringParts[_i];
	        switch (state) {
	          case 0:
	            if (part === '0') {
	              pushPart('');
	            } else {
	              pushPart(part);
	            }
	            state = 1;
	            break;
	          case 1:
	            if (part === '0') {
	              state = 2;
	            } else {
	              pushPart(part);
	            }
	            break;
	          case 2:
	            if (part !== '0') {
	              pushPart('');
	              pushPart(part);
	              state = 3;
	            }
	            break;
	          case 3:
	            pushPart(part);
	        }
	      }
	      if (state === 2) {
	        pushPart('');
	        pushPart('');
	      }
	      return compactStringParts.join(":");
	    };

	    IPv6.prototype.toByteArray = function() {
	      var bytes, part, _i, _len, _ref;
	      bytes = [];
	      _ref = this.parts;
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        part = _ref[_i];
	        bytes.push(part >> 8);
	        bytes.push(part & 0xff);
	      }
	      return bytes;
	    };

	    IPv6.prototype.toNormalizedString = function() {
	      var part;
	      return ((function() {
	        var _i, _len, _ref, _results;
	        _ref = this.parts;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          part = _ref[_i];
	          _results.push(part.toString(16));
	        }
	        return _results;
	      }).call(this)).join(":");
	    };

	    IPv6.prototype.match = function(other, cidrRange) {
	      if (other.kind() !== 'ipv6') {
	        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
	      }
	      return matchCIDR(this.parts, other.parts, 16, cidrRange);
	    };

	    IPv6.prototype.SpecialRanges = {
	      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
	      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
	      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
	      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
	      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
	      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
	      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
	      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
	      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
	      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
	      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
	    };

	    IPv6.prototype.range = function() {
	      return ipaddr.subnetMatch(this, this.SpecialRanges);
	    };

	    IPv6.prototype.isIPv4MappedAddress = function() {
	      return this.range() === 'ipv4Mapped';
	    };

	    IPv6.prototype.toIPv4Address = function() {
	      var high, low, _ref;
	      if (!this.isIPv4MappedAddress()) {
	        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
	      }
	      _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
	      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
	    };

	    return IPv6;

	  })();

	  ipv6Part = "(?:[0-9a-f]+::?)+";

	  ipv6Regexes = {
	    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
	    transitional: new RegExp(("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)") + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
	  };

	  expandIPv6 = function(string, parts) {
	    var colonCount, lastColon, part, replacement, replacementCount;
	    if (string.indexOf('::') !== string.lastIndexOf('::')) {
	      return null;
	    }
	    colonCount = 0;
	    lastColon = -1;
	    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
	      colonCount++;
	    }
	    if (string[0] === ':') {
	      colonCount--;
	    }
	    if (string[string.length - 1] === ':') {
	      colonCount--;
	    }
	    replacementCount = parts - colonCount;
	    replacement = ':';
	    while (replacementCount--) {
	      replacement += '0:';
	    }
	    string = string.replace('::', replacement);
	    if (string[0] === ':') {
	      string = string.slice(1);
	    }
	    if (string[string.length - 1] === ':') {
	      string = string.slice(0, -1);
	    }
	    return (function() {
	      var _i, _len, _ref, _results;
	      _ref = string.split(":");
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        part = _ref[_i];
	        _results.push(parseInt(part, 16));
	      }
	      return _results;
	    })();
	  };

	  ipaddr.IPv6.parser = function(string) {
	    var match, parts;
	    if (string.match(ipv6Regexes['native'])) {
	      return expandIPv6(string, 8);
	    } else if (match = string.match(ipv6Regexes['transitional'])) {
	      parts = expandIPv6(match[1].slice(0, -1), 6);
	      if (parts) {
	        parts.push(parseInt(match[2]) << 8 | parseInt(match[3]));
	        parts.push(parseInt(match[4]) << 8 | parseInt(match[5]));
	        return parts;
	      }
	    }
	    return null;
	  };

	  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
	    return this.parser(string) !== null;
	  };

	  ipaddr.IPv4.isValid = ipaddr.IPv6.isValid = function(string) {
	    var e;
	    try {
	      new this(this.parser(string));
	      return true;
	    } catch (_error) {
	      e = _error;
	      return false;
	    }
	  };

	  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {
	    var parts;
	    parts = this.parser(string);
	    if (parts === null) {
	      throw new Error("ipaddr: string is not formatted like ip address");
	    }
	    return new this(parts);
	  };

	  ipaddr.isValid = function(string) {
	    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
	  };

	  ipaddr.parse = function(string) {
	    if (ipaddr.IPv6.isValid(string)) {
	      return ipaddr.IPv6.parse(string);
	    } else if (ipaddr.IPv4.isValid(string)) {
	      return ipaddr.IPv4.parse(string);
	    } else {
	      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
	    }
	  };

	  ipaddr.process = function(string) {
	    var addr;
	    addr = this.parse(string);
	    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
	      return addr.toIPv4Address();
	    } else {
	      return addr;
	    }
	  };

	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46)(module)))

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		"name": "elliptic",
		"version": "0.16.0",
		"description": "EC cryptography",
		"main": "lib/elliptic.js",
		"scripts": {
			"test": "mocha --reporter=spec test/*-test.js"
		},
		"repository": {
			"type": "git",
			"url": "git@github.com:indutny/elliptic"
		},
		"keywords": [
			"EC",
			"Elliptic",
			"curve",
			"Cryptography"
		],
		"author": {
			"name": "Fedor Indutny",
			"email": "fedor@indutny.com"
		},
		"license": "MIT",
		"bugs": {
			"url": "https://github.com/indutny/elliptic/issues"
		},
		"homepage": "https://github.com/indutny/elliptic",
		"devDependencies": {
			"browserify": "^3.44.2",
			"mocha": "^1.18.2",
			"uglify-js": "^2.4.13"
		},
		"dependencies": {
			"bn.js": "^0.16.0",
			"brorand": "^1.0.1",
			"hash.js": "^0.3.2",
			"inherits": "^2.0.1"
		},
		"readme": "# Elliptic [![Build Status](https://secure.travis-ci.org/indutny/elliptic.png)](http://travis-ci.org/indutny/elliptic)\n\nFast elliptic-curve cryptography in a plain javascript implementation.\n\nNOTE: Please take a look at http://safecurves.cr.yp.to/ before choosing a curve\nfor your cryptography operations.\n\n## Incentive\n\nECC is much slower than regular RSA cryptography, the JS implementations are\neven more slower.\n\n## Benchmarks\n\n```bash\n$ node benchmarks/index.js\nBenchmarking: sign\nelliptic#sign x 262 ops/sec ±0.51% (177 runs sampled)\neccjs#sign x 55.91 ops/sec ±0.90% (144 runs sampled)\n------------------------\nFastest is elliptic#sign\n========================\nBenchmarking: verify\nelliptic#verify x 113 ops/sec ±0.50% (166 runs sampled)\neccjs#verify x 48.56 ops/sec ±0.36% (125 runs sampled)\n------------------------\nFastest is elliptic#verify\n========================\nBenchmarking: gen\nelliptic#gen x 294 ops/sec ±0.43% (176 runs sampled)\neccjs#gen x 62.25 ops/sec ±0.63% (129 runs sampled)\n------------------------\nFastest is elliptic#gen\n========================\nBenchmarking: ecdh\nelliptic#ecdh x 136 ops/sec ±0.85% (156 runs sampled)\n------------------------\nFastest is elliptic#ecdh\n========================\n```\n\n## API\n\n### ECDSA\n\n```javascript\nvar EC = require('elliptic').ec;\n\n// Create and initialize EC context\n// (better do it once and reuse it)\nvar ec = new EC('secp256k1');\n\n// Generate keys\nvar key = ec.genKeyPair();\n\n// Sign message (must be an array, or it'll be treated as a hex sequence)\nvar msg = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nvar signature = key.sign(msg);\n\n// Export DER encoded signature in Array\nvar derSign = signature.toDER();\n\n// Verify signature\nconsole.log(key.verify(msg, derSign));\n```\n\n### ECDH\n\n```javascript\n// Generate keys\nvar key1 = ec.genKeyPair();\nvar key2 = ec.genKeyPair();\n\nvar shared1 = key1.derive(key2.getPublic());\nvar shared2 = key2.derive(key1.getPublic());\n\nconsole.log('Both shared secrets are BN instances');\nconsole.log(shared1.toString(16));\nconsole.log(shared2.toString(16));\n```\n\nNOTE: `.derive()` returns a [BN][1] instance.\n\n## Supported curves\n\nElliptic.js support following curve types:\n\n* Short Weierstrass\n* Montgomery\n* Edwards\n* Twisted Edwards\n\nFollowing curve 'presets' are embedded into the library:\n\n* `secp256k1`\n* `p192`\n* `p224`\n* `p256`\n* `curve25519`\n* `ed25519`\n\nNOTE: That `curve25519` could not be used for ECDSA, use `ed25519` instead.\n\n### Implementation details\n\nECDSA is using deterministic `k` value generation as per [RFC6979][0]. Most of\nthe curve operations are performed on non-affine coordinates (either projective\nor extended), various windowing techniques are used for different cases.\n\nAll operations are performed in reduction context using [bn.js][1], hashing is\nprovided by [hash.js][2]\n\n#### LICENSE\n\nThis software is licensed under the MIT License.\n\nCopyright Fedor Indutny, 2014.\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n\n[0]: http://tools.ietf.org/html/rfc6979\n[1]: https://github.com/indutny/bn.js\n[2]: https://github.com/indutny/hash.js\n",
		"readmeFilename": "README.md",
		"_id": "elliptic@0.16.0",
		"_shasum": "9bc84e75ccd97e3e452c97371726c535314d1a57",
		"_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-0.16.0.tgz",
		"_from": "https://registry.npmjs.org/elliptic/-/elliptic-0.16.0.tgz"
	}

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		"name": "bitcore",
		"version": "0.9.5",
		"description": "A pure and powerful JavaScript Bitcoin library.",
		"author": {
			"name": "BitPay",
			"email": "dev@bitpay.com"
		},
		"main": "index.js",
		"scripts": {
			"lint": "gulp lint",
			"test": "gulp test",
			"coverage": "gulp coverage",
			"build": "gulp"
		},
		"contributors": [
			{
				"name": "Daniel Cousens",
				"email": "bitcoin@dcousens.com"
			},
			{
				"name": "Esteban Ordano",
				"email": "eordano@gmail.com"
			},
			{
				"name": "Gordon Hall",
				"email": "gordon@bitpay.com"
			},
			{
				"name": "Jeff Garzik",
				"email": "jgarzik@bitpay.com"
			},
			{
				"name": "Kyle Drake",
				"email": "kyle@kyledrake.net"
			},
			{
				"name": "Manuel Araoz",
				"email": "manuelaraoz@gmail.com"
			},
			{
				"name": "Matias Alejo Garcia",
				"email": "ematiu@gmail.com"
			},
			{
				"name": "Ryan X. Charles",
				"email": "ryanxcharles@gmail.com"
			},
			{
				"name": "Stefan Thomas",
				"email": "moon@justmoon.net"
			},
			{
				"name": "Stephen Pair",
				"email": "stephen@bitpay.com"
			},
			{
				"name": "Wei Lu",
				"email": "luwei.here@gmail.com"
			}
		],
		"keywords": [
			"bitcoin",
			"bip32",
			"bip37",
			"bip70",
			"merge",
			"multisig"
		],
		"repository": {
			"type": "git",
			"url": "https://github.com/bitpay/bitcore.git"
		},
		"browser": {
			"request": "browser-request"
		},
		"dependencies": {
			"bn.js": "=0.16.1",
			"bs58": "=2.0.0",
			"elliptic": "=0.16.0",
			"hash.js": "=0.3.2",
			"inherits": "=2.0.1",
			"lodash": "=2.4.1",
			"sha512": "=0.0.1"
		},
		"devDependencies": {
			"bitcore-build": "git://github.com/bitpay/bitcore-build.git",
			"brfs": "^1.2.0",
			"chai": "^1.10.0",
			"gulp": "^3.8.10"
		},
		"license": "MIT",
		"gitHead": "85857bd0cc4da75037f3efe12cc823046e07895f",
		"bugs": {
			"url": "https://github.com/bitpay/bitcore/issues"
		},
		"homepage": "https://github.com/bitpay/bitcore",
		"_id": "bitcore@0.9.5",
		"_shasum": "39aa427769dfaf4d69e87bf2e4be69cc3fa68035",
		"_from": "bitcore@>=0.9.0 <0.10.0",
		"_npmVersion": "2.3.0",
		"_nodeVersion": "0.11.15",
		"_npmUser": {
			"name": "maraoz",
			"email": "manuelaraoz@gmail.com"
		},
		"maintainers": [
			{
				"name": "gasteve",
				"email": "stephen@pairhome.net"
			},
			{
				"name": "maraoz",
				"email": "manuelaraoz@gmail.com"
			},
			{
				"name": "eordano",
				"email": "eordano@gmail.com"
			},
			{
				"name": "yemel",
				"email": "angel.jardi@gmail.com"
			}
		],
		"dist": {
			"shasum": "39aa427769dfaf4d69e87bf2e4be69cc3fa68035",
			"tarball": "http://registry.npmjs.org/bitcore/-/bitcore-0.9.5.tgz"
		},
		"directories": {},
		"_resolved": "https://registry.npmjs.org/bitcore/-/bitcore-0.9.5.tgz",
		"readme": "ERROR: No README data found!"
	}

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		"name": "bitcore-p2p",
		"version": "0.9.1",
		"description": "Interface to the bitcoin P2P network for bitcore",
		"author": {
			"name": "BitPay",
			"email": "dev@bitpay.com"
		},
		"main": "index.js",
		"scripts": {
			"lint": "gulp lint",
			"test": "gulp test:node",
			"coverage": "gulp coverage",
			"build": "gulp"
		},
		"contributors": [
			{
				"name": "Yemel Jardi",
				"email": "yemel@bitpay.com"
			},
			{
				"name": "Braydon Fuller",
				"email": "braydon@bitpay.com"
			},
			{
				"name": "Ryan X. Charles",
				"email": "ryan@bitpay.com"
			},
			{
				"name": "Eric Martindale",
				"email": "eric@bitpay.com"
			},
			{
				"name": "Philip Hutchins",
				"email": "philip@bitpay.com"
			},
			{
				"name": "Manuel Araoz",
				"email": "maraoz@bitpay.com"
			},
			{
				"name": "Esteban Ordano",
				"email": "eordano@gmail.com"
			},
			{
				"name": "Elichai Turkel"
			}
		],
		"keywords": [
			"bitcoin",
			"bitcore"
		],
		"repository": {
			"type": "git",
			"url": "https://github.com/bitpay/bitcore-p2p.git"
		},
		"dependencies": {
			"bitcore": "^0.9.0",
			"bufferput": "^0.1.2",
			"buffers": "^0.1.1",
			"socks5-client": "^0.3.6"
		},
		"devDependencies": {
			"bitcore-build": "git://github.com/bitpay/bitcore-build.git",
			"brfs": "^1.2.0",
			"chai": "~1.10.0",
			"gulp": "^3.8.10",
			"lodash": "^2.4.1",
			"sinon": "^1.12.2"
		},
		"license": "MIT",
		"gitHead": "38b6602ff35e87958524af6b4f9de09126f2d3fc",
		"readme": "P2P Networking capabilities for bitcore\n=======\n\n[![NPM Package](https://img.shields.io/npm/v/bitcore-p2p.svg?style=flat-square)](https://www.npmjs.org/package/bitcore-p2p)\n[![Build Status](https://img.shields.io/travis/bitpay/bitcore-p2p.svg?branch=master&style=flat-square)](https://travis-ci.org/bitpay/bitcore-p2p)\n[![Coverage Status](https://img.shields.io/coveralls/bitpay/bitcore-p2p.svg?style=flat-square)](https://coveralls.io/r/bitpay/bitcore-p2p?branch=master)\n\nbitcore-p2p adds support for connecting to the bitcoin p2p network on node.\n\nSee [the main bitcore repo](https://github.com/bitpay/bitcore) for more information.\n\n## Getting Started\n\n```sh\nnpm install bitcore-p2p\n```\n```sh\nbower install bitcore-p2p\n```\nIn order to connect to the bitcore network, you'll need to know the IP address of at least one node of the network. You can do that by using the known DNS servers. Then, you can connect to it:\n\n```javascript\nvar Peer = require('bitcore-p2p').Peer;\n\nvar peer = new Peer('0.0.0.0');\n\npeer.on('ready', function() {\n  // peer info\n  console.log(peer.version, peer.subversion, peer.bestHeight);\n});\npeer.on('disconnect', function() {\n  console.log('connection closed');\n});\npeer.connect();\n```\n\nThen, you can get information from other peers by using:\n\n```javascript\n// handle events\npeer.on('inv', function(message) {\n  // message.inventory[]\n});\npeer.on('tx', function(message) {\n  // message.transaction\n});\n```\n\nTake a look at the [bitcore guide](http://bitcore.io/guide/peer.html) on the usage of the `Peer` class.\n\n## Contributing\n\nSee [CONTRIBUTING.md](https://github.com/bitpay/bitcore) on the main bitcore repo for information about how to contribute.\n\n## License\n\nCode released under [the MIT license](https://github.com/bitpay/bitcore/blob/master/LICENSE).\n\nCopyright 2013-2015 BitPay, Inc. Bitcore is a trademark maintained by BitPay, Inc.\n\n",
		"readmeFilename": "README.md",
		"bugs": {
			"url": "https://github.com/bitpay/bitcore-p2p/issues"
		},
		"homepage": "https://github.com/bitpay/bitcore-p2p",
		"_id": "bitcore-p2p@0.9.1",
		"_shasum": "51a65830b54e00d526499c4f56c5db9643383047",
		"_from": "../../../../../var/folders/ht/zgv6kqxn6w7gklpbs8qp7bpr0000gn/T/npm-95835-fa051fd6/git-cache-34ee3f843bcb/38b6602ff35e87958524af6b4f9de09126f2d3fc",
		"_resolved": "git://github.com/throughnothing/bitcore-p2p.git#38b6602ff35e87958524af6b4f9de09126f2d3fc"
	}

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS)
				return 62 // '+'
			if (code === SLASH)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}(false ? (this.base64js = {}) : exports))


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	exports.read = function(buffer, offset, isLE, mLen, nBytes) {
	  var e, m,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      nBits = -7,
	      i = isLE ? (nBytes - 1) : 0,
	      d = isLE ? -1 : 1,
	      s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity);
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};

	exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
	      i = isLE ? 0 : (nBytes - 1),
	      d = isLE ? 1 : -1,
	      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

	  buffer[offset + i - d] |= s * 128;
	};


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * isArray
	 */

	var isArray = Array.isArray;

	/**
	 * toString
	 */

	var str = Object.prototype.toString;

	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */

	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(67)

	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)

	module.exports = Hmac

	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg

	  var blocksize = (alg === 'sha512') ? 128 : 64

	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key

	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }

	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)

	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }

	  this._hash = createHash(alg).update(ipad)
	}

	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}

	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}

	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}

	module.exports = { hash: hash };
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(125);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;

	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;

	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);

	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(48);
	var Transform = __webpack_require__(49);
	var inherits = __webpack_require__(37);
	var modes = __webpack_require__(50);
	var StreamCipher = __webpack_require__(74);
	var ebtk = __webpack_require__(68);

	inherits(Decipher, Transform);
	function Decipher(mode, key, iv) {
	  if (!(this instanceof Decipher)) {
	    return new Decipher(mode, key, iv);
	  }
	  Transform.call(this);
	  this._cache = new Splitter();
	  this._last = void 0;
	  this._cipher = new aes.AES(key);
	  this._prev = new Buffer(iv.length);
	  iv.copy(this._prev);
	  this._mode = mode;
	}
	Decipher.prototype._transform = function (data, _, next) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  while ((chunk = this._cache.get())) {
	    thing = this._mode.decrypt(this, chunk);
	    this.push(thing);
	  }
	  next();
	};
	Decipher.prototype._flush = function (next) {
	  var chunk = this._cache.flush();
	  if (!chunk) {
	    return next;
	  }

	  this.push(unpad(this._mode.decrypt(this, chunk)));

	  next();
	};

	function Splitter() {
	   if (!(this instanceof Splitter)) {
	    return new Splitter();
	  }
	  this.cache = new Buffer('');
	}
	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data]);
	};

	Splitter.prototype.get = function () {
	  if (this.cache.length > 16) {
	    var out = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    return out;
	  }
	  return null;
	};
	Splitter.prototype.flush = function () {
	  if (this.cache.length) {
	    return this.cache;
	  }
	};
	function unpad(last) {
	  var padded = last[15];
	  if (padded === 16) {
	    return;
	  }
	  return last.slice(0, 16 - padded);
	}

	var modelist = {
	  ECB: __webpack_require__(72),
	  CBC: __webpack_require__(69),
	  CFB: __webpack_require__(70),
	  OFB: __webpack_require__(73),
	  CTR: __webpack_require__(71)
	};

	module.exports = function (crypto) {
	  function createDecipheriv(suite, password, iv) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    if (typeof iv === 'string') {
	      iv = new Buffer(iv);
	    }
	    if (typeof password === 'string') {
	      password = new Buffer(password);
	    }
	    if (password.length !== config.key/8) {
	      throw new TypeError('invalid key length ' + password.length);
	    }
	    if (iv.length !== config.iv) {
	      throw new TypeError('invalid iv length ' + iv.length);
	    }
	    if (config.type === 'stream') {
	      return new StreamCipher(modelist[config.mode], password, iv, true);
	    }
	    return new Decipher(modelist[config.mode], password, iv);
	  }

	  function createDecipher (suite, password) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    var keys = ebtk(crypto, password, config.key, config.iv);
	    return createDecipheriv(suite, keys.key, keys.iv);
	  }
	  return {
	    createDecipher: createDecipher,
	    createDecipheriv: createDecipheriv
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(48);
	var Transform = __webpack_require__(49);
	var inherits = __webpack_require__(37);
	var modes = __webpack_require__(50);
	var ebtk = __webpack_require__(68);
	var StreamCipher = __webpack_require__(74);
	inherits(Cipher, Transform);
	function Cipher(mode, key, iv) {
	  if (!(this instanceof Cipher)) {
	    return new Cipher(mode, key, iv);
	  }
	  Transform.call(this);
	  this._cache = new Splitter();
	  this._cipher = new aes.AES(key);
	  this._prev = new Buffer(iv.length);
	  iv.copy(this._prev);
	  this._mode = mode;
	}
	Cipher.prototype._transform = function (data, _, next) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  while ((chunk = this._cache.get())) {
	    thing = this._mode.encrypt(this, chunk);
	    this.push(thing);
	  }
	  next();
	};
	Cipher.prototype._flush = function (next) {
	  var chunk = this._cache.flush();
	  this.push(this._mode.encrypt(this, chunk));
	  this._cipher.scrub();
	  next();
	};


	function Splitter() {
	   if (!(this instanceof Splitter)) {
	    return new Splitter();
	  }
	  this.cache = new Buffer('');
	}
	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data]);
	};

	Splitter.prototype.get = function () {
	  if (this.cache.length > 15) {
	    var out = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    return out;
	  }
	  return null;
	};
	Splitter.prototype.flush = function () {
	  var len = 16 - this.cache.length;
	  var padBuff = new Buffer(len);

	  var i = -1;
	  while (++i < len) {
	    padBuff.writeUInt8(len, i);
	  }
	  var out = Buffer.concat([this.cache, padBuff]);
	  return out;
	};
	var modelist = {
	  ECB: __webpack_require__(72),
	  CBC: __webpack_require__(69),
	  CFB: __webpack_require__(70),
	  OFB: __webpack_require__(73),
	  CTR: __webpack_require__(71)
	};
	module.exports = function (crypto) {
	  function createCipheriv(suite, password, iv) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    if (typeof iv === 'string') {
	      iv = new Buffer(iv);
	    }
	    if (typeof password === 'string') {
	      password = new Buffer(password);
	    }
	    if (password.length !== config.key/8) {
	      throw new TypeError('invalid key length ' + password.length);
	    }
	    if (iv.length !== config.iv) {
	      throw new TypeError('invalid iv length ' + iv.length);
	    }
	    if (config.type === 'stream') {
	      return new StreamCipher(modelist[config.mode], password, iv);
	    }
	    return new Cipher(modelist[config.mode], password, iv);
	  }
	  function createCipher (suite, password) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    var keys = ebtk(crypto, password, config.key, config.iv);
	    return createCipheriv(suite, keys.key, keys.iv);
	  }
	  return {
	    createCipher: createCipher,
	    createCipheriv: createCipheriv
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function (crypto, exports) {
	  exports = exports || {};
	  var ciphers = __webpack_require__(128)(crypto);
	  exports.createCipher = ciphers.createCipher;
	  exports.createCipheriv = ciphers.createCipheriv;
	  var deciphers = __webpack_require__(127)(crypto);
	  exports.createDecipher = deciphers.createDecipher;
	  exports.createDecipheriv = deciphers.createDecipheriv;
	  var modes = __webpack_require__(50);
	  function listCiphers () {
	    return Object.keys(modes);
	  }
	  exports.listCiphers = listCiphers;
	};



/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }

	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')

	    setTimeout(function() {
	      var result

	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }

	      callback(undefined, result)
	    })
	  }

	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')

	    if (iterations < 0)
	      throw new TypeError('Bad iterations')

	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')

	    if (keylen < 0)
	      throw new TypeError('Bad key length')

	    digest = digest || 'sha1'

	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)

	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)

	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)

	      var U = crypto.createHmac(digest, password).update(block1).digest()

	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen

	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }

	      U.copy(T, 0, 0, hLen)

	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()

	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }

	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }

	    return DK
	  }

	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160



	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];

	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};

	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};

	var processBlock = function (H, M, offset) {

	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];

	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }

	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;

	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;

	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};

	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}

	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}

	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}

	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}

	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}

	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}

	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');

	  var m = bytesToWords(message);

	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;

	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );

	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }

	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];

	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }

	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}


	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).Buffer))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function (Buffer) {

	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }

	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }

	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }

	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block

	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)

	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }

	      s += ch
	      f += ch

	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s

	    return this
	  }

	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8

	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80

	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)

	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }

	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)

	    var hash = this._update(this._block) || this._hash()

	    return enc ? hash.toString(enc) : hash
	  }

	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }

	  return Hash
	}


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}

	var Buffer = __webpack_require__(1).Buffer
	var Hash   = __webpack_require__(132)(Buffer)

	exports.sha1 = __webpack_require__(134)(Buffer, Hash)
	exports.sha256 = __webpack_require__(135)(Buffer, Hash)
	exports.sha512 = __webpack_require__(136)(Buffer, Hash)


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = __webpack_require__(16).inherits

	module.exports = function (Buffer, Hash) {

	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0

	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)

	  var POOL = []

	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()

	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)

	    this._h = null
	    this.init()
	  }

	  inherits(Sha1, Hash)

	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0

	    Hash.prototype.init.call(this)
	    return this
	  }

	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {

	    var a, b, c, d, e, _a, _b, _c, _d, _e

	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e

	    var w = this._w

	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)

	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )

	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }

	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }

	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }

	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }

	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }

	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }

	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }

	  return Sha1
	}


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(16).inherits

	module.exports = function (Buffer, Hash) {

	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]

	  var W = new Array(64)

	  function Sha256() {
	    this.init()

	    this._w = W //new Array(64)

	    Hash.call(this, 16*4, 14*4)
	  }

	  inherits(Sha256, Hash)

	  Sha256.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }

	  function R (X, n) {
	    return (X >>> n);
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }

	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }

	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }

	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }

	  Sha256.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]

	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w

	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }

	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0

	  };

	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)

	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)

	    return H
	  }

	  return Sha256

	}


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(16).inherits

	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]

	  var W = new Array(160)

	  function Sha512() {
	    this.init()
	    this._w = W

	    Hash.call(this, 128, 112)
	  }

	  inherits(Sha512, Hash)

	  Sha512.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  Sha512.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0

	    for (var i = 0; i < 80; i++) {
	      var j = i * 2

	      var Wi, Wil

	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)

	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]

	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]

	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)

	        W[j] = Wi
	        W[j + 1] = Wil
	      }

	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)

	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]

	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)

	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }

	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0

	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }

	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)

	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }

	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)

	    return H
	  }

	  return Sha512

	}


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(130)

	module.exports = function (crypto, exports) {
	  exports = exports || {}

	  var exported = pbkdf2Export(crypto)

	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync

	  return exports
	}


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(153)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1).Buffer))

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(46)(module), (function() { return this; }())))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};

	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return map(objectKeys(obj), function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (isArray(obj[k])) {
	        return map(obj[k], function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};

	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};

	function map (xs, f) {
	  if (xs.map) return xs.map(f);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    res.push(f(xs[i], i));
	  }
	  return res;
	}

	var objectKeys = Object.keys || function (obj) {
	  var res = [];
	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
	  }
	  return res;
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(140);
	exports.encode = exports.stringify = __webpack_require__(141);


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(22)


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(75)


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(76);
	exports.Stream = __webpack_require__(31);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(52);
	exports.Duplex = __webpack_require__(22);
	exports.Transform = __webpack_require__(51);
	exports.PassThrough = __webpack_require__(75);


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(51)


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(52)


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(139);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(142);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* (ignored) */

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* (ignored) */

/***/ }
/******/ ])